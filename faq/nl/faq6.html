<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Netwerken</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2009 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<a href="../../nl/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>
<font color="#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[Naar Sectie 5 - Het Systeem vanaf Broncode Bouwen]</a>
<a href="faq7.html">[Naar Sectie 7 - Toetsenbord en Scherm Bediening]</a>
</font>

<h1><font color="#e00000">6 - Netwerken</font></h1>
<hr>

<p>
<h3>Inhoudsopgave</h3>
<ul>
<li><a href= "#Intro" >6.1 - Voor we verder gaan</a>
<li><a href= "#Setup" >6.2 - Netwerkconfiguratie</a>
<ul>
  <li><a href="#Setup.if"      >6.2.1 - Identificeren en instellen van uw
    netwerkinterfaces</a>
  <li><a href="#Setup.gateway" >6.2.2 - Standaard gateway</a>
  <li><a href="#Setup.resolver">6.2.3 - DNS vertaling</a>
  <li><a href="#Setup.myname"  >6.2.4 - Host naam</a>
  <li><a href="#Setup.activate">6.2.5 - Wijzigingen activeren</a>
  <li><a href="#Setup.chkroute">6.2.6 - Routes nakijken</a>
  <li><a href="#Setup.forward" >6.2.7 - Uw OpenBSD machine instellen als
    gateway</a>
  <li><a href="#Setup.aliases" >6.2.8 - Aliassen instellen op interfaces</a>
</ul>
<li><a href= "#PF"    >6.3 - Hoe filter en firewall ik met OpenBSD?</a>
<li><a href= "#DHCP"  >6.4 - Dynamic Host Configuration Protocol (DHCP)</a>
<ul>
  <li><a href="#DHCPclient">6.4.1 - DHCP Client</a>
  <li><a href="#DHCPserver">6.4.2 - DHCP Server</a>
</ul>
<li><a href= "#PPP"   >6.5 - Point to Point Protocol</a>
<li><a href= "#Tuning">6.6 - Netwerkparameters tunen</a>
<li><a href= "#NFS"   >6.7 - NFS gebruiken</a>
<li><a href= "#Bridge">6.9 - Een bridge opzetten met OpenBSD</a>
<li><a href= "#PXE"   >6.10 - Hoe boot ik met PXE?</a>
<li><a href= "#CARP"  >6.11 - Het Common Address Redundancy Protocol (CARP)</a>
<li><a href="#OpenNTPD">6.12 - OpenNTPD gebruiken</a>
<li><a href="#Wireless">6.13 - Wat zijn mijn draadloze netwerkmogelijkheden?</a>
<li><a href="#Multipath">6.14 - Hoe kan ik gelijke-kost multipath routering
	doen?</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>6.1 - Voor we verder gaan</h2>

<p>
Voor het overgrote deel van dit document helpt het als u de
<a href="faq5.html">Kernel Configuratie en Instelling</a> sectie van de FAQ, de
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> en
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a> man pagina's gelezen en tenminste gedeeltelijk begrepen hebt.

<p>
Als u een netwerkbeheerder bent, en u bent routeringsprotocols aan het
opzetten, als u uw OpenBSD machine als een router gebruikt, als u diep
moet ingaan op IP networken, moet u echt
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">Understanding
IP Addressing</a> lezen.
Dit is een uistekend document.  "Understanding IP Addressing" bevat
fundamentele kennis waarop u kan bouwen wanneer u werkt met IP netwerken,
vooral wanneer u met één of meer netwerken te maken hebt of er
verantwoordelijk voor bent.

<p>
Indien u werkt met toepassingen zoals web servers, ftp servers en
mail servers, kan u uw voordeel doen door
<a href="http://www.rfc-editor.org/rfc.html">de RFC's te lezen</a>.
Waarschijnlijk kan u ze niet allemaal lezen. Kies er een aantal onderwerpen
uit die u interesseren of die u gebruikt in uw netwerkomgeving. Zoek ze op,
kom te weten hoe ze bedoeld zijn om te werken. De RFC's definiëren
vele (duizenden) standaarden voor protocols op het Internet en hoe ze
zouden moeten werken.

<p>
<a name="Setup"></a>
<h2>6.2 - Netwerkconfiguratie</h2>

Normaal gezien wordt OpenBSD initieel geconfigureerd door het
<a href="faq4.html">installatie</a>proces.
Het is echter goed te begrijpen wat er tijdens dat proces gebeurt en hoe
het werkt.
Alle netwerkconfiguratie gebeurt met eenvoudige tekstbestanden in de
<i>/etc</i> directory.

<p>
<a name="Setup.if"></a>
<h3>6.2.1 - Identificeren en instellen van uw netwerkinterfaces</h3>

<p>
In OpenBSD worden interfaces benoemd volgens het kaarttype, niet volgens het
verbindingstype. U kan uw netwerkkaart geïnitialiseerd zien worden tijdens
het bootproces, of na het bootproces door gebruik van het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
commando. U hebt ook de gelegenheid om uw netwerk interfaces te zien met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> commando.
Hier is bijvoorbeeld de uitvoer van dmesg voor een Intel Fast Ethernet
netwerkkaart, die de device naam fxp gebruikt.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
Als u niet weet wat uw device naam is, kijk dan naar de
<a href="../../nl/plat.html">ondersteunde hardware lijst</a> voor uw platform.
U zal daar een lijst terugvinden van veel voorkomende kaartnamen en hun
OpenBSD device namen. Combineer de korte alfabetische device naam
(zoals fxp) met een nummer toegekend door de kernel en u hebt een
interface naam (zoals fxp0).
Het nummer wordt toegekend op basis van verscheidene criteria, afhankelijk
van de kaart en andere details van het systeem.
Sommige kaarten worden toegekend volgens de volgorde waarin ze gevonden worden
tijdens het "proben" van een bus.
Andere kunnen toegekend worden op basis van hardware-instellingen of
MAC adres.

<p>
U kan te weten komen welke netwerk interfaces er geïdentificeerd zijn
met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
utility. Het volgende commando zal alle netwerk interfaces op een systeem
weergeven. Deze voorbeelduitvoer toont ons slechts één fysische
Ethernet interface,
een <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>.

<blockquote><pre>
$ <b>ifconfig</b>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet 127.0.0.1 netmask 0xff000000
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
pfsync0: flags=0&lt;&gt; mtu 2020
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010&lt;POINTOPOINT,LINK0,MULTICAST&gt; mtu 1450
carp0: flags=0&lt;&gt; mtu 1500
carp1: flags=0&lt;&gt; mtu 1500
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></blockquote>

<p>
Zoals u hier kan zien, geeft
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
ons veel meer informatie dan we op dit punt nodig hebben. Maar het laat
ons wel toe om onze interface te zien. In het bovenstaande voorbeeld
is de interface kaart al geconfigureerd. Dit spreekt voor zich omdat er al
een IP netwerk geconfigureerd is op fxp0, vandaar de waarden &quot;inet
10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;.  Ook de
<b>UP</b> en <b>RUNNING</b> vlaggen zijn aangezet.

<p>
Tenslotte zal u merken dat verscheidene andere interfaces standaard
ingeschakeld zijn. Dit zijn virtuele interfaces die voor verschillende
functies dienen. De volgende manual pagina's beschrijven ze:

<ul>
<!-- XXXrelease -->
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a>
 - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4">pflog</a>
 - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a>
 - SLIP Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a>
 - Point to Point Protocol
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a>
 - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
 - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a>
 - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a>
 - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a>
 - Generic IPv4/IPv6 Tunnel Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp</a>
 - Common Address Redundancy Protocol Interface
</ul>

<p>
De interface wordt tijdens het opstarten geconfigureerd met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">/etc/hostname.<i>if</i>(5)</a>
bestanden, waarbij <i>if</i> vervangen zal worden door de volledige naam
van uw interface, in het bovenstaande voorbeeld is dat
<i>/etc/hostname.fxp0</i>.

<p>
De layout van dit bestand is eenvoudig:

<blockquote><pre>
address_family address netmask broadcast [andere opties]
</pre></blockquote>

Veel meer details over het formaat van dit bestand vindt u terug in de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>
man pagina.
U zal deze moeten lezen voor minder triviale configuraties.

<p>
Een typisch configuratiebestand, geconfigureerd voor een IPv4 adres,
zou er als volgt uitzien:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
In dit geval hebben we een IPv4 (inet) adres gedefinieerd, met als IP adres
10.0.0.38, als subnet mask 255.255.255.0, en zonder specifiek broadcastadres
(dat wordt standaard 10.0.0.255 in dit geval).

<p>
U zou ook media types voor Ethernet kunnen specificeren, als u bijvoorbeeld
100baseTX full-duplex mode zou willen forceren.

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
(Natuurlijk mag u nooit full duplex mode forceren tenzij beide uiteinden
van de verbinding hierop ingesteld zijn! Tenzij er speciale behoeften
zijn, worden de media instellingen beter achterwege gelaten.
Een meer waarschijnlijke situatie zou kunnen zijn dat u 10base-T of half
duplex forceert indien uw infrastructuur dat vereist.)

<p>
Of, u wil misschien speciale vlaggen specifiek voor een bepaalde interface
gebruiken. Aan het formaat van het hostname bestand verandert niet veel!

<blockquote><pre>
$ <b>cat /etc/hostname.vlan0</b>
inet 172.21.0.31 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<a name="Setup.gateway"></a>
<h3>6.2.2 - Standaard gateway</h3>
Zet het IP adres van uw gateway in het bestand <i>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate&amp;sektion=5">/etc/mygate</a></i>.
Dit zal toelaten dat uw gateway ingesteld wordt bij het opstarten.
Dit bestand bestaat uit één lijn, met alleen het adres van de gateway van
deze machine:

<blockquote><pre>
10.0.0.1
</pre></blockquote>

Het is mogelijk om daar een symbolische naam te gebruiken, maar wees
voorzichtig: u kan niet veronderstellen dat dingen zoals de vertaler
("resolver") volledig
geconfigureerd of zelfs bereikbaar zijn tot NADAT de standaard gateway
geconfigureerd is.
Met andere woorden: het kan maar beter een IP adres zijn of iets dat
gedefinieerd is in het <i>/etc/hosts</i> bestand.

<a name="Setup.resolver"></a>
<h3>6.2.3 - DNS vertaling</h3>
DNS vertaling wordt beheerd door het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5"><i>/etc/resolv.conf</i></a>.
bestand.
Hier is een voorbeeld van een <i>/etc/resolv.conf</i> bestand:

<blockquote><pre>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

In dit geval zal de standaard domeinnaam <tt>example.com</tt> zijn,
er zijn twee DNS "resolvers", <tt>125.2.3.4</tt> en <tt>124.2.3.5</tt>,
gespecificeerd, en het <i>/etc/hosts</i> bestand zal geraadpleegd worden
vóór de DNS vertalers.

<p>
Zoals bij bijna alle Unix (en vele niet-Unix) systemen, is er een
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5"><i>/etc/hosts</i></a>
bestand dat kan gebruikt worden om systemen te specificeren die niet in
(of indien gebruikt met de bovenstaande "lookup" prioriteit, niet zoals
gewenst in) het formele DNS systeem zitten.

<p>
Indien u DHCP gebruikt, zal u <a href="#DHCP">6.4 - DHCP</a> willen lezen
en nota nemen van
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5">resolv.conf.tail(5)</a>.

<a name="Setup.myname"></a>
<h3>6.2.4 - Host naam</h3>
Elke Unix machine heeft een naam.
In OpenBSD wordt de naam gespecificeerd als een "Fully Qualified Domain Name"
(FQDN) in één lijn in het bestand
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=myname&amp;sektion=5"><i>/etc/myname</i></a>.
Indien deze machine "puffy" heet en in het domein "example.com" zit, dan zou
het bestand deze ene lijn bevatten:

<blockquote><pre>
puffy.example.com
</pre></blockquote>

<a name="Setup.activate"></a>
<h3>6.2.5 - Activating the changes</h3>
Vanaf hier kunt u ofwel herstarten of het <b>/etc/netstart</b>
script uitvoeren.
U kan dit doen door gewoon het volgende (als root) in te typen:

<blockquote><pre>
# <b>sh /etc/netstart</b>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>
 
<p>
Merk op dat dit enkele fouten produceerde. Door dit script uit te voeren,
herconfigureert u dingen die reeds geconfigureerd waren. Zodoende bestaan
sommige routes al in de kernel routeringstabel. Van hier af zou uw systeem
goed en wel draaiende en on-line moeten zijn. U kan opnieuw nagaan of uw
interface juist werd ingesteld met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.

<p>
Hoewel u op een OpenBSD systeem het netwerk volledig kan herconfigureren
zonder te herstarten, wordt het herstarten ERG aanbevolen na gelijk welke
significante herconfiguratie.
De reden hiervoor is dat de omgeving bij het opstarten een beetje verschillend
is dan wanneer het systeem volledig draaiende is.
Als u bijvoorbeeld een door DNS vertaalde symbolische naam had gespecificeerd
in één van de bestanden, dan zou u waarschijnlijk vaststellen dat het zoals
verwacht werkt na het herconfigureren, maar bij een initiële boot kan het
zijn dat uw externe vertaler ("resolver") niet beschikbaar is, en dus zal dan
de configuratie mislukken.

<a name="Setup.chkroute"></a>
<h3>6.2.6 - Routes nakijken</h3>
U kan uw routes nakijken via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>
of <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>.
Als u routeringsproblemen hebt, kunt u de -n vlag van route(8) gebruiken,
die de IP adressen weergeeft, veeleer dan een DNS lookup te doen en de
hostname weer te geven. Hier is een voorbeeld van het bekijken van uw
routeringstabellen met beide programma's.

<blockquote><pre>
$ <b>netstat -rn</b>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <b>route show</b>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.forward"></a>
<h3>6.2.7 - Uw OpenBSD machine instellen als een forwarding gateway</h3>

<p>
Dit is de basisinformatie die u nodig hebt om uw OpenBSD machine in te
stellen als een gateway (ook router genoemd). Als u OpenBSD gebruikt als
een router op het Internet, stellen we voor dat u ook de Packet Filter
setup instructies hieronder leest om mogelijk kwaadwillig verkeer te
blokkeren. Ook kan u, door de lage beschikbaarheid van
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a>
adressen vanwege netwerk service providers en regionale registers, misschien
eens kijken naar Network Address Translation voor informatie over hoe u
uw IP adresruimte kan bewaren.

<p>
De GENERIC kernel heeft al de mogelijkheid om IP Forwarding toe te laten,
maar dit moet ingeschakeld worden. U doet dit best met de 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
utility. Om dit permanent te wijzigen, bewerkt u het bestand
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf</a>
om IP Forwarding toe te laten. Om dit te doen voegt u de volgende lijn toe
in dat configuratiebestand.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Om deze wijziging door te voeren zonder te herstarten, zou u de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
utility rechtstreeks gebruiken. Onthou echter dat die verandering dan na
het herstarten niet meer van kracht is, en dat dit als root moet uitgevoerd
worden.

<blockquote><pre>
# <b>sysctl net.inet.ip.forwarding=1</b>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></blockquote>

<p>
Wijzig nu de routes op de andere hosts aan beide uiteinden. Er zijn vele
mogelijke gebruiken van OpenBSD als een router door software als
OpenBSD's eigen <a href="http://www.openbgpd.org/">OpenBGPD</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">routed(8)</a>,
<a href="http://sourceforge.net/projects/mrt">mrtd</a>,
<a href="http://www.zebra.org">zebra</a> en
<a href="http://www.quagga.net">quagga</a> te gebruiken.
OpenBSD heeft in de ports collectie ondersteuning voor zebra, quagga en mrtd.
OpenBGPD en routed worden geïnstalleerd als onderdeel van het base systeem.
OpenBSD ondersteunt
verscheidene T1, HSSI, ATM, FDDI, Ethernet en seriële (PPP/SLIP) interfaces.

<p>
<a name="Setup.aliases"></a>
<h3>6.2.8 - Aliassen instellen op een interface</h3>

<p>
OpenBSD heeft een eenvoudig mechanisme om IP aliassen in te stellen op een
interface. Om dit te doen bewerkt u het bestand
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"><i>/etc/hostname.&lt;if&gt;</i></a>.
Dit bestand wordt bij het opstarten gelezen door het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstart&amp;sektion=8">/etc/netstart(8)</a>
script, dat deel uitmaakt van de <a href="faq10.html#rc">rc
opstarthiërarchie</a>. In het voorbeeld veronderstellen we dat de
gebruiker een interface <b>dc0</b> heeft en zich op het netwerk 192.168.0.0
bevindt.
Andere belangrijke informatie:

<ul>
<li>IP voor dc0 is 192.168.0.2
<li>NETMASK is 255.255.255.0
</ul>

<p>
Een paar kanttekeningen bij aliassen. In OpenBSD gebruikt u alleen de
interface naam. Er is geen verschil tussen de eerste alias en de tweede
alias. In tegenstelling tot bij sommige andere besturingssystemen,
refereert OpenBSD er niet naar als dc0:0, dc0:1.  Als u met ifconfig
refereert naar een specifiek ge-aliased IP, of wanneer u een alias
toevoegt, zeg dan zeker "<tt>ifconfig int alias</tt>" in plaats van
gewoon "<tt>ifconfig int</tt>" op de commandolijn.
U kan aliassen verwijderen met "<tt>ifconfig int delete</tt>".

<p>
In de veronderstelling dat u meerdere IP adressen met aliassen gebruikt die
zich in hetzelfde IP subnet bevinden, wordt uw netmask instelling voor elke
alias 255.255.255.255. Ze hoeven niet het netmask te volgen van het eerste
IP dat aan de interface verbonden is. In dit voorbeeld,
<i>/etc/hostname.dc0</i>, worden twee aliassen toegevoegd aan het device
dc0, dat trouwens geconfigureerd was als 
192.168.0.2 netmask 255.255.255.0.

<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 NONE media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

<p>
Zodra u dit bestand hebt gemaakt, vereist het slechts een herstart
om in werking te treden. U kan echter de aliassen met de hand tevoorschijn
toveren met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
utility. Om de eerste alias te activeren zou u het volgende commando
gebruiken:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

(maar opnieuw wordt herstarten aanbevolen om uzelf ervan te verzekeren dat
u alles hebt ingegeven zoals u verwachtte!)

<p>
Om deze aliassen te bekijken moet u het volgende commando gebruiken:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="PF"></a>
<h2>6.3 - Hoe filter en firewall ik met OpenBSD?</h2>
Packet Filter (voortaan PF genoemd) is OpenBSD's systeem om IP
verkeer te filteren en om Network Address Translation te doen. PF kan
ook IP verkeer normaliseren en conditioneren, en bandbreedtecontrole
voorzien en pakketvoorrang regelen. Het kan gebruikt worden om krachtige
en flexibele firewalls te maken.
Het wordt beschreven in de <a href="../pf/nl/index.html"><b>PF
Gebruikersgids</b></a>.


<p> 
<a name= "DHCP"></a>
<h2>6.4 - Dynamic Host Configuration Protocol (DHCP)</h2> 

Dynamic Host Configuration Protocol is een manier om netwerk interfaces
"automatisch" te configureren.
OpenBSD kan een DHCP server zijn (die andere machines configureert), een
DHCP client (geconfigureerd door een andere machine), en in sommige gevallen
kan het beide zijn.

<p>
<a name="DHCPclient"></a>
<h3>6.4.1 - DHCP Client</h3>

<p>
Om de DHCP client
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">dhclient(8)</a>
te gebruiken die bij OpenBSD zit, bewerkt u <tt>/etc/hostname.xl0</tt> (dit
veronderstelt dat uw voornaamste Ethernet interface xl0 is.
De uwe zou ep0 of fxp0 of nog iets anders kunnen zijn.)
Al wat u in dit hostname bestand moet zetten is '<tt>dhcp</tt>':

<blockquote><pre>
# <b>echo dhcp &gt;/etc/hostname.xl0</b>
</pre></blockquote>

<p>
Dit zorgt ervoor dat OpenBSD automatisch de DHCP client start bij het
opstarten. OpenBSD zal zijn IP adres, standaard gateway en DNS servers
krijgen van de DHCP server.

<p>
Als u een DHCP client vanaf de commandolijn wil starten, zorg er dan voor
dat <tt>/etc/dhclient.conf</tt> bestaat en probeer vervolgens:

<blockquote><pre>
# <b>dhclient fxp0</b>
</pre></blockquote>

<p>
waarbij <tt>fxp0</tt> de interface is waarop u DHCP wenst te ontvangen.

<p>
Hoe u de DHCP client ook start, u kan het bestand
<tt>/etc/dhclient.conf</tt> aanpassen om uw DNS <b>niet</b> te updaten
volgens de dhcp server zijn idee van DNS door eerst de 'request' lijnen
erin te uncommenten (ze zijn voorbeelden van de standaardinstellingen, maar
u moet ze uncommenten om dhclient's standaardinstellingen te overschrijven.)

<blockquote><pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre></blockquote>

<p>
en daarna verwijdert u <tt>domain-name-servers</tt>.
Natuurlijk kan het zijn dat u ook <tt>host-name</tt> of andere instellingen
wil verwijderen.

<p>
Door de opties in uw
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5">dhclient.conf(5)</a>
bestand te wijzigen, zegt u de DHCP client hoe hij uw
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">resolv.conf(5)</a>
bestand moet opbouwen.
De DHCP client overschrijft gelijk welke informatie die reeds in
resolv.conf(5) staat door de informatie die hij ontvangt van de DHCP server.
Daarom zal u wijzigingen die u handmatig aanbracht in resolv.conf, verliezen.

<p>
Er zijn twee mechanismen beschikbaar om dit te voorkomen:

<ul>
<li>
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5#OPTION+MODIFIERS">OPTION
MODIFIERS</a></tt>
(<b>default</b>, <b>supersede</b>, <b>prepend</b> en <b>append</b>)
laten u toe gelijk welke van de opties in dhclient.conf(5) op te heffen.

<li>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5"><tt>resolv.conf.tail(5)</tt></a>
laat u toe om gelijk wat u wil toe te voegen aan het resolv.conf(5) bestand
aangemaakt door dhclient(8).
</ul>

<p>
Een voorbeeld zou zijn wanneer u DHCP gebruikt maar <tt>lookup file bind</tt>
wil toevoegen aan de resolv.conf(5) aangemaakt door dhclient(8).
Er is hiervoor geen optie in <tt>dhclient.conf</tt> zodat u
<tt>resolv.conf.tail</tt> moet gebruiken om dit te behouden.

<blockquote><pre>
# <b>echo "lookup file bind" &gt /etc/resolv.conf.tail</b>
</pre></blockquote>

Nu zou uw resolv.conf(5) aan het einde "lookup file bind" moeten bevatten.
<blockquote><pre>
nameserver 192.168.1.1
nameserver 192.168.1.2
lookup file bind
</pre></blockquote>

<p>
<a name="DHCPserver"></a>
<h3>6.4.2 - DHCP Server</h3>

<p>
Als u OpenBSD als een DHCP server
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)</a>,
wil gebruiken, bewerk dan <tt>/etc/rc.conf.local</tt> zodat het de lijn
<tt>dhcpd_flags="<i>interface</i>"</tt> bevat, waarbij u
<tt><i>interface</i></tt> vervangt door de lijst van interfaces
waarop dhcpd(8) moet luisteren.

<pre>
     # <b>echo 'dhcpd_flags="xl1 xl2 xl3"' &gt;&gt;/etc/rc.conf.local</b>
</pre>

<p>
Bewerk daarna <tt>/etc/dhcpd.conf</tt>.
De opties spreken vrijwel voor zich.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Dit zegt uw DHCP clients dat het domein om aan DNS requests toe te voegen
example.com is (dus, als de gebruiker 'telnet joe' intypt dan zal het
hem naar joe.example.com verwijzen). Het zal hen verwijzen naar DNS
servers 192.168.1.3 en 192.168.1.5. Voor hosts die zich op hetzelfde
netwerk bevinden als een Ethernet interface op de OpenBSD machine,
die in het 192.168.1.0/24 bereik staat, zal het hen een IP adres toekennen
tussen 192.168.1.32 en 192.168.1.127. Het zal hun standaard gateway
instellen als 192.168.1.1.

<p>
Als u dhcpd(8) vanaf de commandolijn wil starten, probeer dan na het
bijwerken van
<tt>/etc/dhcpd.conf</tt>:

<pre>
     # <b>touch /var/db/dhcpd.leases</b>
     # <b>dhcpd fxp0</b>
</pre>

<p>
De <tt>touch</tt> lijn is nodig om een leeg
<tt>dhcpd.leases</tt> bestand aan te maken voordat dhcpd(8) kan starten.
De OpenBSD <a href="faq10.html#rc">startup scripts</a> zullen dit bestand
indien nodig bij het opstarten aanmaken, maar als u dhcpd(8) handmatig
start, moet u het eerst aanmaken.
<tt>fxp0</tt> is een interface waarop u een DHCP server wil starten.

<p>
Als u DHCP diensten voor een Windows machine aanbiedt, wil u misschien dat
dhcpd(8) de client een 'WINS' server adres meegeeft. Om dit te laten gebeuren,
voegt u gewoon de volgende lijn toe aan uw
<tt>/etc/dhcpd.conf</tt>:

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(waarin <tt>192.168.92.55</tt> het IP van uw Windows of Samba
server is.) Zie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">dhcp-options(5)</a>
voor meer opties die uw DHCP clients misschien willen.


<p>
<a name="PPP"></a>
<h2>6.5 - PPP </h2>

<p>
Het Point to Point Protocol (PPP) is in het algemeen wat gebruikt wordt om
een verbinding op te zetten naar uw ISP via een inbelmodem. OpenBSD heeft 2
manieren om dit te doen:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
 - de kernel PPP daemon
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
 - de userland PPP daemon 
</ul>

<p>
ppp en pppd voeren allebei gelijkaardige functies uit, op verschillende
manieren.
pppd werkt met de kernel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp(4)</a>
driver, terwijl ppp in userland werkt met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun(4)</a>.
Dit document zal enkel de userland PPP daemon behandelen, omdat deze
gemakkelijker is om te debuggen en om mee te interageren. Om te beginnen
zal u enkele eenvoudige gegevens over uw ISP nodig hebben. Hier is een lijst
van nuttige informatie die u zal nodig hebben.

<ul>
<li>Het inbelnummer van uw ISP
<li>Uw nameserver 
<li>Uw gebruikersnaam en wachtwoord
<li>Uw gateway
</ul>

<p>
U kan zonder sommige hiervan, maar het zou helpen bij het opzetten van ppp.
De userland PPP daemon gebruikt het bestand
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a>
als configuratiebestand. Er staan heel wat nuttige bestanden in
<i>/etc/ppp</i> die verschillende instellingen kunnen hebben voor vele
verschillende situaties. U kan best eens grasduinen in deze directory.

<p>
<h3>Initiële Instelling - voor PPP(8)</h3>

<p>
Initiële Instelling voor de userland PPP daemon bestaat uit het aanpassen
van het <i>/etc/ppp/ppp.conf</i> bestand. Dit bestand bestaat standaard
niet, maar er is een bestand <i>/etc/ppp/ppp.conf.sample</i> dat u gewoon
kan bewerken om uw eigen <i>ppp.conf</i> bestand te maken. Hier zal ik
beginnen met de eenvoudigste en waarschijnlijk meest gebruikte setup. Hier
is een snel gemaakt <i>ppp.conf</i> bestand dat gewoon enkele
standaardwaarden instelt:

<blockquote><pre>
default:
  set log Phase Chat LCP IPCP CCP tun command     
  set device /dev/cua01                           
  set speed 115200     
  set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
</pre></blockquote>

<p>
De sectie onder het <tt>default:</tt> label wordt elke keer uitgevoerd.
Hier stellen we al onze essentiële informatie in. Met &quot;set
log&quot; stellen we onze logging niveau's in. Dit kan veranderd worden:
verwijs naar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
voor meer info over logging niveau's instellen. Ons device wordt ingesteld
met &quot;set device&quot;. Dit is het device waarop de modem staat. In
dit voorbeeld staat de modem op com poort 2. Daarom zou com poort 1
<i>/dev/cua00</i> zijn. Met &quot;set speed&quot; stellen we de snelheid van
onze inbelverbinding in en met &quot;set dial&quot; stellen we onze
inbelparameters in. Hiermee kunnen we onze timeout tijd instellen, enz.
Deze lijn zou echter min of meer moeten blijven zoals ze is.

<p>
Nu kunnen we overgaan tot het instellen van de informatie, specifiek voor
onze ISP. We doen dit door nog een label toe te voegen onder onze
<tt>default:</tt> sectie. Dit label mag u noemen zoals u wil - het
makkelijkst is om gewoon de naam van uw ISP te gebruiken.
Hier zal ik <tt>myisp:</tt> als ons label gebruiken dat refereert naar onze ISP.
Hier is een eenvoudige instelling die alles omvat wat we nodig hebben om
verbonden te geraken:

<blockquote><pre>
myisp:
  set phone 1234567   
  set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
  set timeout 120   
  set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
  add default HISADDR 
  enable dns
</pre></blockquote>

<p>
We hebben hier de essentiële info ingesteld voor die specifieke ISP.
De eerste optie &quot;set phone&quot; stelt het inbelnummer van uw ISP in.
De &quot;set login&quot; stelt onze login opties in. Hier hebben we een
timeout van 5 ingesteld; dit betekent dat we onze loginpoging staken na
5 seconden als er geen carrier gevonden wordt. Anders zal hij wachten tot
&quot;login:&quot; verstuurd wordt en vervolgens uw gebruikersnaam en
wachtwoord doorsturen.

<p>
In dit voorbeeld is onze
Username = ppp en Password = ppp. Deze waarden moeten veranderd worden.
De lijn &quot;set timeout&quot; stelt de idle timeout in op 120 seconden
voor de volledige duur van de verbinding. De &quot;set ifaddr&quot; lijn
is een beetje lastig. Hieronder volgt een meer uitvoerige uitleg.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
In de bovenstaande lijn hebben we het ingesteld volgens het formaat
&quot;<b>set ifaddr
[myaddr[/nn] [hisaddr[/nn] [netmask [triggeraddr]]]]</b>&quot;.
Dus het eerst vermelde IP is wat we als ons IP willen. Als u een statisch
IP hebt, stelt u dat hier in. In ons voorbeeld gebruiken we /0 wat zegt
dat er geen bits van dit IP adres moeten overeenkomen en dat het hele ding
mag vervangen worden. Het tweede vermelde IP is wat we verwachten als
hun IP. Als u dit kent mag u het specificeren. Opnieuw weten we in onze
lijn niet wat er toegekend zal worden, dus we laten het aan hen over om
het ons te zeggen. De derde optie is ons netmask, hier ingesteld op
255.255.255.0.  Als triggeraddr gespecificeerd wordt, wordt het gebruikt
in plaats van myaddr in de initiële IPCP negotiatie. Er zal echter
alleen een adres aanvaard worden dat in het myaddr bereik ligt. Dit is nuttig
wanneer genegotieerd wordt met bepaalde PPP implementaties die geen IP
nummer toekennen tenzij hun peer ``0.0.0.0'' aanvraagt.

<p>
De volgende optie is &quot;add default HISADDR&quot; die onze standaard
route naar hun IP instelt. Dit is 'sticky', wat betekent dat als hun IP
adres verandert, onze route automatisch wordt aangepast. Met &quot;enable
dns&quot; vragen we onze ISP om onze nameserver adressen te authenticeren.
Doe dit NIET als u een lokale DNS draait, aangezien ppp het gebruik ervan
gewoon zal omzeilen door enkele nameserver lijnen te plaatsen in
<i>/etc/resolv.conf</i>.

<p>
In plaats van traditionele login methodes gebruiken vele ISP's nu ofwel
CHAP ofwel PAP authenticatie. Als dit het geval is, zal onze configuratie
er lichtjes anders uitzien:

<blockquote><pre>
myisp:
  set phone 1234567   
  set authname ppp
  set authkey ppp
  set login
  set timeout 120   
  set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
  add default HISADDR 
  enable dns
</pre></blockquote>

<p>
In het bovenstaande voorbeeld specificeren we onze gebruikersnaam (ppp)
en paswoord (ppp) met respectievelijk authname en authkey. Het is niet nodig
om te specificeren of CHAP of PAP gebruikt wordt - dit wordt automatisch
genegotieerd. "set login" geeft louter aan om proberen in te loggen
met de voorheen opgegeven gebruikersnaam en paswoord.

<p>
<h3>PPP(8) gebruiken</h3>

<p>
Nu we ons <i>ppp.conf</i> bestand hebben ingesteld, kunnen we beginnen met
een verbinding naar onze ISP proberen te maken. Ik zal enkele veelgebruikte
argumenten van ppp toelichten:

<ul>
<li><tt>ppp -auto myisp</tt> - Dit voert ppp uit, configureert uw interfaces,
verbindt naar uw ISP en gaat dan in de achtergrond.
<li><tt>ppp -ddial myisp</tt> - Dit lijkt op -auto, maar als uw verbinding
verbroken wordt zal het proberen opnieuw te verbinden.
</ul>

<p>
Als het bovenstaande niet werkt, probeer dan <i>/usr/sbin/ppp</i> zonder
opties uit te voeren - dit zal ppp in interactieve modus draaien.
De opties kunnen één voor één gespecificeerd
worden om fouten of andere problemen op te sporen. Met de instellingen van
hierboven zal ppp loggen naar /var/log/ppp.log. Die log zal, net als de
man pagina, alle nuttige informatie bevatten.

<p>
<h3>ppp(8) extra's</h3>

<p>
In sommige situaties wil u misschien commando's uitvoeren terwijl uw
verbinding gemaakt of verbroken wordt. Er zijn twee bestanden die u kan
aanmaken precies voor deze situaties:
<i>/etc/ppp/ppp.linkup</i> en <i>/etc/ppp/ppp.linkdown</i>.
Voorbeeldconfiguraties kunt u hier bekijken:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
<h3>ppp(8) variaties</h3>

<p>
Vele ISP's bieden nu xDSL diensten aan, die sneller zijn dan traditionele
inbelmethodes. Dit omvat varianten zoals ADSL en SDSL.
Hoewel er geen fysisch bellen plaatsvindt, is de verbinding nog steeds gebaseerd
op het Point to Point Protocol. Voorbeelden zijn:

<ul>
<li>PPPoE
<li>PPPoA
<li>PPTP
</ul>

<p>
<h3>PPPoE/PPPoA</h3>

<p>
Het Point to Point Protocol over Ethernet (PPPoE) is een methode om PPP
pakketten in Ethernet frames te versturen.
Het Point to Point Protocol over ATM (PPPoA) wordt typisch gedraaid op ATM
netwerken, zoals die in het VK en België.

<p>
Typisch betekent dit dat u een verbinding met uw ISP kan maken door een
standaard Ethernet kaart en Ethernet-gebaseerde DSL modem te gebruiken
(in tegenstelling tot een enkel-USB modem).

<p>
Als u een modem hebt die PPPoE/PPPoA spreekt, is het mogelijk om de modem
in te stellen om het verbinden te doen. Als alternatief, indien de modem een
`bridge' modus heeft, is het mogelijk om deze in te schakelen en de modem
de pakketten te laten "passeren" naar een machine die PPPoE software draait.

<p>
De voornaamste software interface tot PPPoE/PPPoA op OpenBSD is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8">pppoe(8)</a>,
een userland implementatie (nogal gelijkaardig aan hoe we
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
hierboven beschreven hebben).
Een kernel PPPoE implementatie,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=4">pppoe(4)</a>,
werd in OpenBSD ingevoerd.

<p>
<h3>PPTP</h3>

<p>
Het Point to Point Tunneling Protocol (PPTP) is een proprietair Microsoft
protocol.
Een pptp client is beschikbaar, die interfacet met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
en kan verbinden met de PPTP-gebaseerde Virtual Private Networks (VPN)
gebruikt door sommige kabel en xDSL providers.
pptp zelf moet geïnstalleerd worden vanuit
<a href="faq15.html#PkgMgmt">packages</a>
of <a href="faq15.html#Ports">ports</a>.
Verdere instructies over het instellen en het gebruiken van pptp zijn
beschikbaar in de man pagina die samen met het pptp package geïnstalleerd
wordt.

<p>
<a name="Tuning"></a>
<h2>6.6 - Netwerkparameters tunen</h2>
<!-- XXXrelease -->

Eén van de doelstellingen van OpenBSD is dat het systeem <i>Gewoon Werkt</i>
voor de overgrote meerderheid van onze gebruikers.
Aan knoppen draaien die u niet begrijpt zal veel waarschijnlijker het systeem
breken dan dat het de prestaties ervan zal verbeteren.
Begin steeds met de standaardinstellingen en pas <i>alleen</i> dingen aan
waarmee u werkelijk een probleem ziet.

<p>
<i>ZEER WEINIG mensen zullen deze dingen moeten doen!</i>

<p>
<h3>6.6.1 - Hoe kan ik de kernel tweaken zodat er een groter aantal
retries en langere timeouts zijn voor TCP sessies?</h3>

<p>
U gebruikt dit normaal om rekening te houden met routerings- of
verbindingsproblemen.
Natuurlijk, om het meest effectief te zijn, moeten beide uiteinden van
de verbinding gelijkaardige waarden gebruiken.

<p>
Om dit te tweaken, gebruikt u <tt>sysctl</tt> en verhoogt u de waarden van:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Met sysctl -a kan u de huidige waarden van deze (en vele andere) parameters
bekijken. Om er een te veranderen, doet u iets als
<tt>sysctl net.inet.tcp.keepidle=28800</tt>.

<p>
<h3>6.6.2 - Hoe kan ik directed broadcasts aanzetten?</h3>

<p>
Normaal gezien wil u dit niet doen. Dit laat toe dat iemand verkeer naar
het broadcast adres(sen) van uw verbonden netwerk(en) stuurt indien u
OpenBSD gebruikt als een router.

<p>
Er zijn enkele gevallen, in gesloten netwerken, waarin dit nuttig zou
kunnen zijn, vooral wanneer er oudere implementaties van het NetBIOS
protocol in gebruik zijn. Dit is nog een andere sysctl.
<tt>sysctl net.inet.ip.directed-broadcast=1</tt> zet dit aan. Lees over
<a href="http://www.netscan.org">smurf aanvallen</a> als u wil weten
waarom dit standaard is uitgeschakeld.

<p>
<h3>6.6.3 - Ik wil niet dat de kernel dynamisch een bepaalde poort
toewijst</h3>

<p>
Ook hiervoor is er een sysctl. Vertaald uit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8#EXAMPLES">sysctl(8)</a>:

<blockquote><pre>
Om de lijst van gereserveerde TCP-poorten in te stellen die niet dynamisch
door de kernel toegewezen mogen worden:
 
      # <b>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</b>
 
Dit kan worden gebruikt om te voorkomen dat daemons een specifieke poort
innemen die een ander programma nodig heeft om te functioneren.
Lijstelementen kunnen door komma's en/of whitespace worden gescheiden.
 
Het is ook mogelijk om poorten toe te voegen of te verwijderen van de lijst:
 
      # <b>sysctl net.inet.tcp.baddynamic=+748</b>
      # <b>sysctl net.inet.tcp.baddynamic=-871</b>
</pre></blockquote>

<p>
<h3>6.6.4 - Hoe kan ik de prestaties verbeteren op echt snelle verbindingen
met veel verkeer?</h3>

Als u prestatiebeperkingen ziet bij gebruik van een hoge-snelheid WAN
verbinding die veel gegevens transfereert, kan u een prestatieverbetering
bekomen door de volgende sysctls te wijzigen:
<blockquote><pre>
net.inet.tcp.recvspace
net.inet.tcp.sendspace
</pre></blockquote>

Probeer een waarde als 65536 in plaats van de standaardwaarde 16384.
Merk op dat slechts weinigen hierdoor enig voordeel zullen zien.
Pas dit niet aan tenzij u werkelijk prestaties ziet die lager liggen dan
wat u verwacht.

<p>
<a name="NFS"></a>
<h2>6.7 - Eenvoudig NFS gebruik</h2>

<p>
NFS, of Network File System, wordt gebruikt om bestandssystemen over het
netwerk te delen. Hier zijn een aantal aangewezen man pagina's om te
lezen alvorens een NFS server op te zetten:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
</ul>

<p>
Deze sectie zal de stappen doorlopen voor een eenvoudige setup van NFS.
Dit voorbeeld behandelt de server in een LAN, met clients die NFS
gebruiken in deze LAN.
Beveiliging van NFS wordt hier niet behandeld. We gaan er van uit dat u
al pakket filtering of andere firewall bescherming hebt opgezet, om toegang
van buitenaf te beletten. Als u toegang van buitenaf tot uw NFS server
toelaat, en er staat gevoelige informatie op, dan raden we
ten zeerste aan dat u IPsec gebruikt. Anders kunnen mensen mogelijk uw
NFS verkeer te zien krijgen. Iemand zou zich ook kunnen voordoen als het
IP adres dat u toelaat tot uw NFS server. Er zijn verscheidene aanvallen
mogelijk. Wanneer het goed geconfigureerd is, beschermt IPsec tegen deze
soort aanvallen.

<h3>Een NFS server instellen</h3>

<p>
Deze diensten moeten ingeschakeld worden en draaien op de server:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)</a>
</ul>

<p>
Standaard zijn deze in OpenBSD allemaal uitgeschakeld.
Voeg de volgende lijnen toe aan
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"
>rc.conf.local(8)</a>
om ze in te schakelen:

<blockquote><pre>
portmap=YES
nfs_server=YES
</pre></blockquote>

<p>
De volgende stap is het configureren van een lijst van bestandssystemen die
beschikbaar zullen worden gesteld aan clients om te mounten.

<p>
In dit voorbeeld hebben we een server met IP adres 10.0.0.1.
Deze server zal NFS aanbieden alleen aan clients in zijn eigen subnet.
Dit wordt allemaal geconfigureerd in het /etc/exports bestand.
Dit bestand bevat een lijst van bestandssystemen die u toegankelijk wenst
te maken via NFS en definieert wie er toegang tot heeft.
Er zijn veel opties die u kan gebruiken in /etc/exports; het beste is dat
u de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5"
>exports(5)</a>
man pagina leest.
Voor onze voorbeeldserver hebben we een exports bestand ingesteld dat er
als volgt uitziet:

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network=10.0.0 -mask=255.255.255.0
</pre></blockquote>

<p>
Dit betekent dat het lokale bestandssysteem <tt>/work</tt> beschikbaar zal
gemaakt worden via NFS.
De <tt>-alldirs</tt> optie geeft aan dat clients op gelijk
welk punt onder het <tt>/work</tt> mount point zullen kunnen mounten, maar
ook op <tt>/work</tt> zelf.
Als er bijvoorbeeld een directory was met de naam <tt>/work/monday</tt>,
dan zouden clients <tt>/work</tt> kunnen mounten (en toegang hebben tot
alle bestanden/directories onder die directory) of ze zouden
<tt>/work/monday</tt> kunnen mounten en enkel toegang hebben tot de
bestanden/directories die daarin zitten.
De <tt>-ro</tt> optie geeft aan dat clients alleen read-only toegang zullen
krijgen.
De laatste twee argumenten geven aan dat enkel clients binnen het
10.0.0.0 netwerk met een netmask van 255.255.255.0 geauthoriseerd zullen
worden om dit bestandssysteem te mounten.
Dit is belangrijk voor sommige servers die langs verschillende netwerken
toegankelijk zijn.

<p>
Een andere belangrijke opmerking omtrent beveiliging: voeg niet gewoon een
bestandssysteem toe aan /etc/exports zonder een soort lijst van
toegelaten host(s).
Zonder een lijst van hosts die een bepaalde directory kunnen mounten,
kan iedereen die uw host kan bereiken, zomaar uw NFS exports mounten.

<p>
Nu kan u de serverdiensten opstarten.
U kan ofwel herstarten (na ze ingeschakeld te hebben zoals in de instructies
hierboven) of ze manueel opstarten.

<blockquote><pre>
# <b>/usr/sbin/portmap</b>
# <b>echo -n &gt;/var/db/mountdtab</b>
# <b>/sbin/mountd</b>
# <b>/sbin/nfsd -tun 4</b>
</pre></blockquote>

<p>
De argumenten die doorgegeven worden aan nfsd schakelen TCP (-t) en UDP (-u)
verbindingen in, en zorgen dat er 4 instanties van nfsd draaien.
U kan best een gepast aantal NFS server instanties instellen om het
maximale aantal gelijktijdige client verzoeken die u wil bedienen,
af te handelen.

<p>
U bent nu klaar om de geëxporteerde bestandssystemen te mounten vanaf de
client(s).

<p>
Onthou: als u wijzigingen aanbrengt in /etc/exports terwijl NFS reeds draait,
dan moet u mountd hierover inlichten!
HUP gewoon mountd en de wijzigingen vinden plaats.

<blockquote><pre>
# <b>kill -HUP `cat /var/run/mountd.pid`</b>
</pre></blockquote>

<h3>NFS bestandssystemen mounten</h3>

<p>
NFS bestandssystemen kunnen vanaf een client gemount worden zonder
diensten of daemons in te schakelen.
Ze kunnen net zoals gelijk welk ander bestandssysteem gemount worden.

<p>
NFS bestandssystemen moeten gemount worden via mount(8), of meer bepaald
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8">mount_nfs(8)</a>.
Om een bestandssysteem <tt>/work</tt> op host 10.0.0.1 te mounten naar een
lokaal bestandssysteem <tt>/mnt</tt>, doet u dit (merk op dat het niet nodig
is een IP adres te gebruiken; mount zal hostnamen vertalen):

<blockquote><pre>
# <b>mount -t nfs 10.0.0.1:/work /mnt</b>
</pre></blockquote>

<p>
Om ervoor te zorgen dat dat bestandssysteem bij het opstarten gemount wordt,
voegt u iets als dit toe in /etc/fstab:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<p>
Het is belangrijk dat u <tt>0 0</tt> gebruikt aan het einde van deze lijn
zodat uw computer het NFS bestandssysteem bij het opstarten niet probeert
te fsck'en.
De andere standaard beveiligingsopties, zoals <tt>noexec</tt>,
<tt>nodev</tt> en <tt>nosuid</tt> moeten hier ook gebruikt worden waar
ze toepasselijk zijn.
Bijvoorbeeld:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<p>
Op deze manier kunnen devices of setuid programma's op de NFS server
de beveilingsmaatregelen op de NFS client niet tenietdoen.
Als u geen programma's mount die u verwacht te draaien op de NFS client,
voegt u noexec toe aan deze lijst.

<p>
Wanneer u toegang verkrijgt tot een NFS mount als de root-gebruiker,
vertaalt de server automatisch root's toegang naar gebruikersnaam "nobody"
en groep "nobody".
Dit is belangrijk om te weten bij bestandspermissies.
Neem bijvoorbeeld een bestand met deze permissies:

<blockquote><pre>
-rw-------    1 root     wheel           0 Dec 31 03:00 _daily.B20143
</pre></blockquote>

<p>
Als dit bestand op een NFS share zat en de root-gebruiker probeerde
toegang te krijgen tot dit bestand vanaf de NFS client, dan zou dat
geweigerd worden.
Dit is zo omdat de server de gebruiker "nobody" gebruikt wanneer root
probeert toegang te krijgen tot dat bestand.
Aangezien de gebruiker nobody geen permissies heeft voor dat bestand,
wordt de toegang geweigerd.

<p>
De gebruiker en groep waarnaar root vertaald wordt, zijn configureerbaar
via het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5"
>exports(5)</a>
bestand op de NFS server.

<h3>Statistieken over NFS nakijken</h3>

<p>
Eén ding om na te kijken om te verzekeren dat NFS juist werkt is dat alle
diensten juist geregistreerd zijn bij RPC.
Om dit te doen, gebruikt u rpcinfo(8).

<blockquote><pre>
$ <b>rpcinfo -p 10.0.0.1</b>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
Bij normaal gebruik zijn er nog enkele andere hulpmiddelen die u
toelaten om te zien wat er gebeurt met NFS. Eén ervan is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8">showmount(8)</a>, 
dat u kan laten zien wat er momenteel gemount is en door wie. Er is ook
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsstat&amp;sektion=1"
>nfsstat(1)</a>
dat veel uitgebreidere statistieken toont.
Om showmount(8) te gebruiken, probeer <tt>/usr/bin/showmount -a host</tt>.
Bijvoorbeeld:

<blockquote><pre>
$ <b>/usr/bin/showmount -a 10.0.0.1</b>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
Deze uitvoer toont dat de client 10.0.0.37 de <tt>/work</tt> export
gemount heeft die aangeboden wordt vanaf de server op 10.0.0.1.

<a name="Bridge"></a>
<h2>6.9 - Een netwerk bridge opzetten in OpenBSD</h2>

<p>
Een <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
is een verbinding tussen twee of meer afzonderlijke netwerken. In
tegenstelling tot een router, worden pakketten door de bridge "onzichtbaar"
overgedragen -- logisch gezien lijkt het alsof de twee netwerksegmenten
één segment zijn voor knooppunten aan gelijk welke zijde van de
bridge. De bridge zal enkel pakketten doorsturen die van het ene naar het
andere segment moeten, dus ze bieden onder andere een gemakkelijke manier
om in een complex netwerk het verkeer te verlagen en laten toch toe om elk
knooppunt indien nodig toegang te verschaffen tot gelijk welk ander
knooppunt.

<p>
Merk op dat door deze "onzichtbare" aard een interface in een bridge
al dan niet een eigen IP adres kan hebben. Als het er een heeft, dan
heeft de interface effectief twee werkingsmodi, één als deel
van een bridge, de andere als een normale, alleenstaande NIC.
Als geen van de interfaces een IP adres heeft, stuurt de bridge
netwerkdata door, maar zal van buitenaf niet onderhouden kunnen worden
(wat een nuttige eigenschap kan zijn).

<p>
<h3>Een voorbeeld van een bridge toepassing</h3>

<p>
Eén van mijn computer rekken bevat een aantal oudere systemen, waarvan
geen enkel een ingebouwde 10BASE-TX NIC heeft. Hoewel ze allemaal een
AUI of AAUI connector hebben, is mijn voorraad transceivers beperkt tot
coax. Een van de machines in dit rek is een OpenBSD-gebaseerde terminal
server die altijd aan staat en met het hogesnelheidsnetwerk verbonden is.
Door een tweede NIC met een coax poort toe te voegen zal ik deze machine
als een bridge naar het coax netwerk kunnen gebruiken.

<p>
Dit systeem heeft nu twee NICs, een Intel EtherExpress/100
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
en een 3c590-Combo kaart
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
voor de coax poort.  <tt>fxp0</tt> is de verbinding met de rest van
mijn netwerk en zal dus een IP adres hebben, <tt>ep0</tt> zal
enkel voor bridging dienen en zal geen IP adres hebben.
Machines verbonden met het coax segment zullen communiceren alsof ze op
de rest van mijn netwerk zaten. Hoe laten we dit nu gebeuren?

<p>
Het bestand <tt>hostname.fxp0</tt> bevat de configuratie info voor
de <tt>fxp0</tt> kaart. Deze machine is ingesteld met DHCP, dus het
bestand ziet er als volgt uit:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE
</pre></blockquote>

<p>
Geen verrassingen hier.

<p>
De <tt>ep0</tt> kaart is een beetje verschillend, zoals u al kon raden:

<blockquote><pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre></blockquote>

<p>
Hier dragen we het systeem op om deze interface te activeren met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
en hem op 10BASE-2 (coax) in te stellen. IP adres of gelijkaardige informatie
hoeft voor deze interface niet gespecificeerd te worden. De opties die de
<tt>ep</tt> kaart aanvaardt, staan uitgebreid in de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">man pagina</a> ervan.

<p>
Nu moeten we de bridge instellen. Bridges worden geïnitialiseerd door
het bestaan van een bestand met een naam als
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"><tt>bridgename.bridge0</tt></a>. 
Hier is een voorbeeld voor mijn situatie hier:

<blockquote><pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre></blockquote>

<p>
Dit zegt: stel een bridge in die bestaat uit de twee NICs, fxp0 en ep0,
en activeer ze. Doet het ertoe in welke volgorde de kaarten staan? Neen,
onthou dat een bridge heel symmetrisch is -- pakketten stromen in en uit
in beide richtingen.

<p>
Dat is het! Herstart, en u hebt nu een werkende bridge.

<p>
<h3>Filteren op een bridge</h3>

Hoewel een eenvoudige bridge als deze zeker nuttig kan zijn, is het
waarschijnlijk dat u iets wil DOEN met de pakketten wanneer ze doorheen
uw bridge gaan. Zoals u kon verwachten, kan
<a href="#PF">Packet Filter</a> gebruikt worden om beperkingen op te leggen
aan het verkeer dat doorheen uw bridge gaat.

<p>
Hou in het achterhoofd dat, door de aard van een bridge, dezelfde gegevens
door beide interfaces stromen, zodat u slechts op één interface
hoeft te filteren. Uw standaard "Pass all" opdrachten zouden er ongeveer zo
kunnen uitzien:

<blockquote><pre>
pass in  on ep0  all
pass out on ep0  all
pass in  on fxp0 all
pass out on fxp0 all
</pre></blockquote>

<p>
Nu, stel dat ik graag het verkeer dat deze oude machines zien, wil
filteren, ik wil dat alleen Web en SSH verkeer ze bereikt. In dit geval
zullen we alle verkeer in en uit de <tt>ep0</tt> interface laten, maar filteren
op de <tt>fxp0</tt> interface, gebruik makend van <tt>keep state</tt> om de
antwoordgegevens te behandelen:

<blockquote><pre>
# Pass all traffic through ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre></blockquote>

<p>
Merk op dat deze regelset belet dat er ook maar iets, behalve ingaand
HTTP en SSH verkeer, ofwel de bridge ofwel gelijk welk ander knooppunt
"erachter" bereikt. Andere resultaten zouden kunnen bekomen worden door
op de andere interface te filteren.

<p>
Om de bridge die u gemaakt hebt in de gaten te houden en te beheren,
gebruikt u het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
commando, dat ook kan gebruikt worden om een bridge te maken na het
opstarten.

<p>
<h3>Tips voor bridging</h3>

<ul>
<li>Het is TEN ZEERSTE aangeraden dat u slechts op één enkele
interface filtert.
Hoewel het mogelijk is om op allebei te filteren, moet u dit echt heel
goed begrijpen om het juist te doen.

<li>Door de <i>blocknonip</i> optie van 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
of in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5">bridgename.bridge0</a>
te gebruiken,
kan u beletten dat niet-IP verkeer (zoals IPX of NETBEUI) langs uw filters
glipt. Dit kan belangrijk zijn in sommige situaties, maar u moet weten dat
bridges werken voor alle soorten verkeer, niet enkel IP.

<li>Bridging vereist dat de NICs in een "Promiscuous mode" staan -- ze
luisteren naar ALLE netwerkverkeer, niet alleen datgene gericht naar de
interface. Dit zal de processor en bus onder een grotere belasting plaatsen
dan men zou verwachten. Sommige NICs werken niet naar behoren in deze
modus, de TI ThunderLAN chip
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4">tl(4)</a>)
is een voorbeeld van een chip die niet wil werken als onderdeel van een bridge. 
</ul>

<a name="PXE"></a>
<h2>6.10 - Hoe boot ik met PXE? (i386, amd64)</h2>
De Preboot Execution Environment, of PXE, is een manier om een computer te
starten via het netwerk, veeleer dan via een harde schijf, een diskette of een
CD-ROM. De technologie werd aanvankelijk ontwikkeld door Intel, maar wordt nu
door de meeste grote netwerkkaart- en computerfabrikanten ondersteund.
Merk op dat er verschillende netwerk bootprotocols zijn, PXE is relatief
recent.
Traditioneel gebeurt PXE booting met ROMs op de NIC of het moederbord van
het systeem, maar er zijn via verschillende bronnen bootdiskettes
beschikbaar, die ook PXE booting toelaten.
Veel ROMs op oudere NICs ondersteunen netwerk booting maar ondersteunen
PXE NIET;
OpenBSD/i386 of amd64 kan momenteel door deze kaarten niet via het netwerk
gestart worden.


<p>
<h3>Hoe werkt PXE booting?</h3>
Eerst en vooral is het verstandig om te begrijpen hoe
<a href="faq14.html#Boot386">OpenBSD start</a> op i386 en amd64 platformen.
Bij aanvang van het bootproces, broadcast de PXE-capabele NIC een DHCP request
over het netwerk.
De DHCP server zal de adapter een IP adres toekennen, en geeft hem een
bestandsnaam die via een
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a> server moet teruggevonden worden en uitgevoerd.
Dit bestand leidt dan de rest van het boot proces.
Voor OpenBSD is dit bestand
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot</a>, dat de plaats inneemt van het standaard
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">
boot(8)</a> bestand.
pxeboot(8) kan dan een kernel inladen en uitvoeren (zoals
<tt>bsd</tt> of <a href="faq4.html#bsd.rd"><tt>bsd.rd</tt></a>) vanaf
dezelfde tftp(1) server.

<h3>Hoe doe ik het?</h3>
De eerste vanzelfsprekende stap is dat u een PXE-boot capabele computer
of netwerkadapter moet hebben.
Sommige documentatie zal aangeven dat alle moderne NICs en computers
PXE capabel zijn, maar dit is duidelijk niet waar -- veel goedkope
systemen bevatten geen PXE ROMs of gebruiken een ouder netwerk boot protocol.
U hebt ook een netjes geconfigureerde <a href="#DHCP">DHCP</a> en TFTP
server nodig.

<p>
In de verondestelling dat een OpenBSD machine de bron van de bootbestanden
is (dit is NIET vereist), moet uw DHCP server
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf&amp;sektion=5">dhcpd.conf</a>
bestand de volgende lijn bevatten:
<pre>
    filename "pxeboot";
</pre>
om de DHCP server dit bestand te laten aanbieden aan het bootende werkstation.
Bijvoorbeeld:

<pre>
    shared-network LOCAL-NET {
            option  domain-name "example.com";
            option  domain-name-servers 192.168.1.3, 192.168.1.5;

            subnet 192.168.1.0 netmask 255.255.255.0 {
                    option routers 192.168.1.1;
                    <b>filename "pxeboot";</b>
                    range 192.168.1.32 192.168.1.127;
                    default-lease-time 86400;
                    max-lease-time 90000;
            }
    }
</pre>

<p>
U zal ook de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftpd&amp;sektion=8">tftpd(8)</a>
daemon moeten activeren. Dit gebeurt typisch via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8"
>inetd(8)</a>.
De standaard OpenBSD installatie heeft een voorbeeldlijn in
<tt>inetd.conf</tt> die het mooi voor u doet:
<pre>
    #tftp  dgram   udp  wait  root  /usr/libexec/tftpd   tftpd -s /tftpboot
</pre>

waarin het '#' teken eenvoudigweg verwijderd moet worden. Stuur inetd(8)
een -HUP signaal om het <tt>/etc/inetd.conf</tt> te laten herladen.
tftpd(8) biedt bestanden aan vanuit een welbepaalde directory, in het geval
van deze lijn, is die directory <tt>/tftpboot</tt>, wat we in dit voorbeeld
zullen gebruiken.
Vanzelfsprekend moet deze directory aangemaakt en bevolkt worden.
Typisch moet u daar slechts enkele bestanden hebben voor PXE booting:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot</a>, de PXE boot loader (die dezelfde functie vervult als
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>boot</a> op een schijf-gebaseerd systeem).
<li><a href="faq4.html#bsd.rd">bsd.rd</a>, de installatiekernel of <tt>bsd</tt>,
een aangepaste kernel.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"
>/etc/boot.conf</a>, een boot configuratiebestand.
</ul>

Merk op dat <tt>/etc/boot.conf</tt> enkel nodig is als de kernel die u wenst
te starten niet <tt>bsd</tt> heet, of als de andere pxeboot standaardwaarden
niet zijn wat u nodig hebt (u wenst bijvoorbeeld een seriële console
te gebruiken).
U kan uw tftpd(8) server testen met een
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a> client, en nagaan of u de nodige bestanden kan afhalen.

<p>
Wanneer uw DHCP en TFTP servers draaien, bent u klaar om het te proberen.
U zal de PXE boot op uw systeem of netwerkkaart moeten activeren;
raadpleeg hiervoor uw systeemdocumentatie.
Zodra u dit ingeschakeld hebt, zou u iets moeten zien dat lijkt op het
volgende:

<pre>
    Intel UNDI, PXE-2.0 (build 067)
    Copyright (C) 1997,1998 Intel Corporation

    For Realtek RTL 8139(X) PCI Fast Ethernet Controller v1.00 (990420)

    DHCP MAC ADDR: 00 E0 C5 C8 CF E1
    CLIENT IP: 192.168.1.76  MASK: 255.255.255.0  DHCP IP: 192.168.1.252
    GATEWAY IP: 192.168.1.1
    probing: pc0 com0 com1 apm pxe![2.1] mem[540k 28m a20=on]
    disk: hd0*
    net: mac 00:e0:c5:c8:cf:e1, ip 192.168.1.76, server 192.168.1.252
    >> OpenBSD/i386 PXEBOOT 2.03
    boot>
</pre>

Op dit punt hebt u de standaard OpenBSD boot prompt.
Als u hier gewoon "<tt>bsd.rd</tt>" typt, zal u het bestand
<tt>bsd.rd</tt> van de TFTP server afhalen.

<pre>
    >> OpenBSD/i386 PXEBOOT 2.03
    boot> bsd.rd
    booting tftp:bsd.rd: 4375152+733120 [58+122112+105468]=0x516d04
    entry point at 0x100120

    Copyright (c) 1982, 1986, 1989, 1991, 1993
            The Regents of the University of California.  All rights reserved.

    Copyright (c) 1995-2009 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

    OpenBSD 4.6 (RAMDISK_CD) #53: Thu Jul  9 21:41:35 MST 2009
      ...
</pre>

De <a href="faq4.html#bsd.rd">bsd.rd installatiekernel</a> zal nu opstarten.

<p>

<h3>Kan ik nog andere soorten kernels starten met PXE, behalve
<tt>bsd.rd</tt>?</h3>

Ja, hoewel met de tools momenteel in OpenBSD, is PXE booting in eerste
instantie bedoeld is om het besturingssysteem te installeren.


<a name="CARP"></a>
<h2>6.11 - Het Common Address Redundancy Protocol (CARP)</h2>
<h3>6.11.1 - Wat is CARP en hoe werkt het?</h3>
<!-- This article written by Sunny Raspet, slr@mordac.info, and
released under the BSD license -->

<p>
CARP is een hulpmiddel om systeemredundantie te helpen bereiken, door meerdere
computers onderling een enkele virtuele netwerkinterface te laten aanmaken,
zodat als gelijk welke machine faalt, een andere in de plaats kan antwoorden,
en/of een graad van belastingsverdeling tussen systemen toe te laten.
CARP is een verbetering ten opzichte van de Virtual Router Redundancy Protocol
(VRRP) standaard.
Het werd ontwikkeld nadat VRRP niet vrij genoeg geacht werd wegens een
mogelijk overlappend Cisco patent.
Voor meer informatie over de oorsprong van CARP en de juridische problemen
omtrent VRRP, bezoekt u alstublieft <a href="../../lyrics.html#35">deze pagina</a>.

<p>
Om juridische conflicten te vermijden, ontwierp Ryan McBride (met de hulp van
Michael Shalayeff, Marco Pfatschbacher en Markus Friedl) CARP zo dat het
fundamenteel verschillend zou zijn.
De opname van cryptografie is de meest prominente verandering, maar toch
slechts één van de vele.

<p>
Hoe het werkt: CARP is een multicast protocol.
Het groepeert verscheidene fysische computers samen onder één
of meer virtuele adressen.
Van deze is één systeem de master en antwoordt op alle pakketten
bestemd voor de groep, de andere systemen fungeren als "hot spares".
Wat het IP en MAC adres van de lokale fysische interface ook zijn, pakketten
verstuurd naar het CARP adres worden teruggezonden met de CARP informatie.

<p>
Op configureerbare intervals kondigt de master zijn werking op IP protocol
nummer 112 aan.
Als de master offline gaat, beginnen de andere systemen in de CARP groep
met aankondigen.
De host die het vaakst kan aankondigen, wordt de nieuwe master.
Wanneer het hoofdsysteem opnieuw on-line komt, wordt het standaard een
backup host, als het echter meer wenselijk is om één host
altijd master te laten zijn wanneer mogelijk (bv. één host is
een snelle Sun Fire V120 en de andere zijn in vergelijking trage SPARCstation
IPCs), dan kan u ze zo instellen.

<p>
Hoewel hoogredundante en fout-tolerante hardware de nood aan CARP
minimaliseert, neemt het deze niet weg.
Er bestaat geen hardware fouttolerantie die kan helpen als iemand een
stroomkabel uitsnokt, of als uw systeembeheerder in het verkeerde venster
<tt>reboot</tt> typt.
CARP maakt het ook gemakkelijker om de patch en reboot cyclus transparant te
maken voor gebruikers, en gemakkelijker om een software of hardware upgrade
te testen--als het niet werkt, kan u terugvallen op uw "spare" totdat het
opgelost is.

<p>Er zijn echter situaties waarin CARP niet zal helpen.
Het ontwerp van CARP vereist dat de leden van een groep op hetzelfde fysische
subnet zitten met een statisch IP adres, hoewel met de introductie van het
carpdev sleutelwoord IP adressen op de fysische interfaces niet langer nodig
zijn.
Gelijkaardig zullen diensten die een voortdurende verbinding met de server
vereisen (zoals SSH of IRC) niet transparant naar het andere systeem
overgezet worden--hoewel in dit geval CARP kan helpen met de down-tijd te
minimaliseren.
CARP op zichzelf synchroniseert geen gegevens tussen toepassingen, dit moet
gedaan worden door "alternatieve kanalen" zoals
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfsync&amp;sektion=4">pfsync(4)</a>
(voor redundante filtering), het handmatig dupliceren van gegevens tussen
machines met <a href="http://rsync.samba.org/">rsync</a>, of wat er ook
geschikt is voor uw toepassing.

 

<h3>6.11.2 - Configuratie</h3>

<p>
De bediening van CARP staat op twee plaatsen:
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
en
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Laten we eerst naar de sysctls kijken.

<p>De eerste sysctl, <tt>net.inet.carp.allow</tt>, definieert of de host
überhaupt CARP pakketten behandelt.
Dit is duidelijk noodzakelijk om CARP te gebruiken.
Deze sysctl is standaard ingeschakeld.

<p>De tweede, <tt>net.inet.carp.log</tt>, logt CARP status veranderingen,
foute packets en andere fouten.  Staat standaard op het loggen van status
veranderingen.

<p>De derde, <tt>net.inet.carp.preempt</tt> schakelt natuurlijke selectie
tussen CARP hosts in.
De meest geschikte voor de job (dat betekent, het meest frequent kunnen
aankondigen) zal master worden.
Standaard uitgeschakeld, wat betekent dat een systeem dat geen master is
niet zal proberen om (opnieuw) master status te winnen.

<p>
Al deze sysctl variabelen zijn gedocumenteerd in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>.

<p>Voor de rest van de configuratie van CARP, verlaten we ons op
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
De CARP-specifieke commando's <tt>advbase</tt> en
<tt>advskew</tt> hebben te maken met het interval tussen CARP aankondigingen.
De formule (in seconden) is <tt>advskew</tt> gedeeld door 256, vervolgens
opgeteld bij <tt>advbase</tt>.
<tt>advbase</tt> kan gebruikt worden om het netwerkverkeer te verlagen of
om langere latentie toe te laten alvorens een backup host overneemt;
<tt>advskew</tt> laat u bepalen welke host master zal zijn zonder veel
"failover" vertraging (als dat vereist zou zijn).

<p>Vervolgens stelt <tt>pass</tt> een wachtwoord in, en stelt <tt>vhid</tt> het
virtuele host identifier nummer van de CARP groep in.
U moet een uniek nummer toekennen voor elke CARP groep, zelfs als (voor
load balancing doeleinden) ze hetzelfde IP adres delen.
CARP is beperkt tot 255 groepen.

<p>
Tenslotte specificeert <tt>carpdev</tt> welke fysische interface bij deze
bepaalde CARP groep hoort.
Standaard zal gelijk welke interface gebruikt worden die een IP adres in
hetzelfde subnet aan de CARP interface heeft toegekend.


<p>Laten we al deze instellingen samenbrengen in een basisconfiguratie.
Stel dat u twee identiek geconfigureerde Web servers gebruikt,
<i>rachael</i> (192.168.0.5) en <i>pris</i> (192.168.0.6), om een ouder
systeem te vervangen dat op 192.168.0.7 stond.  De commando's:

<blockquote><pre>
rachael# <b>ifconfig carp0 create</b>
rachael# <b>ifconfig carp0 vhid 1 pass tyrell carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

<p>maken de carp0 interface en geven ze een vhid van 1, een wachtwoord
<i>tyrell</i>, en het IP adres 192.168.0.7 met masker 255.255.255.0.
Ken fxp0 toe als lidinterface.
Om dit blijvend te maken na het herstarten, kan u een
<tt>/etc/hostname.carp0</tt> bestand aanmaken dat er zo uitziet:

<blockquote><pre>
inet 192.168.0.7 255.255.255.0 192.168.0.255 vhid 1 pass tyrell carpdev fxp0
</pre></blockquote>

Merk op dat tevens het broadcast adres is gespecificeerd naast het vhid en
het wachtwoord.
Het nalaten hiervan is een veel voorkomende bron van fouten, aangezien het
nodig is als een plaatshouder.

<p>
Doe hetzelfde op <i>pris</i>. Welk systeem ook de CARP interface het eerst
on-line brengt, zal master zijn (in de veronderstelling dat preempt
uitgeschakeld is; het tegengestelde is waar wanneer preempt ingeschakeld is).

<p>
Maar stel dat u niet vanaf nul begint met opstellen.
<i>Rachael</i> was reeds op haar plaats op het adres 192.168.0.7.
Hoe zou u daar omheen werken?
Gelukkig kan CARP met deze situatie omgaan. U kent gewoon het adres toe aan
de CARP interface en in een CARP groep, zodat het niet nodig is de
commando's hierboven te veranderen.
Het is gewoonlijk echter netter om voor elk systeem een IP te hebben-- dit
maakt individuele monitoring en toegang veel eenvoudiger.

<p>Laten we nog een laag complexiteit toevoegen; we willen dat <i>rachael</i>
wanneer mogelijk master blijft.
Er zijn verscheidene redenen waarom we dit zouden kunnen willen:
hardwareverschillen, eenvoudig vooroordeel, "als dit systeem geen master is,
is er een probleem," of de standaard master kennen zonder met scripts de
uitvoer van ifconfig te verwerken en via e-mail te versturen.

<p>Op <i>rachael</i> zullen we de sysctl gebruiken die we hoger aangemaakt
hebben, en vervolgens <tt>/etc/sysctl.conf</tt> bewerken om het blijvend te
maken.

<blockquote><pre>
rachael# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>We zullen ook op <i>pris</i> de configuratie doen:

<blockquote><pre>
pris# <b>ifconfig carp0 advskew 100</b>
</pre></blockquote>

<p>Dit vertraagt lichtjes de aankondigingen van <i>pris</i>, wat betekent dat
<i>rachael</i> master zal zijn indien levend.

<p>
Merk op dat indien u PF gebruikt op een ge-CARPte computer, u "proto carp"
moet meegeven aan alle betrokken interfaces, met een lijn gelijkaardig aan:
<blockquote><pre>
pass on fxp0 proto carp keep state
</pre></blockquote>

<h3>6.11.3 - Load balancing</h3>

<p>Blik enkele maanden vooruit. Ons bedrijf uit het voorgaande voorbeeld is
gegroeid tot op het punt waar een enkele interne Web server het maar net
redt onder de belasting. Wat te doen? CARP ter hulp. Het is tijd om load
balancing uit te proberen. Creëer een nieuwe CARP interface en groep
op <i>rachael</i>:

<blockquote><pre>
rachael# <b>ifconfig carp1 create</b>
rachael# <b>ifconfig carp1 vhid 2 advskew 100 pass bryant carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

<p>Ook op <i>pris</i> zullen we de nieuwe groep en interface aanmaken, en
vervolgens de "preempt" sysctl instellen:

<blockquote><pre>
pris# <b>ifconfig carp1 create</b>
pris# <b>ifconfig carp1 vhid 2 pass bryant carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
pris# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>Nu hebben we twee CARP groepen met hetzelfde IP adres. Elke groep wordt
naar een verschillende host gedraaid, wat betekent dat <i>rachael</i> master
zal blijven van de oorspronkelijke groep, maar <i>pris</i> zal de nieuwe
overnemen.

<p>Hoewel dit voorbeelden zijn voor een twee-machine cluster, zijn dezelfde
principes van toepassing op meer systemen.
Bemerk echter alstublieft, dat er niet verwacht wordt dat u perfect 50/50
verdeling zal bekomen tussen de twee machines--CARP gebruikt een hash van
het bron-IP adres om te bepalen welk systeem de aanvraag afhandelt, veeleer
dan volgens belasting.

<h3>6.11.4 - Meer informatie over CARP</h3>
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>
<li><a href="http://www.countersiege.com/doc/pfsync-carp/">Firewall
Failover met pfsync en CARP</a> door Ryan McBride
</ul>

<a name="OpenNTPD"></a>
<h2>6.12 - OpenNTPD gebruiken</h2>
Nauwkeurige tijd is belangrijk voor veel computertoepassingen.
Veel mensen hebben echter gemerkt dat hun horloge van $5 beter de tijd
kan bijhouden dan hun $2000 computer.
Bovenop te weten hoe laat het is, is het ook vaak belangrijk om
computers te synchroniseren zodat ze het allemaal eens zijn over hoe
laat het is.
Een tijd lang heeft <a href="http://www.ntp.org">ntp.org</a>
een Network Time Protocol
(<a href="http://www.ietf.org/rfc/rfc1305.txt">RFC1305</a>,
<a href="http://www.ietf.org/rfc/rfc2030.txt">RFC2030</a>)
toepassing geproduceerd, beschikbaar via <a href="faq15.html#Ports">ports</a>,
die kan gebruikt worden om klokken van computers via het Internet te
synchroniseren. Het is echter een niet-triviaal programma om in te stellen,
het heeft een moeilijke broncode om te controleren, en heeft grote
geheugenvereisten.
In het kort vervult het een belangrijke rol voor sommige mensen, maar het
is verre van een oplossing voor iedereen.

<p>
<a href="http://www.openntpd.org">OpenNTPD</a> is een poging om sommige van
deze problemen op te lossen, door een triviaal te beheren, veilige en
eenvoudige NTP-compatibele manier te voorzien om op uw computer over
nauwkeurige tijd te beschikken.
OpenBSD's 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd&amp;sektion=8">ntpd(8)</a>
wordt beheerd met een eenvoudig te begrijpen configuratiebestand,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5"><tt>/etc/ntpd.conf</tt></a>.

<p>
Gewoon ntpd(8) activeren via <a href="faq10.html#rc">rc.conf.local</a>
zal ertoe leiden dat de klok van uw computer traag naar de
<a href="http://www.pool.ntp.org/">pool.ntp.org</a> servers,
een verzameling publiek beschikbare tijdservers.
toe evolueert, en vervolgens zichzelf ermee gesynchroniseerd houdt.
Zodra uw klok nauwkeurig gezet is, zal ntpd ze op een hoge
nauwkeurigheidsgraad houden, als uw klok echter meer dan enkele minuten
verkeerd staat, wordt het <i>ten zeerste</i> aanbevolen dat u ze eerst ongeveer
juist zet, aangezien het dagen of weken kan duren om een heel verkeerde
klok te synchroniseren.
U kan dit doen met de "<tt>-s</tt>" optie van ntpd(8) of gelijk welke
andere manier om uw systeemklok nauwkeurig in te stellen.

<a name="OpenNTPDaccurate"></a>
<h3>6.12.1 - "Maar OpenNTPD is niet zo nauwkeurig als de ntp.org daemon!"</h3>
Dat kan zijn.
Dat is niet de
<a href="http://www.openntpd.org/goals.html">ontwerpdoelstelling</a> van
OpenNTPD, het is bedoeld om vrij, eenvoudig, betrouwbaar en veilig te zijn.
Als u echt microseconde precisie meer nodig hebt dan de voordelen van
OpenNTPD, staat het u vrij om ntp.org's ntpd te gebruiken, want deze blijft
beschikbaar via ports en packages.
Er is geen plan of verlangen om OpenNTPD te overladen met elke denkbare
mogelijkheid.

<a name="OpenNTPDharmful"></a>
<h3>6.12.2 - "Iemand heeft beweerd dat OpenNTPD 'schadelijk' is!"</h3>
Sommige mensen hebben de doelstellingen van OpenNTPD niet begrepen -- een
eenvoudige, veilige en gemakkelijk te onderhouden manier om de klok van uw
computer nauwkeurig te houden.
Als het nauwkeurig bijhouden van de tijd belangrijk is: een aantal mensen
hebben al betere resultaten met OpenNTPD dan met ntp.org's ntpd gemeld.
Als veiligheid belangrijk is: de broncode van OpenNTPD is veel leesbaarder
(en dus controleerbaar) en werd geschreven met "native" OpenBSD 
functie-aanroepen zoals
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy&amp;sektion=3">strlcpy</a>,
veeleer dan meer portable functies als
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strcpy&amp;sektion=3">strcpy</a>,
en werd vanaf het begin geschreven om veilig te zijn, niet "achteraf veilig
gemaakt".
Als het waardevol is om meer mensen tijdssynchronisatie te laten gebruiken,
maakt OpenNTPD het veel gemakkelijker voor grotere aantallen mensen om het te
gebruiken. Als dit "schadelijk" is, dan zijn we er allemaal voor.

<p>
Er zijn toepassingen waarbij de ntp.org ntpd meer gepast is; er wordt echter
vastgesteld dat voor een grote meerderheid van de gebruikers OpenNTPD meer dan
voldoende is.

<p>
Een meer volledig antwoord hierop door een van de maintainers van OpenNTPD
kan
<a href="http://www.advogato.org/person/dtucker/diary.html?start=52">hier</a>
gelezen worden.

<a name="OpenNTPDNoServe"></a>
<h3>6.12.3 - Waarom kunnen mijn andere machines niet synchroniseren met OpenNTPD?</h3>

ntpd(8) luistert standaard op geen enkel adres.
Om het als server te gebruiken, moet u de
"<tt>#listen&nbsp;on&nbsp;*</tt>" lijn in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5">/etc/ntpd.conf</a>
uit commentaar zetten en de ntpd(8) daemon herstarten.
Als u natuurlijk liever op een welbepaald IP adres wil luisteren dan op
alle beschikbare adressen en interfaces, vervangt u de "*" door het
gewenste adres.

<p>
Het kan gebeuren dat wanneer uw ntpd(8) luistert, andere machines er nog
steeds niet mee kunnen synchroniseren!
Een pas opgestarte ntpd(8) daemon (als u hem bijvoorbeeld net hebt herstart
na het wijzigen van ntpd.conf) weigert tijdsinformatie aan te bieden aan
andere clients totdat hij eerst zijn eigen klok tot een redelijk niveau van
stabiliteit heeft aangepast.
Wanneer ntpd(8) zijn eigen tijdsinformatie stabiel beschouwt, kondigt hij
dit aan met een "clock now synced" bericht in <tt>/var/log/daemon</tt>.
Zelfs als de systeemklok in het begin vrij nauwkeurig is, kan het tot
10 minuten duren om gesynchroniseerd te geraken, en uren of dagen als de
klok bij het begin niet nauwkeurig ingesteld is.



<a name="Wireless"></a>
<h2>6.13 - Wat zijn mijn draadloze netwerkmogelijkheden?</h2>
OpenBSD heeft ondersteuning voor een aantal draadloze chipsets:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=acx&amp;sektion=4">acx(4)</a>
TI ACX100/ACX111. <sup>(NFF) (AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&amp;sektion=4">an(4)</a>
Aironet Communications 4500/4800.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ath&amp;sektion=4">ath(4)</a>
driver for Atheros 802.11a/b/g. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atu&amp;sektion=4">atu(4)</a>
Atmel AT76C50x USB 802.11b
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atw&amp;sektion=4">atw(4)</a>
ADMtek ADM8211.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=awi&amp;sektion=4">awi(4)</a>
AMD 802.11 PCnet Mobile.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bwi&amp;sektion=4">bwi(4)</a>
Broadcom AirForce 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cnw&amp;sektion=4">cnwi(4)</a>
Xircom CreditCard Netwave
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipw&amp;sektion=4">ipw(4)</a>
Intel PRO/Wireless 2100 802.11b. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&amp;sektion=4">iwi(4)</a>
Intel PRO/Wireless 2200BG/2225BG/2915ABG 802.11a/b/g. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwn&amp;sektion=4">iwn(4)</a>
Intel WiFi Link 4965/5100/5300 802.11a/b/g/Draft-N wireless.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=malo&amp;sektion=4">malo(4)</a>
Marvell Libertas 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pgt&amp;sektion=4">pgt(4)</a>
Conexant/Intersil Prism GT Full-MAC 802.11a/b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ral&amp;sektion=4">ral(4)</a>
and <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ural&amp;sektion=4">ural(4)</a> [USB]
Ralink Technology RT25x0 802.11a/b/g. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ray&amp;sektion=4">ray(4)</a>
Raytheon Raylink/WebGear Aviator 802.11FH
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rtw&amp;sektion=4">rtw(4)</a>
Realtek 8180 802.11b. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rum&amp;sektion=4">rum(4)</a>
Ralink Technology RT2501USB. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=run&amp;sektion=4">run(4)</a>
Ralink Technology USB 802.11a/b/g/Draft-N
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=uath&amp;sektion=4">uath(4)</a>
Atheros USB 802.11a/b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=upgt&amp;sektion=4">upgt(4)</a>
Conexant/Intersil PrismGT SoftMAC USB 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=urtw&amp;sektion=4">urtw(4)</a>
Realtek RTL8187L USB 802.11b/g
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&amp;sektion=4">wi(4)</a>
Prism2/2.5/3. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wpi&amp;sektion=4">wpi(4)</a>
Intel PRO/Wireless 3945ABG. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=zyd&amp;sektion=4">zyd(4)</a>
ZyDAS ZD1211/ZD1211B USB 802.11b/g
</ul>

<sup>(AP)</sup> geeft aan dat de kaart kan gebruikt worden als access point.<br>
<sup>(NFF)</sup> geeft aan dat de chip een niet-vrije firmware vereist die niet
bij OpenBSD kan gevoegd worden.
 
<p>
Adapters gebaseerd op deze chips kunnen gebruikt worden zoals gelijk welke
andere netwerkadapter om een OpenBSD systeem met een bestaand draadloos
netwerk te verbinden, en worden geconfigureerd met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
(kijk alstublieft in de manual pagina's voor details).
Sommige van deze kaarten kunnen ook in de
"Host-Based Access Point" mode gebruikt worden, wat hen toelaat om een
draadloos toegangspunt te vormen voor uw netwerk als onderdeel van uw
firewall.

<p>
Merk op dat om bepaalde van deze kaarten te gebruiken, u de firmwarebestanden
moet bekomen, waarvan de fabrikanten de
<a href="faq1.html#ReallyFree">vrije</a> verspreiding weigeren toe te laten,
zodat ze niet in OpenBSD kunnen opgenomen worden.
Wanneer het mogelijk is, bevatten de man pagina's waarnaar hierboven verwezen
wordt, contactinformatie zodat u de juiste mensen bij de fabrikanten kan
contacteren om hen te laten weten wat u hierover denkt, of om hen te laten
weten welk ander product u in de plaats hebt gekocht.

<p>
Een andere mogelijkheid om te overwegen om uw OpenBSD-gebaseerde firewall
draadloze toegang te laten voorzien, is om een conventionele NIC en een
extern bridging Access Point te gebruiken.
Dit heeft het bijkomend voordeel dat het u toelaat om gemakkelijk de antenne
te plaatsen waar die het meest effectief is, wat meestal niet direct aan
de achterzijde van uw firewall is.


<a name="Multipath"></a>
<h2>6.14 - Hoe kan ik gelijke-kost multipath routering doen?</h2>

<p>
Gelijke-kost multipath routering verwijst naar het hebben van meerdere routes
in de routeringstabel voor hetzelfde netwerk, zoals de standaardroute,
0.0.0.0/0.
Wanneer de kernel een route opzoekt om te bepalen naar waar hij pakketten
moet verzenden die bestemd zijn voor dat netwerk, kan hij gelijk welke
van de gelijke-kost routes kiezen.
In de meeste scenario's wordt multipath routering gebruikt om redundante
uplinkverbindingen aan te bieden, bv. redundante verbindingen naar het
Internet.

<p>
Het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>
commando wordt gebruikt voor het toevoegen/wijzigen/verwijderen van routes
in de routeringstabel.
Het <tt>-mpath</tt> argument wordt gebruikt voor het toevoegen van
multipath routes.

<blockquote><pre>
# <b>route add -mpath default 10.130.128.1</b>
# <b>route add -mpath default 10.132.0.1</b>
</pre></blockquote>

<p>
Verifieer de routes:

<blockquote><pre>
# <b>netstat -rnf inet | grep default</b>
default     10.130.128.1      UGS       2      134      -     fxp1
default     10.132.0.1        UGS       0      172      -     fxp2
</pre></blockquote>

<p>
In dit voorbeeld kunnen we zien dat één standaard route wijst naar
10.130.128.1, dat toegankelijk is via de fxp1 interface, en de andere
route wijst naar 10.132.0.1, dat toegankelijk is via fxp2.

<p>
Aangezien het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate&amp;sektion=5"
>mygate(5)</a> bestand nog geen multipath standaard routes ondersteunt,
moeten de bovenstaande commando's toegevoegd worden onderaan de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
>hostname.if(5)</a> bestanden voor de fxp1 en fxp2 interfaces.
Het <tt>/etc/mygate</tt> bestand moet dan verwijderd worden.

<dl>
<dt><b>/etc/hostname.fxp1</b></dt>
<dd><tt>!route add -mpath default 10.130.128.1</tt></dd>
<dt><b>/etc/hostname.fxp2</b></dt>
<dd><tt>!route add -mpath default 10.132.0.1</tt></dd>
</dl>

<p>
Vergeet tenslotte niet het gebruik van multipath routes te activeren door
de juiste sysctl(3) variabele in te schakelen.

<blockquote><pre>
# <b>sysctl net.inet.ip.multipath=1</b>
# <b>sysctl net.inet6.ip6.multipath=1</b>
</pre></blockquote>

<p>
Zorg ervoor dat u
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5"
>sysctl.conf(5)</a>
aanpast om de wijzigingen blijvend te maken.

<p>
Probeer nu een traceroute naar verschillende bestemmingen.
De kernel zal het verkeer balanceren over elke multipath route.

<blockquote><pre>
# <b>traceroute -n 154.11.0.4</b>
traceroute to 154.11.0.4 (154.11.0.4), 64 hops max, 60 byte packets
 1  10.130.128.1  19.337 ms  18.194 ms  18.849 ms
 2  154.11.95.170  17.642 ms  18.176 ms  17.731 ms
 3  154.11.5.33  110.486 ms  19.478 ms  100.949 ms
 4  154.11.0.4  32.772 ms  33.534 ms  32.835 ms

# <b>traceroute -n 154.11.0.5</b>
traceroute to 154.11.0.5 (154.11.0.5), 64 hops max, 60 byte packets
 1  10.132.0.1  14.175 ms  14.503 ms  14.58 ms
 2  154.11.95.38  13.664 ms  13.962 ms  13.445 ms
 3  208.38.16.151  13.964 ms  13.347 ms  13.788 ms
 4  154.11.0.5  30.177 ms  30.95 ms  30.593 ms
</pre>
</blockquote>

<p>
Voor meer informatie over hoe de route gekozen wordt, raadpleegt u
<a href="http://www.ietf.org/rfc/rfc2992.txt">RFC2992</a>, "Analysis of an
Equal-Cost Multi-Path Algorithm".

<p>
Het loont de moeite om te noteren dat als een interface die gebruikt wordt
door een multipath route, uitvalt (dus haar draaggolf verliest), de kernel
nog steeds pakketten zal proberen door te sturen die de route gebruiken die
naar die interface wijst.
Dit verkeer gaat natuurlijk op in het niets en gaat nergens naartoe.
Het wordt sterk aanbevolen om
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifstated&amp;sektion=8"
>ifstated(8)</a> te gebruiken om te controleren op onbeschikbare interfaces
en de routeringstabel naargelang aan te passen.


<p>
<font color="#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[Naar Sectie 5 - Het Systeem vanaf Broncode Bouwen]</a>
<a href="faq7.html">[Naar Sectie 7 - Toetsenbord en Scherm Bediening]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[terug]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq6.html,v 1.283 ]<br>
$Translation: faq6.html,v 1.66 2010/03/19 18:42:43 maurice Exp $<br>
-->
$OpenBSD: faq6.html,v 1.56 2010/03/29 07:15:38 ajacoutot Exp $
</small>

</body>
</html>

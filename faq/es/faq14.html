<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Configuraci&oacute;n del disco</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta http-equiv="Content-Language" content="es">
<meta name="resource-type" content="documento">
<meta name="description"   content="Preguntas Frecuentes de OpenBSD">
<meta name="keywords"      content="openbsd,faq,documentación">
<meta name="distribution"  content="global">
<meta name="copyright"     content="Este documento es copyright 1998-2004 de OpenBSD.">
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- máx. 72 caracteres por línea -->

<img alt="[OpenBSD]" height="30" width="141" src="../../images/smalltitle.gif">
<p>
<font color="#0000e0">
<a href="index.html">[&Iacute;ndice de documentos]</a>
<a href="faq12.html">[Secci&oacute;n 12 - Cuestiones sobre plataformas
espec&iacute;ficas]</a>
</font>

<h1><font color="#e00000">14 - Configuraci&oacute;n del
disco</font></h1><hr>

<h3>Tabla de contenidos</h3>
<ul>
<li><a href="#disklabel">14.1 - Utilizaci&oacute;n del <i>disklabel</i>
de OpenBSD</a>
<li><a href="#fdisk">14.2 - Utilizaci&oacute;n del <i>fdisk</i> de
OpenBSD</a>
<li><a href="#NewDisk">14.3 - C&oacute;mo a&ntilde;adir discos
adicionales en OpenBSD</a>
<li><a href="#SwapFile">14.4 - C&oacute;mo usar un fichero como memoria
de intercambio (<i>swap</i></a>
<li><a href="#SoftUpdates">14.5 - &quot;Soft Updates&quot;</a>
<li><a href="#Boot386">14.6 - El proceso de arranque de OpenBSD/i386 en
detalle</a>
<li><a href="#LargeDrive">14.7 - &iquest;Qu&eacute; problemas puede
haber en OpenBSD con dispositivos de gran capacidad?</a>
<li><a href="#InstBoot">14.8 - Instalaci&oacute;n de bloques de arranque
(espec&iacute;fico de i386)</a>
<li><a href="#Backup">14.9 - C&oacute;mo prepararse para el desastre:
hacer copias de seguridad (respaldo) y restaurar desde una cinta</a>
<li><a href="#MountImage">14.10 - C&oacute;mo montar im&aacute;genes de
disco en OpenBSD.</a>
<li><a href="#pciideErr">14.11 - &iexcl;Ayuda! &iexcl; da errores con
PCIIDE!</a>
<li><a href="#RAID">14.13 - Opciones de RAID con OpenBSD</a>
</ul>
<hr>

<a name="disklabel"></a>
<a name="14.1"></a>
<h2>14.1 - C&oacute;mo usar disklabel</h2>
   
<h3>Tabla de contenidos</h3>

<ul>
<li><a href="#disklabel.1">&iquest;Qu&eacute; es disklabel?</a>
<li><a href="#disklabel.2">disklabel durante la instalaci&oacute;n de
OpenBSD</a>
<li><a href="#disklabel.3">Usos comunes de disklabel</a>
</ul>
   

<a name="disklabel.1"></a>
<h3>&iquest;Qu&eacute; es disklabel?</h3>

<p>
Antes de empezar, se recomienda leer la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
   
<p>
Las &laquo;clasificaciones del disco&raquo; (<i>disklabels</i>) se crean
para permitir una interfaz eficiente entre el disco y los controladores
del disco que contiene el n&uacute;cleo del sistema (<i>kernel</i>).
Estas clasificaciones contienen cierta informaci&oacute;n sobre el
disco, como la geometr&iacute;a del controlador e informaci&oacute;n
sobre los sistemas de archivos (<i>filesystems</i>).  Esta
informaci&oacute;n la utiliza el programa de arranque para cargar el
controlador y para saber en qu&eacute; parte del controlador se
encuentran los sistemas de archivos.  Las clasificaciones tambi&eacute;n
se usan en conjunto con los sistemas de archivos para crear un entorno
m&aacute;s eficiente.  Hay una documentaci&oacute;n m&aacute;s detallada
sobre disklabel en la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>.

<p>
Adem&aacute;s, el uso de disklabel ayuda a superar las limitaciones de
las arquitecturas al particionar el disco.  Por ejemplo, en i386
s&oacute;lo se puede crear cuatro particiones primarias (particiones que
puedan ver otros sistemas operativos como Windows NT o DOS).  Con
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>,
una de esas particiones primarias se usa para almacenar <b>todas</b>
nuestras particiones de OpenBSD (<i>swap</i>, <i>/</i>, <i>/usr</i>,
<i>/var</i>, ...), y todav&iacute;a nos quedar&aacute;n tres particiones
libres para otros sistemas operativos.

<p>
<a name="disklabel.2"></a>
<h3>disklabel durante la instalaci&oacute;n de OpenBSD</h3>

<p>
Una de las partes principales de la instalaci&oacute;n de OpenBSD es la
creaci&oacute;n inicial de &laquo;clasificaciones&raquo;
(<i>labels</i>).  Para los usuarios de plataformas i386, &eacute;ste es
el paso que viene justo despu&eacute;s de usar
<a href="#fdisk">fdisk(1)</a>.  Durante la instalaci&oacute;n, el
programa que se usa para crear clasificaciones separadas que contengan
los puntos de montaje separados es
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
Durante este proceso se puede configurar los puntos de montaje desde
dentro de disklabel, pero esto no es del todo necesario si consideramos
que m&aacute;s tarde nos pedir&aacute; que confirmemos nuestras
elecciones.  De todos modos hace que la instalaci&oacute;n sea un poco
m&aacute;s suave.

<p>
Ya que esto ocurre durante la instalaci&oacute;n, todav&iacute;a no
tendremos ninguna clasificaci&oacute;n creada y, por lo tanto, antes
debemos crearlas.  La primera clasificaci&oacute;n que tendremos que
crear es la clasificaci&oacute;n '<b>a</b>'.  Esta clasificaci&oacute;n
DEBE ser en la que se monte el sistema de archivos <b>/</b>.  Puede
verse una lista de las particiones que se recomienda crear, y sus
respectivos tama&ntilde;os recomendados, en la
<a href="faq4.html#SpaceNeeded">secci&oacute;n 4.3</a> de las preguntas
frecuentes.  Para servidores se recomienda que, como m&iacute;nimo, se
creen estas particiones separadas.  Para los usuarios de computadoras
(ordenadores) de sobremesa, ser&aacute; suficiente con crear un
s&oacute;lo punto de montaje para <b>/</b>.  Cuando se cree por primera
vez esta partici&oacute;n ra&iacute;z (clasificaci&oacute;n <b>a</b>),
hay que tener en cuenta que ser&aacute; necesario dejar ALGO de espacio
para la clasificaci&oacute;n de <i>swap</i>.  Ahora que ya hemos
explicado lo m&aacute;s b&aacute;sico, pasemos a ver un ejemplo de la
utilizaci&oacute;n de disklabel durante la instalaci&oacute;n.  En este
primer ejemplo se asume que OpenBSD va a ser el &uacute;nico sistema
operativo en la m&aacute;quina, y que se llevar&aacute; a cabo una
instalaci&oacute;n completa.

<p>
<i>N. del T.:  el texto que sigue a continuaci&oacute;n est&aacute;
traducido para el prop&oacute;sito de este documento, pero durante la
instalaci&oacute;n el texto aparecer&aacute; en ingl&eacute;s</i>

<pre>
Si se comparte el disco con otros sistemas operativos, esos sistemas
operativos deben tener una entrada de la partici&oacute;n en la BIOS
que abarque completamente el espacio que ocupen.  Hay que asegurarse
de que todos los sistemas de archivos de OpenBSD se encuentren dentro
del tama&ntilde;o especificado en la tabla de particiones de la BIOS 'A6'
(por definici&oacute;n, el editor de disklabel tratar&aacute; de forzar
esto).  Si no se est&aacute; seguro de c&oacute;mo usar correctamente
particiones m&uacute;ltiples (o sea, /, /usr, /tmp, /var, /usr/local, y
otras separadas), se puede dividir el espacio de momento en una
partici&oacute;n ra&iacute;z y otra <i>swap</i>.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Intro&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Intro&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Intro&gt;</b>
block size: [8192] <b>&lt;Intro&gt;</b>
cpg: [16] <b>&lt;Intro&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Intro&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Intro&gt;</b>
</pre>

<p>
Hasta este punto hemos creado una partici&oacute;n ra&iacute;z de 64MB
montada en <b>/</b>, y una partici&oacute;n <i>swap</i> de 64MB.  Note
que empieza (&quot;offset&quot;) en el sector 63.  En la parte
correspondiente al tama&ntilde;o, disklabel muestra su tama&ntilde;o en
sectores; sin embargo no es necesario introducirlos en el mismo formato.
Como en el ejemplo anterior, puede introducir los tama&ntilde;os de la
forma <i>64 Megabytes = 64M</i> y <i>2 Gigabytes = 2G</i>.  Disklabel
los redondear&aacute; hasta el cilindro m&aacute;s cercano.
Tambi&eacute;n notar&aacute; en el ejemplo anterior que disklabel asume
que la clasificaci&oacute;n '<b>b</b>' ser&aacute; <i>swap</i>.  Esto es
correcto ya que el n&uacute;cleo del sistema GENERIC est&aacute;
configurado para buscar <i>swap</i> en la clasificaci&oacute;n <b>b</b>,
y todo lo que usted debe hacer es seguir esta gu&iacute;a y usar
<b>b</b> como su &aacute;rea de <i>swap</i>.

<p>
El siguiente ejemplo le guiar&aacute; por la creaci&oacute;n de dos
clasificaciones m&aacute;s.  Esto quiere decir que no es una
instalaci&oacute;n completa, ya que el tama&ntilde;o de &eacute;stas no
ser&aacute; suficiente para instalar OpenBSD al completo.  Mostrar otra
vez la creaci&oacute;n de todas las particiones ser&iacute;a redundante.

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Intro&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Intro&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Intro&gt;</b>
block size: [8192] <b>&lt;Intro&gt;</b>
cpg: [16] <b>&lt;Intro&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Intro&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Intro&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Intro&gt;</b>
block size: [8192] <b>&lt;Intro&gt;</b>
cpg: [16] <b>&lt;Intro&gt;</b>
</pre>

<p>
En este ejemplo puede notar dos diferencias con el anterior.  Una, que
el inicio del sector (<i>offset</i>) lo averigua de forma
autom&aacute;tica.  Cuando haga una instalaci&oacute;n de este tipo no
tendr&aacute; que configurar los sectores.  Otra diferencia es que la
clasificaci&oacute;n '<b>c</b>' representa a todo el disco.  Por este
motivo no debe tocar la clasificaci&oacute;n <b>c</b>.

<p>
Una vez que todas las clasificaciones hayan sido creadas, todo lo
quedar&aacute; por hacer ser&aacute; grabarlas en el disco y pasar al
proceso de instalaci&oacute;n.  Para grabarlo todo y salir de disklabel
(y continuar con la instalaci&oacute;n), haga lo siguiente:

<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>

<p>
<b>*NOTA*</b> - Para usuarios con discos grandes.  Si la BIOS de su
equipo no tiene soporte para el tama&ntilde;o de su disco, OpenBSD
tampoco tendr&aacute; soporte para &eacute;ste.  En cualquier otro caso
OpenBSD deber&iacute;a ser capaz de tratar su disco sin problema alguno.
Si se encuentra en una situaci&oacute;n en la que la BIOS de su
m&aacute;quina no dispone de soporte para su disco, puede probar Maxtor
EZ-Drive u otro producto complementario de similares
caracter&iacute;sticas.

<p>
<a name="disklabel.3"></a>
<h3>Uso general de disklabel(8)</h3>

<p>
Una vez que est&eacute; instalado el sistema, el uso frecuente de
disklabel no deber&iacute;a ser necesario.  Pero a veces tendr&aacute;
que usarlo cuando a&ntilde;ada, elimine, o reestructure sus discos.  Una
de las primeras cosas que tendr&aacute; que hacer ser&aacute; ver su
disklabel actual.  Para ello, escriba lo siguiente:

<pre>
# <b>disklabel wd0</b> &lt;----- O cualquier dispositivo de disco que quiera ver

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre>

<p>
La orden anterior le permite ver el disklabel presente, y de este modo
asegurarse de que no l&iacute;a nada (algo que todos necesitamos algunas
veces).  Pero para poder hacer cambios debe usar disklabel con la
opci&oacute;n -E, de este modo:

<pre>
# <b>disklabel -E wd0</b>
</pre>

<p>
Esto le llevar&aacute; hasta un &laquo;punto de pedido&raquo;
(&quot;prompt&quot;), el mismo que us&oacute; durante la
instalaci&oacute;n de OpenBSD.  Probablemente, la orden m&aacute;s
importante de todas en este punto de pedido sea '?'.  Con esta orden
obtendr&aacute; una lista de posibles opciones relacionadas con
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
Incluso podr&aacute; ver la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
al completo con la orden 'M'.  Desde este punto podr&aacute;
a&ntilde;adir o eliminar todo lo que desee, o hacer cambios en las
particiones.  Para m&aacute;s informaci&oacute;n al respecto lea la
p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.


<a name="fdisk"></a>
<h2>14.2 - C&oacute;mo usar fdisk</h2>

<p>
Antes que nada, aseg&uacute;rese de leer la p&aacute;gina del manual
principal de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>

<p>
Fdisk es un programa de ayuda para el mantenimiento de sus particiones.
Este programa se usa durante la instalaci&oacute;n para configurar la
partici&oacute;n de OpenBSD (esta partici&oacute;n puede contener
<u>varias</u> clasificaciones, cada una de ellas con sistemas de
archivos, <i>swap</i>, etc... ).  Puede dividir el espacio de sus
dispositivos y activar uno de ellos.  Fdisk se suele usar en &laquo;Modo
Monousuario&raquo; (<b>boot -s</b> - &quot;Single User Mode&quot;).
Fdisk tambi&eacute;n configura el MBR de los discos.

<p>
Para la instalaci&oacute;n, la mayor&iacute;a de las veces s&oacute;lo
necesitar&aacute; <b>UNA</b> partici&oacute;n de OpenBSD, y a
continuaci&oacute;n usar disklabel para poner en ella una <i>swap</i> y
un sistema de archivos.

<p>
Para ver s&oacute;lo su tabla de particiones con fdisk, haga lo
siguiente:

<pre>
# <b>fdisk fd0</b>
</pre>

<p>
lo que le dar&aacute; una salida parecida a &eacute;sta:

<pre>
         Disk: fd0       geometry: 80/2/18 [2880 sectors]
         Offset: 0       Signatures: 0xAA55,0x0
                  Starting        Ending
          #: id  cyl  hd sec -  cyl  hd sec [     start -       size]
----------------------------------------------------------------------
----------------------------------------------------------------------
         *0: A6    0   0   1 -   79   1  18 [         0 -       2880] OpenBSD
          1: 00    0   0   0 -    0   0   0 [         0 -          0] unused
          2: A7    0   0   2 -   79   1  18 [         1 -       2879] NEXTSTEP
          3: 00    0   0   0 -    0   0   0 [         0 -          0] unused
</pre>

<p>
En este ejemplo estamos viendo la salida de fdisk para el dispositivo de
la disquetera.  Podemos ver la partici&oacute;n de OpenBSD (A6) y su
tama&ntilde;o.  El asterisco (*) nos indica que la partici&oacute;n de
OpenBSD es una partici&oacute;n de arranque.

<p>
En el ejemplo anterior s&oacute;lo vimos nuestra informaci&oacute;n.
&iquest;Y si quisi&eacute;ramos editar nuestra tabla de particiones?
Pues bien, para ello debemos usar el indicador <b>-e</b>, que nos
trasladar&aacute; a una l&iacute;nea de &oacute;rdenes desde la que
podremos interaccionar con fdisk.

<pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre>

<p> 
Entrar en fdisk y explorar el disco es totalmente seguro, s&oacute;lo
debe asegurarse de contestar <b>N</b> cuando le pregunte si quiere
guardar los cambios, y de que NO usa la orden <b>write</b>.

<p>
Aqu&iacute; tiene una revisi&oacute;n de las &oacute;rdenes que puede
usar cuando escoja el indicador <b>-e</b>.

<ul>
<li><b>help</b> Mostrar una lista de las &oacute;rdenes comprensibles
para fdisk en el modo de edici&oacute;n interactiva.
<li><b>reinit</b> Iniciar la copia residente en memoria del bloque de
arranque seleccionado.
<li><b>disk</b> Mostrar la geometr&iacute;a del dispositivo que haya
verificado fdisk.  Si lo desea, puede editarla para aplicarle cambios.
<li><b>setpid</b> Cambiar el identificador de particiones de la entrada
en la tabla para la partici&oacute;n indicada.  Esta orden es
&uacute;til para la reasignaci&oacute;n de una partici&oacute;n
existente a OpenBSD.
<li><b>edit</b> Editar una cierta entrada en la tabla en la copia
residente en memoria del bloque de arranque actual.  Puede editarla en
modo de geometr&iacute;a de la BIOS o en modo de sectores de inicio y
tama&ntilde;os.
<li><b>flag</b> Activar una cierta entrada en la tabla de particiones
como partici&oacute;n de arranque.  Solamente se puede marcar una
entrada como partici&oacute;n de arranque.  Si quiere arrancar desde una
partici&oacute;n extendida, tendr&aacute; que marcar la entrada de la
partici&oacute;n en la tabla como partici&oacute;n de arranque.
<li><b>update</b> Actualizar el c&oacute;digo de la m&aacute;quina en la
copia residente en memoria del bloque de arranque seleccionado.
<li><b>select</b> Seleccionar y cargar en memoria el bloque de arranque
que se&ntilde;ala a la entrada en la tabla de particiones extendidas del
bloque de arranque actual.
<li><b>print</b> Mostrar en pantalla la copia residente en memoria del
bloque de arranque seleccionado y su tabla MBR.
<li><b>write</b> Grabar la copia residente en memoria del bloque de
arranque al disco.  Le pedir&aacute; que confirme esta operaci&oacute;n.
<li><b>exit</b> Salir del nivel actual de fdisk, volviendo al bloque de
arranque residente en memoria previamente seleccionado, o saliendo
completamente del programa si no hubiera ninguno.
<li><b>quit</b> Salir del nivel actual de fdisk, volviendo al bloque de
arranque residente en memoria previamente seleccionado, o saliendo
completamente del programa si no hubiera ninguno.  A diferencia de
<b>exit</b>, no guarda los cambios del bloque modificado.
<li><b>abort</b> Salir del programa sin guardar cambios.
</ul>

<a name="NewDisk"></a>
<h2>14.3 - C&oacute;mo a&ntilde;adir discos adicionales</h2>

<p>
Una vez que ya tenga su disco instalado <b>CORRECTAMENTE</b>,
deber&aacute; usar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>s&oacute;lo i386</i>) y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
para configurarlo en OpenBSD.

<p>
Los usuarios de plataformas i386 deben empezar con fdisk.  El resto de
plataformas pueden ignorar esta parte.  En el ejemplo que sigue a
continuaci&oacute;n estamos a&ntilde;adiendo un tercer dispositivo SCSI
al sistema.

<pre>
# <b>fdisk -i sd2</b>
</pre>

<p>
De este modo se iniciar&aacute; la tabla de particiones
&laquo;real&raquo; para su uso exclusivo por OpenBSD.  A
continuaci&oacute;n debe crear un disklabel.  Esto le parecer&aacute;
algo confuso.

<pre>
# <b>disklabel -e sd2</b>

<i>(la pantalla se queda en blanco y aparece su $EDITOR)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre>

<p>
Ignore la partici&oacute;n <b>c</b>, siempre est&aacute; ah&iacute; y es
para que funcionen programas como disklabel.  El tipo de sistema de
archivos (<i>fstype</i>) para OpenBSD es 4.2BSD.  El n&uacute;mero total
de sectores es el tama&ntilde;o total del disco.  Supongamos que
&eacute;ste es un disco de 3GB;  tres gigabytes, en t&eacute;rminos del
fabricante del disco, son 3000 megabytes.  Divida 6185088 entre 3000
(use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">
bc(1)</a>) y obtendr&aacute; 2061.  Por lo tanto, para crear particiones
para a, d, e, f, g, ... simplemente multiplique X*2061 y obtendr&aacute;
el n&uacute;mero de megabytes de espacio en esa partici&oacute;n.  El
sector de inicio (<i>offset</i>) para su primera partici&oacute;n nueva
debe ser el mismo que el &quot;<i>sectors/track</i>&quot; que le haya
dado anteriormente la salida de disklabel.  En este caso es 63.  El
sector de inicio para cada partici&oacute;n consecutiva debe ser una
combinaci&oacute;n del tama&ntilde;o de cada partici&oacute;n y el
sector de inicio de la misma (excepto la partici&oacute;n <b>c</b>, ya
que no juega ning&uacute;n papel aqu&iacute;).

<p>
O, si s&oacute;lo quiere tener una partici&oacute;n en el disco (si, por
ejemplo, quisiera usarlo todo para almacenaje de web o como directorio
home), tome el tama&ntilde;o total del disco y r&eacute;stele los
sectores por pista (&quot;sectors/track&quot;).  En este caso,
6185088-63 = 6185025.  La partici&oacute;n quedar&aacute; as&iacute;:

<pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre>

<p>
<b>&iexcl;Si todo esto le parece complicado e innecesario, puede usar
disklabel -E para obtener el mismo modo de particiones que tiene en su
disco de instalaci&oacute;n!</b> Ah&iacute; puede usar &laquo;96M&raquo;
para especificar &laquo;96 megabytes&raquo; (o con un disco lo bastante
grande, 96G para 96 gigabytes).  Desafortunadamente, el modo -E usa la
geometr&iacute;a del disco de la BIOS, no la geometr&iacute;a del disco
real, y con frecuencia &eacute;stas no son las mismas.  Para evitar esta
limitaci&oacute;n, escriba 'g d' para la 'geometr&iacute;a del disco'.
Otras opciones son 'g b' para la 'geometr&iacute;a de la bios' y 'g u'
para la 'geometr&iacute;a del usuario', o simplemente lo que indique la
&laquo;clasificaci&oacute;n&raquo; (<i>label</i>) antes de que disklabel
efect&uacute;e alg&uacute;n cambio.

<p>
Esto ha sido largo, pero todav&iacute;a no ha terminado.  Para
finalizar, debe crear el sistema de archivos en el disco usando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>.

<pre>
# <b>newfs sd2a</b>
</pre>

<p>
O cualquiera otra denominaci&oacute;n de su disco de acuerdo con el
esquema de numeraci&oacute;n del disco de OpenBSD (mire la salida de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a> 
para averiguar el nombre que OpenBSD da a su disco).

<p>
Ahora debe decidir d&oacute;nde va a montar la nueva partici&oacute;n
que acaba de crear.  Digamos que quiere ponerla en /u.  Primero cree el
directorio /u, y luego m&oacute;ntelo.

<pre>
# <b>mount /dev/sd2a /u</b>
</pre>

<p>
Finalmente, a&ntilde;&aacute;dalo a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>:

<pre>
/dev/sd2a /u ffs rw 1 1
</pre>

<p>
&iexcl;Y si necesitara migrar a un directorio ya existente como
/usr/local?  Entonces deber&iacute;a montar la partici&oacute;n nueva en
/mnt, y usar <tt>cpio -pdum</tt> para copiar /usr/local al directorio
/mnt.  A continuaci&oacute;n editar el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
para indicar que la partici&oacute;n /usr/local es ahora /dev/sd2a (su
partici&oacute;n reci&eacute;n creada).  Por ejemplo:

<pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre>

<p>
Reinicie en modo monousuario con <b>boot -s</b> y copie el fichero
/usr/local existente a /usrs/local-backup (eliminando el original cuando
est&eacute; seguro), y cree un directorio /usr/local vac&iacute;o.
Reinicie el sistema y &iexcl;ya est&aacute;!  &iexcl;ah&iacute;
est&aacute;n los ficheros!


<a name="SwapFile"></a>
<h2>14.4 - C&oacute;mo usar un fichero como memoria de <i>swap</i></h2>

<p>
(Nota: si lo que quiere es usar un fichero como memoria de intercambio
(<i>&quot;swap&quot;</i>) porque obtiene errores del tipo &quot;virtual
memory exhausted&quot;, deber&iacute;a intentar antes elevar los
l&iacute;mites por proceso con la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a> de csh, o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>) de sh.

<p>
Para el uso de un fichero como memoria de intercambio (<i>swap file</i>)
no es estrictamente necesaria la compilaci&oacute;n de un n&uacute;cleo
del sistema personalizado, pero en este documento mostraremos
c&oacute;mo a&ntilde;adir espacio <i>swap</i> de las dos formas.

<p>
<h3>Usar un fichero como <i>swap</i></h3>

<p>
Usar un fichero como memoria de <i>swap</i> es la forma m&aacute;s
f&aacute;cil y r&aacute;pida de obtener una configuraci&oacute;n
adicional del espacio de <i>swap</i>.  El fichero no debe residir en un
sistema de archivos que tenga SoftUpdates activado (se encuentra
desactivado por definici&oacute;n).  Para empezar, puede ver
cu&aacute;nta memoria de <i>swap</i> tiene en ese momento y
cu&aacute;nta est&aacute; usando con la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>,
del modo siguiente:

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre>

<p>
Esto le mostrar&aacute; los dispositivos que est&aacute;n siendo usados
como memoria de <i>swap</i> y sus estad&iacute;sticas actuales.  En el
ejemplo anterior, s&oacute;lo hay un dispositivo denominado
&quot;swap_device&quot;.  &Eacute;ste es el &aacute;rea predefinida para
<i>swap</i> (si lo vi&eacute;ramos con disklabel, lo mostrar&iacute;a
como la partici&oacute;n b).  Tambi&eacute;n puede ver en el ejemplo
anterior que el dispositivo no est&aacute; siendo muy usado en ese
momento.  Pero para el prop&oacute;sito de este documento, procederemos
como si necesit&aacute;ramos 32MB adicionales.

<p>
El primer paso para configurar un fichero como un dispositivo de
<i>swap</i> es crear el fichero.  El mejor modo de hacerlo es con la
utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">
dd(1)</a>.  He aqu&iacute; un ejemplo de c&oacute;mo crear el fichero
<i>/var/swap</i>, que tendr&aacute; un tama&ntilde;o de 32MB.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Una vez que lo hayamos creado, podemos activar el uso de ese dispositivo
como memoria de <i>swap</i>.  Para activarlo, use la siguiente orden:

<pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre>

<p>
Ahora debemos comprobar si se ha a&ntilde;adido correctamente a la lista
de nuestros dispositivos de <i>swap</i>.

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>

<p>
Ahora que ya est&aacute; activado el fichero y que se est&aacute; usando
como <i>swap</i>, debe a&ntilde;adir una l&iacute;nea a su fichero
<i>/etc/fstab</i>, para que el fichero tambi&eacute;n se active en el
pr&oacute;ximo arranque.  Si no a&ntilde;ade esta l&iacute;nea, no
tendr&aacute; este dispositivo de <i>swap</i> configurado.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre>

<p>
<h3>Usar <i>swap</i> a trav&eacute;s de un dispositivo vnode</h3>

<p>
&Eacute;sta es una soluci&oacute;n m&aacute;s permanente que la de
a&ntilde;adir m&aacute;s espacio de <i>swap</i>.  Para usar
permanentemente un fichero como memoria de <i>swap</i>, primero compile
un n&uacute;cleo con vnd0c como <i>swap</i>.  Si su sistema de archivos
ra&iacute;z es wd0a, entonces wd0b es el <i>swap</i> anterior y debe
usar la siguiente l&iacute;nea en el fichero de configuraci&oacute;n del
n&uacute;cleo (si tiene dudas, lea el
<a href="faq5.html">cap&iacute;tulo 5</a> de las preguntas frecuentes
referente a la compilaci&oacute;n del n&uacute;cleo del sistema):

<pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre>

<p>
Despu&eacute;s de esto, tendr&aacute; que crear el fichero que se
usar&aacute; como memoria de <i>swap</i>.  Debe hacerlo usando la misma
orden que en los ejemplos anteriores.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Ahora el fichero est&aacute; en su sitio y debe a&ntilde;adirlo a
<i>/etc/fstab</i>.  Aqu&iacute; tiene una l&iacute;nea de ejemplo de
c&oacute;mo arrancar con este dispositivo como <i>swap</i>.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre>

<p>
En este punto su m&aacute;quina debe ser reiniciada para que los cambios
en el n&uacute;cleo hagan efecto.  A continuaci&oacute;n deber&aacute;
configurar el dispositivo como memoria de <i>swap</i>.  Para ello
usar&aacute;
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>.

<pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre>

<p>
El &uacute;ltimo paso es activar ese dispositivo como memoria de
<i>swap</i>.  Lo haremos como en los ejemplos anteriores, usando
swapctl(8).  Despu&eacute;s comprobaremos si ha sido correctamente
a&ntilde;adido a nuestra lista de dispositivos de <i>swap</i>.

<pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>


<a name="SoftUpdates"></a>
<h2>14.5 - Soft Updates</h2>

<p>
<i>Soft Updates</i> est&aacute; basado en una idea propuesta por
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg
Gangerand Yale Patt</a> y desarrollada para FreeBSD por
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a>.
<i>Soft Updates</i> impone un orden parcial en las operaciones de la
memoria intermedia de cach&eacute; que eliminar la escritura
sincr&oacute;nica de entradas de directorio del c&oacute;digo de FFS.
De este modo se consigue un gran aumento en el rendimiento de la
escritura en disco.

<p>
El potencial de ejecutar fsck(8) en plano de fondo usando <i>Soft
Updates</i> a&uacute;n no es posible en OpenBSD, por lo que
todav&iacute;a es necesario
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">
fsck(8)</a> despu&eacute;s de que el sistema se apague de forma abrupta.
Esto puede cambiar en versiones futuras.

<p>
Para activar <i>Softupdates</i>, el n&uacute;cleo debe estar compilado
con

<p>
<b>option FFS_SOFTUPDATES</b>

<p>
Esta opci&oacute;n est&aacute; incluida en el n&uacute;cleo GENERIC.

<p>
La activaci&oacute;n de <i>Soft Updates</i> se debe realizar con una
opci&oacute;n de tiempo en el montaje.  Cuando se monta una
partici&oacute;n con la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>,
se puede indicar que se active <i>soft updates</i> en esa
partici&oacute;n.  La siguiente muestra es de una entrada en
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i> 
para una partici&oacute;n <i>sd0a</i> que queremos que se monte con
<i>soft updates</i> activado.

<pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre>

<p>
Nota para los usuarios de sparc:  no se debe activar <i>soft updates</i>
en las m&aacute;quinas sun4 o sun4c.  Estas arquitecturas s&oacute;lo
tienen soporte para una cantidad de memoria del n&uacute;cleo muy
limitada, y no pueden usar esta funcionalidad.  Las m&aacute;quinas
sun4m no tienen esta limitaci&oacute;n y s&iacute; pueden usarla.

<a name="Boot386"></a>
<h2>14.6 - El proceso de arranque de OpenBSD/i386 en detalle</h2>

<p>
El proceso de arranque de OpenBSD/i386 no es algo trivial, y entender
c&oacute;mo funciona puede ayudarnos a resolver alg&uacute;n problema.
Hay cuatro piezas clave en el proceso de arranque:
<ol>
<li><i><b>Registro de Arranque Maestro</b> (Master Boot Record,
MBR):</i>  El MBR es el primer sector f&iacute;sico del disco (los
primeros 512 bytes).  Contiene la tabla de particiones primarias y un
peque&ntilde;o programa para cargar el <i>Partition Boot Record</i>
(PBR).  N&oacute;tese que en algunos entornos, el t&eacute;rmino MBR se
usa para referirse &uacute;nicamente a la parte de c&oacute;digo de este
primer bloque del disco, en lugar de referirse a todo este primer bloque
(incluida la tabla de particiones).  Es importante que se entienda el
sentido de <i>&quot;initialize the MBR&quot;</i> (iniciar el MBR), ya
que dentro de la terminolog&iacute;a que se usa en OpenBSD esto incluye
la reescritura de todo el sector del MBR, no s&oacute;lo del
c&oacute;digo como en algunos sistemas.  Esto es algo que rara vez se
querr&aacute; hacer.  En lugar de ello, hay que usar la orden
<tt>&quot;update&quot;</tt> de fdisk(8).

<p>
Aunque OpenBSD incluya un MBR, no es necesario usar &eacute;ste ya que
pr&aacute;cticamente cualquier otro MBR puede arrancar OpenBSD.  El MBR
se manipula con el programa fdisk(8), que se usa para modificar la tabla
de particiones adem&aacute;s de para instalar el c&oacute;digo de MBR en
el disco.

<p>
El MBR de OpenBSD se anuncia con el mensaje
<pre>
    Using Drive: 0 Partition: 3
</pre>
mostrando as&iacute; el disco y la partici&oacute;n desde las que va a
cargar el PBR.

<li><i><b>Registro de Arranque de la Partici&oacute;n</b> (Partition
Boot Record, PBR):</i>  El PBR, tambi&eacute;n llamado
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
(por el nombre del archivo que contiene el c&oacute;digo) es el primer
sector f&iacute;sico de la partici&oacute;n de OpenBSD del disco.  El
PBR es la &laquo;primera fase del cargador de arranque&raquo; para
OpenBSD.  El PBR lo carga el c&oacute;digo del MBR, y tiene la
funci&oacute;n de cargar la segunda fase del cargador de arranque,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>.
Como el MBR, el PBR es una peque&ntilde;&iacute;sima secci&oacute;n de
c&oacute;digo y datos, tan s&oacute;lo 512 bytes en total.  Eso no es
suficiente para tener una aplicaci&oacute;n que pueda hacer uso total
del sistema de archivos.  Por lo tanto, en lugar de dejar que el PBR
localice <tt>/boot</tt> en el disco, la ubicaci&oacute;n accesible por
la BIOS de <tt>/boot</tt> se codificada f&iacute;sicamente en PBR
durante la instalaci&oacute;n.

<p>
El PBR lo instala
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot</a>,
que se describe con detalle en la
<a href="faq14.html#InstBoot">secci&oacute;n 14.8</a> de este documento.
El PBR se anuncia con el mensaje
<pre>
    reading boot....
</pre>
imprimiendo la l&iacute;nea de puntos seg&uacute;n va leyendo los
sectores del disco.

<li><b><i>Cargador de Arranque de Segunda Fase, <tt>/boot</tt>:</i></b>
<tt>/boot</tt> es cargado por el PBR, y tiene la funci&oacute;n de
acceder al sistema de archivos de OpenBSD a trav&eacute;s de la BIOS de
la m&aacute;quina, y de ubicar y cargar el n&uacute;cleo del sistema
(<i>kernel</i>).  boot(8) tambi&eacute;n pasa varias opciones e
informaci&oacute;n al n&uacute;cleo del sistema.

<p>
boot(8) es un programa interactivo.  Despu&eacute;s de cargarse, intenta
ubicar y leer <tt>/etc/boot.conf</tt> si existe (en una
instalaci&oacute;n t&iacute;pica no existe), y procesa cualquier orden
que lleva.  A menos que <tt>/etc/boot.conf</tt> le d&eacute; otras
instrucciones, pasa un punto de inserci&oacute;n al usuario:

<pre>
     probing: pc0 com0 com1 apm mem[636k 190M a20=on]
     disk: fd0 hd0+
     &gt;&gt; OpenBSD/i386 BOOT 2.02
     boot&gt;
</pre>

En la configuraci&oacute;n predeterminada, le da al usuario cinco
segundos para que le pase alguna orden;  si no se hace nada durante este
tiempo, incia su tarea predeterminada:  cargar el n&uacute;cleo del
sistema, <tt>bsd</tt>, desde la partici&oacute;n ra&iacute;z del primer
disco duro.  El cargador de arranque de segunda fase sondea (examina) el
<i>hardware</i> del sistema a trav&eacute;s de la BIOS (ya que
todav&iacute;a no se ha cargado el n&uacute;cleo de OpenBSD).  En el
cuadro de arriba se pueden ver unas pocas cosas que ha buscado y
encontrado:
<ul>
<li><b>pc0</b> - El teclado y la pantalla de v&iacute;deo t&iacute;picas
de un sistema i386
<li><b>com0, com1</b> - Dos puertos serie
<li><b>apm</b> - Funciones <i>Advanced Power Management</i> de la BIOS
<li><b>636k 190M</b> - La cantidad de memoria convencional (por debajo
de 1MB) y extendida (por encima de 1MB) que ha encontrado
<li><b>fd0 hd0+</b> - Los dispositivos de disco de la BIOS que
encuentra;  en este caso una disquetera y un disco duro
</ul>

<p>
El caracter '+' despu&eacute;s de &quot;hd0&quot; indica que la BIOS a
informado a <tt>/boot</tt> de que este disco es accesasible mediante
LBA.  Cuando se realiza una primera instalaci&oacute;n, a veces se
observa un caracter '*' despu&eacute;s del disco duro;  esto indica un
disco que no parece tener una clasificaci&oacute;n de disco de OpenBSD
v&aacute;lida.

<li><b><i>Kernel: <tt>/bsd</tt></i>:</b>  El <i>kernel</i> o
n&uacute;cleo del sistema es el objetivo final de todo el proceso de
arranque:  cargar el n&uacute;cleo en la RAM y que se ejecute
correctamente.  Una vez que se ha cargado el n&uacute;cleo, OpenBSD
accede directamente al <i>hardware</i>, sin que ya sea necesario que
vaya a trav&eacute;s de la BIOS.
</ol>

<p>
As&iacute; pues, el inicio del proceso de arranque seguir&iacute;a un
esquema como el siguiente:
<blockquote><pre>
Using Drive: 0 Partition: 3                      <b><i>&lt;- MBR</i></b>
reading boot....                                 <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
&gt;&gt; OpenBSD/i386 BOOT 2.02
boot&gt;
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993     <b><i>&lt;- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2003 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 3.4 (GENERIC) #18: Wed Sep 17 03:34:47 MDT 2003
   ...
</pre></blockquote>


<h3>Posibles errores</h3>
<ul>
<li><b>MBR en mal estado, no v&aacute;lido, o incompatible:</b>
Generalmente, un disco duro usado contiene algo de c&oacute;digo de MBR;
pero si el disco es nuevo o se encontraba anteriormente en una
plataforma diferente, Y SI hemos contestado <i>&quot;Yes&quot;</i> a la
pregunta de si quer&iacute;amos usar todo el disco (<i>&quot;Use entire
disk&quot;</i>) durante el <a href="faq4.html#Disks">proceso de
instalaci&oacute;n</a>, podemos acabar con un disco sin un MBR
v&aacute;lido y que ni siquiera podr&aacute; arrancar, aun cuando
contenga una tabla de particiones v&aacute;lida.

<p>
En este caso podemos instalar el MBR de OpenBSD en el disco duro usando
el programa fdisk.  Para ello arrancaremos desde el medio de
instalaci&oacute;n que tengamos, y escogeremos la opci&oacute;n
&quot;Shell&quot; para obtener un punto de inserci&oacute;n de
&oacute;rdenes, desde donde le pasaremos la orden:
<pre>
    # <b>fdisk -u wd0</b>
</pre>

<p>
Tambi&eacute;n podemos instalar un MBR espec&iacute;fico en el disco
usando fdisk.  Por ejemplo:
<pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre> 

instalar&aacute; el archivo <tt>/usr/mdec/mbr</tt> como el MBR de
nuestro sistema.  Este archivo en concreto, en una instalaci&oacute;n
t&iacute;pica de OpenBSD, es el MBR est&aacute;ndar que tambi&eacute;n
se encuentra dentro de fdisk.  Pero se puede especificar cualquier otro
MBR.

<li><b>Ubicaci&oacute;n no v&aacute;lida  de <tt>/boot</tt> instalada
en PBR:</b>
Cuando installboot(8) instala el registro de arranque de la
partici&oacute;n, escribe la ubicaci&oacute;n f&iacute;sica de los
sectores del disco de <tt>/boot</tt> en el PBR.  Por lo tanto, si se
elimina y sustituye <tt>/boot</tt> sin volver a ejecutar
<a href="faq14.html#InstBoot">installboot(8)</a>, el sistema no
podr&aacute; arrancar; el motivo es que el PBR carga cualquier cosa que
se encuentre en los bloques que tiene especificados, que seguramente ya
no ser&aacute; el cargador de arranque de segunda fase.  Dado que
<tt>/boot</tt> se lee usando las llamadas a la BIOS, si se altera la
geometr&iacute;a del disco (o sea, si se pasa de una m&aacute;quina que
usa traducci&oacute;n CHS a otra que usa traducci&oacute;n LBA, o si se
cambia la opci&oacute;n de traducci&oacute;n en la BIOS), la BIOS
entender&aacute; que se encuentra en una ubicaci&oacute;n diferente
(para obtener los mismos datos del disco hay que acceder a un bloque
num&eacute;rico diferente).  De nuevo, aqu&iacute; ser&aacute; necesario
ejecutar installboot(8) antes de poder volver a arrancar el sistema.
Como el PBR es muy peque&ntilde;o, el rango de mensajes de error es
bastante limitado:

<ul>
<li><b>Read Error</b> -- La BIOS devuelve un error al intentar leer un
bloque desde el disco.  Podr&iacute;a ser un problema f&iacute;sico del
disco, o que se ha llamado a un sector no v&aacute;lido (o sea, un
problema de geometr&iacute;a del disco).
<li><b>Bad magic</b> -- Se ha le&iacute;do un n&uacute;mero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>
no v&aacute;lido en la cabecera del cargador de arranque de segunda
fase.  Esto, generalmente, significa que sea lo que fuere que se haya
le&iacute;do, NO era <tt>/boot</tt>.  Este problema se suele deber a un
problema con la geometr&iacute;a del disco, al haber sustituido
<tt>/boot</tt> en el disco o por haber ignorado las
<a href="faq14.html#LargeDrive">limitaciones de 8GB &oacute; de la
BIOS</a> del sistema, y haber acabado <tt>/boot</tt> en alguna parte en
donde no lo puede localizar el PBR.
</ul>
</ul>

<p>
Para m&aacute;s informaci&oacute;n sobre el proceso de arranque de i386,
v&eacute;ase los documentos:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="ftp://ftp.openbsd.org/pub/OpenBSD/3.4/i386/INSTALL.mbr">INSTALL.mbr</a>
<li><a href="ftp://ftp.openbsd.org/pub/OpenBSD/3.4/i386/INSTALL.ata">INSTALL.ata</a>
<li><a href="ftp://ftp.openbsd.org/pub/OpenBSD/3.4/i386/INSTALL.chs">INSTALL.chs</a>
<li><a href="ftp://ftp.openbsd.org/pub/OpenBSD/3.4/i386/INSTALL.dbr">INSTALL.dbr</a>
</ul>


<a name="LargeDrive"></a>
<h2>14.7 - &iquest;Qu&eacute; problemas puede haber en OpenBSD con
dispositivos de gran capacidad?</h2>

<p>
OpenBSD tiene soporte para sistemas de archivos de tama&ntilde;os mucho
mayores que cualquier de los discos duros que existen en la actualidad o
incluso de los que puedan aparecer en breve;  sin embargo, existen
limitaciones en algunas interfaces que son de menor tama&ntilde;o que el
m&aacute;ximo te&oacute;rico de OpenBSD.

<p>
No son posibles todas las combinaciones de <i>hardware</i>.  Un nuevo
disco duro IDE de 250GB no funcionar&aacute; en las interfaces
m&aacute;s viejas (anteriores a los est&aacute;ndares &gt;137GB), y
algunos adaptadores SCSI muy viejos han dado problemas con discos
m&aacute;s modernos.  Hay que respetar las posibilidades y limitaciones
del <i>hardware</i>.

<h3>Limitaciones al tama&ntilde;o de la partici&oacute;n y
ubicaci&oacute;n</h3>
<p>
Desafortunadamente, la capacidad absoluta del sistema operativo no se
encontrar&aacute; disponible hasta DESPU&Eacute;S de que el sistema
operativo haya sido cargado en la memoria y el proceso de arranque haya
introducido sus propios l&iacute;mites.  El proceso de arranuqe tiene
que utilizar (y por lo tanto est&aacute; limitado por) la ROM de
arranque del sistema.  El cargador de arranque de primera face de
OpenBSD/i386
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>)
tambi&eacute;n tiene su propia limitaci&oacute;n interna de 8GB,
heredada del l&iacute;mite de las BIOS antiguas.

<p>
Por este motivo, todo el fichero <i>/bsd</i> (el n&uacute;cleo del
sistema) se debe ubicar dentro del &aacute;rea direccionable de la ROM
de arranque en el disco, o dentro de los primeros 8G del disco,
cualquiera que sea m&aacute;s peque&ntilde;a.  Esto significa que en
algunos equipos i386 m&aacute;s antiguos, la partici&oacute;n
<i>root</i> debe encontrarse dentro del l&iacute;mite de los primeros
504M, pero en la mayor&iacute;a de equipos nuevos se puede encontrar en
cualquier parte dentro de los primeros 8G.

<p>
N&oacute;tese que es posible instalar un dispositivo de 40GB en un 486
antiguo y cargar OpenBSD como una sola partici&oacute;n gigante, y por
ello creer que la regla anterior ha sido violada con &eacute;xito.  Sin
embargo, puede volver para vengarse en un modo horrible:

<ul>
<li>Instala el sistema en la partici&oacute;n <i>/</i> de 40G.
Funciona, ya que el sistema operativo base y sus ficheros, incluido
<i>/bsd</i>, se encuentran dentro de los primeros 504M.
<li>Utiliza el sistema hasta que acaba con m&aacute;s de 504M en
ficheros.
<li>Lo actualiza, compila su propio n&uacute;cleo, cualquier otra cosa,
y copia su nuevo <i>/bsd</i> sobre el antiguo.
<li>Reinicia el sistema.
<li>Le aparece un mensaje tipo &quot;bad magic&quot;.
</ul>

<p>
&iquest;Por qu&eacute;?  Porque cuando copi&oacute; &laquo;sobre&raquo;
el nuevo fichero <i>/bsd</i>, no sobreescribi&oacute; el antiguo, sino
que se reubic&oacute; en un nuevo espacio del disco, probablemente fuera
del rango de los 504M para los que tiene soporte la BIOS.  El cargador
de arranque no pudo localizar <i>/bsd</i> y el sistema se colg&oacute;.

<p>
Para que OpenBSD arranque, los cargadores de arranque (biosboot(8) y
<tt>/boot</tt> en el caso de i386) y el n&uacute;cleo (<tt>/bsd</tt>)
deben encontrarse dentro del rango del soporte de la ROM de arranque, y
dentro de sus propias capacidades.  Para ir sobre seguro, la regla es
f&aacute;cil:

<p>
<b>Toda la partici&oacute;n <i>root</i> debe estar dentro del espacio
direccionable por la BIOS (o ROM de arranque) de la m&aacute;quina o
dentro de los primeros 8G, cualquiera que sea el m&aacute;s
peque&ntilde;o de los dos.</b>
En este momento no hay forma de evitar esto, <i>es necesario</i> seguir
esta regla.

<p>
&Eacute;sta es otra buena raz&oacute;n para
<a href="faq4.html#SpaceNeeded">dividir el disco duro en
particiones</a>, en lugar de usar una &uacute;nica partici&oacute;n
grande.

<h3>Requisitos de tiempo y memoria de fsck(8)</h3>
<p>
Otra consideraci&oacute;n con sistemas de archivos grandes es la del
tiempo y memoria requeridos para poder usar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">
fsck(8)</a> en el sistema de archivos despu&eacute;s de una ca&iacute;da
del sistema o de una interrupci&oacute;n de la fuente el&eacute;ctrica.
No se debe poner un sistema de archivos de 120GB en un sistema con 32MB
de RAM y esperar que fsck(1) se ejecute con &eacute;xito despu&eacute;s
de una ca&iacute;da.  El sistema deber&iacute;a tener como m&iacute;nimo
1MB de memoria disponible por cada 1GB de espacio en disco para que fsck
se ejecute con &eacute;xito sobre el disco.  El tiempo requerido para
que fsck repare el disco puede ser un problema seg&uacute;n se va
incrementando el tama&ntilde;o del sistema de archivos.


<a name="InstBoot"></a>
<h2>14.8 - Instalaci&oacute;n de bloques de arranque (espec&iacute;fico
de i386)</h2>

<p>
Las versiones m&aacute;s antiguas de MS-DOS s&oacute;lo pod&iacute;an
reconocer geomtr&iacute;as de disco de 1024 cilindros o menos.  Ya que
casi pr&aacute;cticamente todos los discos modernos tienen m&aacute;s de
1024 cilindros, la mayor&iacute;a de chips de BIOS SCSI (que vienen
integrados en la tarjeta controladora SCSI) y de BIOS IDE (que son parte
del resto de la BIOS para PCs) disponen de una opci&oacute;n (algunas
veces preactivada) para &laquo;traducir&raquo; la geometr&iacute;a real
del disco en algo que est&eacute; dentro de los l&iacute;mites de la
capacidad de MS-DOS.  Sin embargo, no todos los chips de BIOS
&laquo;traducen&raquo; la geometr&iacute;a del mismo modo.  Si cambia su
BIOS (instalando una nueva placa base o a&ntilde;adiendo una nueva
controladora SCSI) y la nueva usa una &laquo;traducci&oacute;n&raquo; de
la geometr&iacute;a diferente, no podr&aacute; cargar la segunda fase
del gestor de arranque (y por lo tanto no podr&aacute; cargar el
n&uacute;cleo).  Esto se debe a que la primera fase del gestor de
arranque contiene una lista de bloques que comprende <i>/boot</i> en
t&eacute;rminos de la geometr&iacute;a &laquo;traducida&raquo; original.
Si est&aacute; usando discos IDE y realiza cambios en la
configuraci&oacute;n de su BIOS, tambi&eacute;n puede cambiar sin
saberlo su traducci&oacute;n (la mayor&iacute;a de BIOS IDE ofrecen 3
traducciones diferentes).  Para que su bloque de arranque pueda iniciar
con normalidad, ponga un disquete de arranque (o use un CD-ROM con
capacidad arranque), y en el punto <kbd>boot&gt;</kbd> escriba <kbd>b
hd0a:/bsd</kbd> para forzar el arranque desde el primer disco duro (y no
desde el disquete).  Su m&aacute;quina deber&iacute;a iniciar sin
ning&uacute;n problema.  Ahora debe actualizar la primera fase del
gestor de arranque para poder ver la nueva geometr&iacute;a (y
reescribir el bloque de arranque de acuerdo con ella).<br>
En el ejemplo se asume que su disco de arranque es sd0 (SCSI, pero si
fuera IDE ser&iacute;a wd0, etc... ):

<pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre>

<p>
Si installboot protesta porque es incapaz de leer la geometr&iacute;a de
la BIOS, puede invocar la orden 'machine diskinfo' (o su forma
abreviada, 'ma di') desde el punto <kbd>boot&gt;</kbd>, para ver la
informaci&oacute;n que necesite.  Rellene con los valores
&quot;heads&quot; y &quot;secs&quot; los indicadores <code>-h</code> y
<code>-s</code> de installboot respectivamente, para que la orden
modificada de installboot quede como sigue:

<pre>
#<b> cd /usr/mdec; ./installboot -h &lt;heads&gt; -s &lt;secs&gt; /boot biosboot sd0</b>
</pre>

<p>
Si se requiriera una versi&oacute;n de los bloques de arranque,
tendr&iacute;a que compilarlos usted mismo.

<pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (o cualquier otro
dispositivo que sea su disco)
</pre>

<a name="Backup"></a>
<h2>14.9 - Prepararaci&oacute;n para el desastre: hacer copias de
seguridad (respaldo) y restaurar desde la cinta</h2>

<p>
<h3>Introducci&oacute;n:</h3>

<p>
Si su instalaci&oacute;n de OpenBSD va a ser lo que se llama un servidor
de producci&oacute;n, es aconsejable disponer de alg&uacute;n tipo de
respaldo por si acaso uno de sus discos fijos fallara.

<p>
Esta informaci&oacute;n le ayudar&aacute; a usar las utilidades
t&iacute;picas
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
disponibles con OpenBSD.  Existe una utilidad para copias de seguridad
m&aacute;s avanzada, llamada &quot;Amanda&quot;, con la que se pueden
hacer copias de seguridad de m&uacute;ltiples servidores en una sola
cinta.  En la mayor&iacute;a de entornos,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
es suficiente.  Sin embargo, si necesita hacer copias de seguridad de
m&uacute;ltiples m&aacute;quinas en una sola cinta, vale la pena que
conozca Amanda.

<p>
Los dispositivos de ejemplo en este documento son para una
configuraci&oacute;n que usa discos y cintas SCSI.  En un entorno de
producci&oacute;n, se recomiendan los discos SCSI sobre los IDE debido
al modo que gestionan los bloques err&oacute;neos, lo que no significa
que esta informaci&oacute;n sea in&uacute;til si est&aacute; usando un
disco IDE u otro tipo de cinta;  en este caso los nombres de sus
dispositivos ser&aacute;n ligeramente diferentes.  Por ejemplo, sd0a
ser&iacute;a wd0a en un sistema basado en IDE.

<p>
<h3>Hacer copias en cinta</h3>

<p>
Para hacer copias en una cinta es necesario saber de antemano
d&oacute;nde est&aacute;n montados los sistemas de archivos.  Esto se
puede determinar usando la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
desde el punto de pedido del int&eacute;rprete de &oacute;rdenes
(<i>shell prompt</i>).  Deber&iacute;a obtener una salida similar a
&eacute;sta:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</pre>

<p>
En este ejemplo, el sistema de archivos ra&iacute;z (/) reside
f&iacute;sicamente en sd0a, lo que indica que es la partici&oacute;n a
del disco fijo SCSI 0.  El sistema de archivos /usr reside en sd0h, lo
que indica que es la partici&oacute;n h del disco fijo SCSI 0.

<p>
Otro ejemplo de una tabla de puntos de montaje m&aacute;s avanzado
ser&iacute;a:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</pre>

<p>
En este ejemplo, el sistema de archivos ra&iacute;z reside
f&iacute;sicamente en sd0a, el sistema de archivos <i>/var</i> reside en
sd0d, el sistema de archivos <i>/home</i> en sd0e y finalmente,
<i>/usr</i> en sd0h.

<p>
Para hacer copias de seguridad de su m&aacute;quina necesitar&aacute;
pasar informaci&oacute;n a dump sobre el nombre de cada partici&oacute;n
del disco fijo.  Aqu&iacute; tiene un ejemplo de las &oacute;rdenes que
se necesitan para hacer copias de la primera tabla de montaje (la
m&aacute;s simple):

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind</b>
</pre>

<p>
Para la segunda tabla (la m&aacute;s avanzada), usar&iacute;a algo
parecido a esto:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind</b>
</pre>

<p>
Puede revisar la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">
dump(8)</a> para averiguar qu&eacute; es lo que hace exactamente cada
uno de los par&aacute;metros en la l&iacute;nea de &oacute;rdenes.
Aqu&iacute; tiene una breve descripci&oacute;n de los par&aacute;metros
usados:

<ul>
<li><b>0</b> - Lleva a cabo un nivel 0 de dump, lo coge todo.
<li><b>a</b> - Intenta determinar autom&aacute;ticamente el
tama&ntilde;o de la cinta.
<li><b>u</b> - Actualiza el fichero <i>/etc/dumpdates</i> para indicar
cu&aacute;ndo se realiz&oacute; la &uacute;ltima copia de seguridad.
<li><b>f</b> - Indica qu&eacute; dispositivo de cinta se usar&aacute;
(en este caso <i>/dev/nrst0</i>).
</ul>

<p>
La &uacute;ltima parte indica la partici&oacute;n de la que se
har&aacute; la copia de seguridad (<i>/dev/rsd0a</i>, etc... ).

<p>
La orden <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
se usa al final para rebobinar el controlador.  Revise la p&aacute;gina
del manual de mt para ver m&aacute;s opciones (como &quot;eject&quot;).

<p>
Si no est&aacute; seguro de cu&aacute;l es el nombre de su dispositivo
de cinta, use dmesg para localizarlo.  Un ejemplo de entrada del
dispositivo de cinta en dmesg ser&aacute; parecido al siguiente:

<pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre>

<p>
Es posible que haya notado que al realizar la copia de seguridad, se
accede al controlador de la cinta con el nombre del dispositivo
&quot;nrst0&quot; en lugar de &quot;st0&quot;, que es el nombre que se
ve en dmesg.  Cuando se accede a st0 como nrst0 se est&aacute;
accediendo al mismo controlador f&iacute;sico de la cinta, pero
indicando al controlador que no debe rebobinar al final del proceso y
que acceda al dispositivo en modo virgen.  Para hacer copias de
seguridad de m&uacute;ltiples sistemas de archivos en una sola cinta,
aseg&uacute;rese de usar el dispositivo sin rebobinar;  si usa un
dispositivo de rebobinado (rst0) para hacer copias de seguridad de
m&uacute;ltiples sistemas de archivos, acabar&aacute; anulando el
sistema de archivos anterior cuando el pr&oacute;ximo dump intente
grabar en la cinta.  Puede encontrar una descripci&oacute;n m&aacute;s
elaborada sobre los distintos dispositivos de control de cinta en la
p&aacute;gina del manual de dump.

<p>
Si quiere escribir un peque&ntilde;o gui&oacute;n (<i>script</i>), puede
hacerlo como el siguiente:

<pre>
echo &quot;  Empezando Copia de Seguridad Completa...&quot;
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n &quot;  Rebobinando el Dispositivo, por favor espere...&quot;
mt -f /dev/rst0 rewind
echo &quot;Fin.&quot;
echo                      
</pre>

<p>
Si desea programar las copias de seguridad para que se hagan por la
noche o a cualquier otra hora, puede usar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">
cron(8)</a> para que lance el gui&oacute;n de forma autom&aacute;tica.

<p>
Tambi&eacute;n puede serle de ayuda documentar (en un trozo de papel) el
tama&ntilde;o necesario para cada sistema de archivos.  Puede usar la
orden <kbd>df -h</kbd> para determinar cu&aacute;nto espacio est&aacute;
usando cada partici&oacute;n.  Esto le ser&aacute; &uacute;til cuando el
dispositivo falle y necesite recrear su partici&oacute;n en el nuevo
dispositivo.

<p>
Restaurar sus datos tambi&eacute;n le ayudar&aacute; a reducir la
fragmentaci&oacute;n.  Para asegurarse de que tiene todos los ficheros,
la mejor forma de hacer copias de seguridad es reiniciando el sistema en
modo monousuario.  Los sistemas de archivos no necesitan estar montados
para hacer las copias.  Despu&eacute;s de reiniciar no se olvide de
montar la partici&oacute;n ra&iacute;z (/) con permisos de escritura (r)
y lectura (w), o dump fallar&aacute; cuando intente grabar los
&quot;dumpdates&quot;.  Para iniciar en modo monousuario haga lo
siguiente desde el punto de arranque:

<pre>
boot&gt; bsd -s
</pre>

<p>
<h3>Ver el contenido de una copia en cinta:</h3>

<p>
Despu&eacute;s de que haya hecho las correspondientes copias de
seguridad por primera vez, es una buena idea que pruebe su cinta y que
se asegure de que los datos en ella sean los que Vd. esperaba que
fueran.

<p>
Puede usar el siguiente ejemplo para revisar un cat&aacute;logo de
ficheros en una cinta:

<pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre>

<p>
Esto har&aacute; que se muestre una lista con los ficheros existentes en
la primera partici&oacute;n de la cinta.  De acuerdo con los ejemplos
anteriores, 1 ser&iacute;a su sistema de archivos ra&iacute;z
(<i><b>/</b></i>).

<p>
Para poder ver el contenido de la segunda partici&oacute;n de la cinta y
enviar la salida a un fichero, use una orden como la siguiente:

<pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre>

<p>
Si tiene una tabla de particiones como la simple de ejemplos anteriores,
2 ser&iacute;a <i>/usr</i>;  si la tabla es como la m&aacute;s avanzada,
entonces 2 podr&iacute;a ser <i>/var</i> u otro sistema de archivos.  El
n&uacute;mero de secuencia coincide con el orden en el que se graben los
sistemas de archivos en la cinta.

<p>
<h3>Restaurar desde la cinta:</h3>

<p>
El ejemplo que ver&aacute; m&aacute;s adelante podr&iacute;a ser
&uacute;til si su disco fijo fallara totalmente.  En caso de que quiera
restaurar sus sistemas de archivos desde un &uacute;nico fichero de la
cinta, revise la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
y preste atenci&oacute;n a las instrucciones sobre el modo interactivo.

<p>
Si se ha preparado bien, substituir un disco y restaurar sus datos desde
la cinta puede ser un proceso muy r&aacute;pido.  El disquete de
instalaci&oacute;n/arranque est&aacute;ndar de OpenBSD contiene la
utilidad que se requiere para restaurar, as&iacute; como los binarios
que se requieren para particionar y hacer que pueda arrancar desde su
dispositivo.  En la mayor&iacute;a de los casos, este disquete y su
cinta con la copia de seguridad m&aacute;s reciente ser&aacute; todo lo
que necesite para restaurar el sistema.

<p>
Despu&eacute;s de substituir f&iacute;sicamente el dispositivo de disco
err&oacute;neo, los pasos b&aacute;sicos para restaurar sus datos son
los siguientes:

<ul>
<li>
Inicie desde el disquete de instalaci&oacute;n/arranque de OpenBSD.
Desde el men&uacute; de selecci&oacute;n, escoja Shell.
Prot&eacute;jalo contra la escritura e introduzca su cinta de la copia
de seguridad m&aacute;s reciente en el dispositivo.

<li>
Use la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
para crear una partici&oacute;n primaria de OpenBSD en el nuevo
dispostivo.  Por ejemplo:

<pre>
# <b>fdisk -e sd0</b>
</pre>

<p>
Revise la <a href="#fdisk">secci&oacute;n 14.2</a> sobre fdisk para
m&aacute;s informaci&oacute;n.

<li>
Use la orden 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
para recrear su tabla de particiones de OpenBSD dentro de la
partici&oacute;n primaria de OpenBSD que acaba de crear con fdisk.  Por
ejemplo:

<pre>
# <b>disklabel -E sd0</b>
</pre>

<p>
No se olvide de la partici&oacute;n de <i>swap</i>.  Revise la
<a href="#disklabel">secci&oacute;n 14.1</a> sobre disklabel para
m&aacute;s informaci&oacute;n.

<li>
Use la orden 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
en cada una de las particiones que acaba de crear, para construir un
sistema de archivos limpio en cada una de ellas.  Por ejemplo:

<pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre>

<li>
Monte su reci&eacute;n preparado sistema de archivos ra&iacute;z (/) en
/mnt.  Por ejemplo:

<pre>
# <b>mount /dev/sd0a /mnt</b>
</pre>

<li>
Cambie a ese sistema de archivos ra&iacute;z que acaba de montar y
comience con el proceso de restauraci&oacute;n.  Por ejemplo:

<pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre>

<li>
Como querr&aacute; poder arrancar desde este nuevo disco, haga lo
siguiente para grabar un nuevo MBR en su dispositivo:

<pre>
# <b>fdisk -i sd0</b>
</pre>

<li>
Adem&aacute;s de grabar un nuevo MBR en el controlador,
necesitar&aacute; instalar bloques de arranque para iniciar desde
&eacute;l.  A continuaci&oacute;n puede ver un breve ejemplo:

<pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre>

<li>
Su nuevo sistema de archivos ra&iacute;z en el disco fijo deber&iacute;a
estar lo suficientemente preparado como para que pueda iniciar desde
&eacute;l y continuar restaurando el resto de sus sistemas de archivos.
Como su sistema operativo todav&iacute;a no est&aacute; completo,
aseg&uacute;rese de iniciar la copia de seguridad en modo monousuario.
Desde el punto de pedido de la shell, ejecute las siguientes
&oacute;rdenes para desmontar y parar el sistema:

<pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre>

<li>
Elimine el disquete de instalaci&oacute;n/arranque del dispositivo y
reinicie el sistema.  Desde el punto de arranque de OpenBSD
<kbd>boot&gt;</kbd>, ejecute la siguiente orden:

<pre>
boot&gt; <b>bsd -s</b>
</pre>

<p>
La orden <kbd>bsd -s</kbd> har&aacute; que el n&uacute;cleo del sistema
inicie en modo monousuario, por lo que s&oacute;lo necesitar&aacute; el
sistema de archivos ra&iacute;z (<i><b>/</b></i>).

<li>
Asumiendo que ha llevado a cabo todos los pasos anteriores correctamente
y que no ha cometido ning&uacute;n error, deber&iacute;a acabar viendo
un punto en el que le pedir&aacute; que introduzca un camino para la
shell o que pulse la tecla <kbd>intro</kbd>.  Pulse
<kbd>&lt;intro&gt;</kbd> si va a usar sh.  A continuaci&oacute;n
tendr&aacute; que volver a montar el sistema de archivos ra&iacute;z en
modo de lectura (r) y escritura (w), al contrario que en modo de
s&oacute;lo lectura como hasta ahora.  Ejecute la siguiente orden:

<pre>
# <b>mount -u -w /</b>
</pre>

<li>
Una vez que lo haya vuelto a montar en modo de lectura y escritura,
puede continuar restaurando sus otros sistemas de archivos.  Por
ejemplo:

<pre>
(tabla de particiones simple)
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(tabla de particiones m&aacute;s avanzada)
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre>

<p>
Puede usar &quot;<kbd>restore rvsf</kbd>&quot; en lugar de usar
s&oacute;lo &quot;<kbd>rsf</kbd>&quot;, para ver lo nombres de los
objetos mientras los extrae de la copia de seguridad.

<li>
Por &uacute;ltimo, despu&eacute;s de que acabe de restaurar el resto de
sistemas de archivos al disco, reinicie en modo multiusuario.  Si todo
ha salido como lo ha planeado, su sistema volver&aacute; al estado en el
que se encontraba cuando realiz&oacute; la copia de seguridad, y
volver&aacute; a estar preparado para su uso.
</ul>

<a name="MountImage"></a>
<h2>14.10 - C&oacute;mo montar im&aacute;genes de disco en OpenBSD</h2>

<p>
Para montar una imagen de disco (im&aacute;genes ISO, im&aacute;genes de
disco creadas con ´dd´, etc.. ) en OpenBSD, debe configurar un
dispositivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">
vnd(4)</a>.  Por ejemplo, si tuviera una imagen ISO ubicada en
<i>/tmp/ISO.image</i>, deber&iacute;a seguir los siguientes pasos para
montar la imagen:

<table border="0" width="650">
        <tr>
                <td nowrap bgcolor="#eeeeee">
<pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre>
                </td>
        </tr>
</table>

<p>
Note que, dado que esta imagen es una imagen de CD, debe especificar el
tipo <i>cd9660</i> al montarla.  Esto se debe aplicar a cualquier tipo;
v.g. deber&aacute; usar el tipo <i>ffs</i> cuando monte im&aacute;genes
de disco.

<p>
Para desmontar la imagen use la siguiente orden:

<table border="0" width="650">
        <tr>
                <td nowrap bgcolor="#eeeeee">
<pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre>
                </td>
        </tr>
</table>

<p>
Para m&aacute;s informaci&oacute;n mire la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>

<a name="pciideErr"></a>
<h2>14.11 - &iexcl;Ayuda! &iexcl;da errores con PCIIDE!</h2>

<p>
PCI IDE DMA es inestable en muchas combinaciones de <i>hardware</i>.
Hasta hace poco tiempo, la mayor&iacute;a de sistemas operativos
&laquo;m&aacute;s conocidos&raquo; que aseguraban dar soporte para
transferencias DMA con dispositivos IDE, no ten&iacute;an esa
funcionalidad activada de modo predeterminado.

<p>
OpenBSD es agresivo, e intenta usar el modo DMA m&aacute;s alto que
pueda configurar.  Esto corrompe las transferencias de datos en algunas
configuraciones, por culpa de placas base con <i>chipsets</i>
err&oacute;neos, controladoras err&oacute;neas y, o, ruido en los
cables.  Por suerte, los modos Ultra-DMA protegen las transferencias de
datos con un CRC para detectar la corrupci&oacute;n.  Cuando el CRC
Ultra-DMA falla, OpenBSD muestra un mensaje de error e intenta repetir
la operaci&oacute;n.

<pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre>

<p>
Despu&eacute;s de un par de fallos, OpenBSD prueba un modo Ultra-DMA
m&aacute;s bajo, pero m&aacute;s estable.  Si se llega al modo 0
Ultra-DMA, el controlador baja de grado hasta el modo PIO.

<p>
Si OpenBSD no consigue bajar el modo, o si el proceso bloquea la
m&aacute;quina, por favor env&iacute;e un
<a href="../../es/report.html">informe sobre el error</a>.


<a name="RAID"></a>
<h2>14.13 - Opciones de RAID para OpenBSD</h2>

<p>
RAID (<i>Redundant Array of Inexpensive Disks</i>) ofrece la oportunidad
de usar dispositivos m&uacute;ltiples para obtener un mejor rendimiento,
m&aacute;s capacidad, y/o redundancia de la que se puede obtener de un
&uacute;nico dispositivo.  Aunque una explicaci&oacute;n completa de los
beneficios y riesgos de RAID no entra en los objetivos de esta
secci&oacute;n, hay un par de puntos que son importantes aqu&iacute;:

<ul>
<li>RAID no tiene nada que ver con las copias de seguridad.
<li>Por s&iacute; solo, RAID no elimina el tiempo de ca&iacute;das.
</ul>

<p>
Si es la primera vez que lee informaci&oacute;n sobre RAID, tenga en
cuenta que esto no es un buen comienzo para explorar RAID.

<h3>Opciones de <i>software</i></h3>

<p>
OpenBSD incluye <i>RAIDframe</i>, una soluci&oacute;n de software de
RAID.  Puede encontrar documentaci&oacute;n sobre <i>RAIDframe</i> en
los siguientes sitios:

<ul>
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">Sitio principal de
RAIDframe</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">p&aacute;gina del manual de raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">p&aacute;gina del manual de raid(4)</a>
</ul>

<p>
<!-- XXXexpires - paragraph need rewriting when 3.1 becomes unsupported -->
Desde la versi&oacute;n 3.1 de OpenBSD, se puede replicar la
partici&oacute;n ra&iacute;z directamente usando la opci&oacute;n
&quot;<tt>Autoconfiguration</tt>&quot; de <i>RAIDframe</i>.

<h3>Opciones de <i>hardware</i></h3>

<p>
Muchas <a href="../../es/plat.html">plataformas</a> de OpenBSD incluyen
soporte para varios productos de <i>hardware</i> de RAID.  Las opciones
var&iacute;an seg&uacute;n la plataforma; mire en la p&aacute;gina de
soporte apropiada para cada una
<a href="../../es/plat.html">aqu&iacute;</a>.

<p>
Otra opci&oacute;n disponible para muchas plataformas es la de los
muchos productos que hacen que dispositivos m&uacute;ltiples
act&uacute;en como un &uacute;nico dispositivo IDE o SCSI, y
est&aacute;n conectados en un adaptador IDE o SCSI normal.  Estos
dispositivos pueden funcionar en casi cualquier plataforma de
<i>hardware</i> que disponga de soporte para SCSI o IDE.

<p>
Algunos de los fabricantes de estos productos:

<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>

<p>
(Nota:  &eacute;stos son simplemente productos sobre los que los
usuarios de OpenBSD han informado que utilizan, no es ning&uacute;n tipo
de recomendaci&oacute;n ni es una lista exhaustiva).

<h3>No-opciones</h3>

<p>
Una pregunta formulada a menudo en las
<a href="../../es/mail.html">listas de correo</a> es si &laquo;hay
soporte para las controladoras de IDE RAID Promise o HighPoint&raquo;, y
la respuesta es &laquo;No&raquo;.  Estas tarjetas y <i>chips</i> no son
controladores de <i>hardware</i> de RAID reales, sino <i>software</i> de
RAID de arranque asistido por la BIOS.  Como OpenBSD ya dispone de
soporte para <i>software</i> de RAID independiente del <i>hardware</i>,
no hay un deseo entre los desarrolladores de OpenBSD la
implementaci&oacute;n de un soporte especial para estas tarjetas.

<p>
<font color="#0000e0">
<a href="index.html">[&Iacute;ndice de documentos]</a>
<a href="faq12.html">[Secci&oacute;n 12 - Cuestiones sobre plataformas
espec&iacute;ficas]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[&iacute;ndice]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq14.html,v 1.99 ]<br>
$Translation: faq14.html,v 1.55 2009/06/29 18:34:05 ajacoutot Exp $<br>
-->
$OpenBSD: faq14.html,v 1.53 2009/06/29 17:19:48 ajacoutot Exp $
</small>
</body>
</html>

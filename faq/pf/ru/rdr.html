<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Traffic Redirection (Port Forwarding)</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003, Nick Holland <nick@openbsd.org>
Copyright (c) 2003-2005, Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../ru/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="nat.html">Предыдущая: Преобразование Сетевых Адресов</a>]
[<a href="index.html">Содержание</a>]
[<a href="shortcuts.html">Следующая: Сокращения для написания правил</a>]

<h1><font color="#e00000">PF: Перенаправление (Проброс портов)</font></h1>

<hr>

<h3>Table of Contents</h3>
<ul>
<li><a href="#intro">Вступление</a>
<li><a href="#filter">Перенаправление и Фильтрация пакетов</a>
<li><a href="#security">Безопасность</a>
<li><a href="#reflect">Перенаправление и Отражение</a>
	<ul>
	<li><a href="#splitdns">Локальный DNS</a>
	<li><a href="#sepnet">Перемещение Сервера в Отдельную Локальную
	Сеть</a>
	<li><a href="#tcpproxy">TCP Проксирование</a>
	<li><a href="#rdrnat">Комбинация RDR и NAT</a>
	</ul>
</ul>

<hr>

<a name="intro"></a>
<h2>Вступление</h2>
Если у вас есть работающий NAT в вашем офисе, то вы имеете выход в Интернет
на всех машинах. Что если у вас есть машина позади NAT шлюза, которая
должна быть доступна из вне? Вот где вступает в работу перенаправление.
Перенаправление позволяет входящему трафику быть посланным машине находящейся
позади NAT шлюза.

<p>
Давайте рассмотрим пример:
<blockquote>
<tt>
rdr on tl0 proto tcp from any to any port 80 -&gt; 192.168.1.20
</tt>
</blockquote>

<p>
Эта строка перенаправляет трафик входящий на 80 TCP порт (веб сервер) на
машину внутри сети с ip 192.168.1.20. Поэтому, даже несмотря на то, что
192.168.1.20 находится за шлюзом и внутри вашей сети, внешний мир может
иметь к этой машине доступ.

<p>
Часть правила <tt>from any to any</tt> может быть
весьма полезна. Если вы знаете какой адрес или подсеть
должны иметь доступ к веб серверу на 80 порт, то вы можете это указать:
<blockquote>
<tt>
rdr on tl0 proto tcp from 27.146.49.0/24 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20
</tt>
</blockquote>

<p>
Это будет перенаправлять только указанную подсеть. Обратите внимание, 
это означает, что вы можете перенаправлять определённые входящие хосты
на определённые машины находящиеся за натом. Это может оказаться полезным.
Например, вы можете давать удалённым пользователями доступ на их 
собственные рабочие компьютеры, если вы знаете кто с какого IP адреса
будет соединяться:
<blockquote>
<tt>
rdr on tl0 proto tcp from 27.146.49.14 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20<br>
rdr on tl0 proto tcp from 16.114.4.89 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.22<br>
rdr on tl0 proto tcp from 24.2.74.178 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.23
</tt>
</blockquote>

<p>
Диапазон портов также может быть перенаправлен:
<blockquote>
<tt>
rdr on tl0 proto tcp from any to any port 5000:5500 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20<br>
rdr on tl0 proto tcp from any to any port 5000:5500 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20 port 6000<br>
rdr on tl0 proto tcp from any to any port 5000:5500 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20 port 7000:*<br>
</tt>
</blockquote>

<p>
Эти примеры показывают перенаправление портов от 5000 до 5500 включительно,
на машину 192.168.1.20.
В правиле #1 порт 5000 перенаправляется на 5000, 5001 на 5001, и т.д.
В правиле #2 указанный диапазон портов перенаправляется на 6000 порт.
И в правиле #3 порт 5000 перенаправляется на 7000, 5001 на 7001, и т.д.

<a name="filter"></a>
<h2>Перенаправление и Фильтрация Пакетов</h2>
<font color="#ff0000">Обратите внимание:</font> Преобразованные пакеты проходят
через фильтр и будут блокированы или пропущены, в зависимости от правил
фильтрации.

<p>
<i>Единственное</i> исключение для этого правила это когда ключевое слово <tt>pass</tt>
используется с <tt>rdr</tt> правилом. В этом случае перенаправленные
пакеты будут пропущены сквозь работу фильтра:
эти пакеты не будут оцениваться правилами фильтрации. Это сокращённый
путь добавления фильтрующего правила <tt>pass</tt> для каждого правила
перенаправления. Воспринимайте это как обыкновенное <tt>rdr</tt> правило
(без ключевого слова <tt>pass</tt>) объединённое с фильтрующим правилом <tt>pass</tt>,
с ключевым слово <tt>keep state</tt>.
Однако, если вы хотите использовать более специфичные фильтрующие опции, 
такие, как <tt>synproxy</tt>, <tt>modulate state</tt>, и т.д. то вам необходимо
отдельно использовать <tt>pass</tt> правило, потому что эти опции не работают
в правилах перенаправления.

<p>
Также помните, что трансляция происходит <i>до</i> фильтрации, фильтр
будет видеть уже транслированные пакеты с преобразованным ip адресом и портом,
указанными в <tt>rdr</tt> правилах.
Рассмотрим такой сценарий:

<ul>
<li>192.0.2.1 - хост в Интернет.
<li>24.65.1.13 - внешний адрес OpenBSD роутера.
<li>192.168.1.5 - внутренний адрес веб сервера.
</ul>

<p>
Перенаправляющее правило:
<blockquote>
<tt>
rdr on tl0 proto tcp from 192.0.2.1 to 24.65.1.13 port 80 \<br>
&nbsp;&nbsp;&nbsp;-&gt; 192.168.1.5 port 8000
</tt>
</blockquote>

<p>
Пакет до обработки <tt>rdr</tt> правилом:
<ul>
<li>Исходный адрес: 192.0.2.1
<li>Исходный порт: 4028
<li>Адрес назначения: 24.65.1.13
<li>Порт назначения: 80
</ul>

<p>
Пакет после обработки <tt>rdr</tt> правилом:
<ul>
<li>Исходный адрес: 192.0.2.1
<li>Исходный порт: 4028
<li>Адрес назначения: 192.168.1.5
<li>Порт назначения: 8000
</ul>

<p>
Фильтр увидит пакет в том виде, в котором он представлен после трансляции.

<a name="security"></a>
<h2>Безопасность</h2>
Перенаправление имеет проблемы с безопасностью. Появляется уязвимость
в брандмауэре позволяющая пропустить трафик во внутреннюю защищённую сеть.
Если трафик перенаправляется к примеру на внутренний веб сервер и злоумышленник
обнаруживает уязвимость в веб сервере или в CGI скрипте запущенном на веб
сервере, тогда машина может быть использована злоумышленником. И теперь
злоумышленник имеет окно во внутреннюю сеть, позволяющее ему проходить сквозь
брандмауэр.

<p>
Подобные риски могут быть минимизированы, если держать систему к которой имеется
доступ из вне в сильно ограниченной сети. Эту сеть часто зовут Демилитаризованной
Зоной (DMZ) или Приватная Сервисная Сеть (PSN). Таким образом, если веб сервер 
взломан, последствия могут быть ограничены DMZ/PSN сетью, где фильтруется
доступ в и из неё.

<a name="reflect"></a>
<h2>Перенаправление и Отражение</h2>
Часто правила перенаправления используют для проброса входящих соединений
из Интернета на локальный сервер с внутренним адресом в локальной сети,
такой как:
<blockquote>
<tt>
server = 192.168.1.40<br>
<br>
rdr on $ext_if proto tcp from any to $ext_if port 80 -&gt; $server \<br>
&nbsp;&nbsp;&nbsp;port 80
</tt>
</blockquote>

<p>
Но когда правила перенаправления проверяются клиентом из LAN сети,
это не работает. Причина в том, что правила перенаправления применяются
только для пакетов, которые проходят через указанный интерфейс(<tt>$ext_if</tt>, 
внешний интерфейс в примере). 
Соединение на внешний адрес брандмауэра от хоста в локальной сети не 
означает, что пакет пойдёт через внешний интерфейс. TCP/IP стэк на брандмауэре
сравнивает адрес назначения входящих пакетов со своими собственными адресами
и алиасами и определяет подключение к самому себе, после того, как пакеты
прошли внутренний интерфейс. Такие пакеты физически не проходят через внешний
интерфейс, и стэк не симулирует такой проход. Таким образом, PF никогда
не видит эти пакеты на внешнем интерфейсе, и правило перенаправления указанное
на внешнем интерфейсе не применяется.

<p>
Добавление второго правила перенаправления на внутреннем интерфейсе не 
даст желаемого результата. Когда локальный клиент соединяется на внешний 
интерфейсе брандмауэра, инициализационный пакет TCP рукопожатия достигает
брандмауэр через внутренний интерфейс. Правила перенаправления сработает,
адрес назначения поменяется на адрес внутреннего сервера.
Пакет будет переброшен обратно через внутренний интерфейс и достигнет
внутреннего сервера. Но исходный адрес не будет преобразован и всё ещё будет
содержать адрес локального клиент, поэтому отправит ответ напрямую клиенту,
брандмауэр никогда не увидит ответ и не сможет правильно выполнить обратное
преобразование. Клиент принимает ответ от не предполагаемого источника и 
отбрасывает его. TCP рукопожатие не состоится и соединение не установится.

<p>
Всё же часто необходимо для клиентов в локальной сети соединяться
на внутренний сервер, как внешние клиенты и делать это прозрачно.
Существует несколько решений этой проблемы:

<a name="splitdns"></a>
<h3>Локальный DNS</h3>

<p>
Возможно настроить DNS сервер так, чтобы ответ на запросы от локальных хостов
отличался от ответа на внешние запросы, таким образом локальные клиенты
будут принимать внутренний адрес сервера. Тогда они будут соединяться на прямую
к локальному сервер, и брандмауэр не запутается во всём этом. Подобный метод
снижает локальный трафик, потому что пакеты не будут посылаться через
брандмауэр.

<a name="sepnet"></a>
<h3>Перемещение Сервера в Отдельную Локальную Сеть</h3>

<p>
Добавление дополнительного сетевого интерфейсе на брандмауэр и перемещение
локального сервера из клиентской сети в специальную сеть (DMZ), позволяющую
перенаправление соединений от локальных клиентов, так же как перенаправление
внешних соединений. Использование отдельных сетей имеет несколько преимуществ,
включая улучшенную безопасность путём изоляции сервера от остающихся
локальных хостов. Если сервер (который в нашем случае доступен из Интернета)
будет взломан, он не сможет получить доступ к другим локальным хостам напрямую,
потому как все соединения проходят через брандмауэр.

<a name="tcpproxy"></a>
<h3>TCP Проксирование</h3>

<p>
Может быть установлено TCP проксирование на брандмауэре,
принимать соединения на внутреннем интерфейсе и перенаправлять на прослушиваемый
проксируемый порт. Когда локальный клиент соединяется
на брандмауэр, прокси принимает соединение, устанавливает второе соединение
с внутренним сервером и передаёт данные между этими двумя соединениями.

<p>
Примитивное проксирование может быть организовано с помощью
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8"
>inetd(8)</a> и
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nc&amp;sektion=1"
>nc(1)</a>. Указанная запись в <tt>/etc/inetd.conf</tt> создаст прослушиваемый 
сокет прикреплённый к кольцевому адресу (127.0.0.1) и 5000 порту.
Соединения передаются на 80 порт, на сервер 192.168.1.10.
<blockquote>
<tt>
127.0.0.1:5000 stream tcp nowait nobody /usr/bin/nc nc -w \<br>
&nbsp;&nbsp;&nbsp;20 192.168.1.10 80
</tt>
</blockquote>

<p>
Указанное перенаправляющее правило пробрасывает 80 порт на внутренний 
интерфейс к прокси:
<blockquote>
<tt>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;127.0.0.1 port 5000
</tt>
</blockquote>

<a name="rdrnat"></a>
<h3>Комбинация RDR и NAT</h3>

<p>
С добавлением NAT правила на внутреннем интерфейсе преобразование
исходного адреса описанное выше будет достигнуто.
<blockquote>
<tt>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;$server
<br>
no nat on $int_if proto tcp from $int_if to $int_net<br>
nat on $int_if proto tcp from $int_net to $server port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;$int_if
</tt>
</blockquote>

<p>
Инициализационный пакет от клиента будет снова преобразован,
когда будет пробрасываться обратно через внутренний интерфейс, 
замена клиентского исходного адреса на внутренний адрес брандмауэра.
Внутренний сервер будет отвечать обратно брандмауэру, который может 
сделать обратно NAT и RDR преобразования, когда пробрасывается
локальному клиенту. Эта конструкция сложный комплекс, потому что
он создаёт два отдельных стейта для каждого отражённого соединения.
Необходимо принять меры для предотвращения работы NAT с другим трафиком,
например соединения из внешних хостов (через другие перенаправления) или
трафик самого брандмауэра. Обратите внимание, что <tt>rdr</tt> правило
показанное выше заставляет TCP/IP стэк просматривать пакеты прибывающие
на внутренний интерфейс с адресом назначения во внутреннию сеть.

<p>
Лучше использовать ранее упомянутое решение, взамен этого.

<p>
[<a href="nat.html">Предыдущая: Преобразование Сетевых Адресов</a>]
[<a href="index.html">Содержвание</a>]
[<a href="shortcuts.html">Следующая:  Сокращения для написания правил</a>]

<p>
<hr>
<a href="../../pf/ru/index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: rdr.html,v 1.27 ]<br>
$Translation: rdr.html,v 1.4 2009/08/01 21:47:52 tobias Exp $<br>  
-->
$OpenBSD: rdr.html,v 1.4 2009/08/01 21:41:39 tobias Exp $
</small>

</body>
</html> 

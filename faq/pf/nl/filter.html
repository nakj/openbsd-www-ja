<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Pakketten Filteren</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2007 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../nl/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="tables.html">Vorige: Tabellen</a>]
[<a href="index.html">Inhoud</a>]
[<a href="nat.html">Volgende: Network Address Translation</a>]

<h1><font color="#e00000">PF: Pakketten Filteren</font></h1>

<hr>

<h3>Inhoudsopgave</h3>
<ul>
<li><a href="#intro">Inleiding</a>
<li><a href="#syntax">Regelsyntaxis</a>
<li><a href="#defdeny">Standaard Weigeren</a>
<li><a href="#pass">Verkeer Doorlaten</a>
<li><a href="#quick">Het <tt>quick</tt> Sleutelwoord</a>
<li><a href="#state">Toestand ("state") Bijhouden</a>
<li><a href="#udpstate">Toestand ("state") Bijhouden voor UDP</a>
<li><a href="#stateopts">"Stateful" Traceringsopties</a>
<li><a href="#tcpflags">TCP Vlaggen</a>
<li><a href="#synproxy">TCP SYN Proxy</a>
<li><a href="#antispoof">Gespoofte Pakketten Blokkeren</a>
<li><a href="#urpf">Unicast Reverse Path Forwarding</a>
<li><a href="#osfp">Passieve Besturingssysteem "Fingerprinting"</a>
<li><a href="#ipopts">IP Opties</a>
<li><a href="#example">Filterregelset Voorbeeld</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Inleiding</h2>
Pakketten filteren is het selectief doorlaten of blokkeren van
gegevenspakketten naarmate ze doorheen een netwerkinterface passeren.
De criteria die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.6"
>pf(4)</a> gebruikt bij het inspecteren van pakketten zijn gebaseerd op de
Layer 3 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a> en
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4"
>IPv6</a>) en Layer 4
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4"
>ICMP</a> en
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4"
>ICMPv6</a>) hoofdingen ("headers"). De vaakst gebruikte criteria zijn
bron- en bestemmingsadres, bron- en bestemmingspoort, en protocol.

<p>
Filterregels specificeren de criteria waaraan een pakket moet voldoen en de
resulterende actie, ofwel blokkeren ofwel passeren, die ondernomen wordt wanneer
een overeenstemming gevonden wordt. Filterregels worden in na elkaar komende
volgorde geëvalueerd, eerste tot laatste.
Tenzij het pakket overeenstemt met een regel die het <tt>quick</tt>
sleutelwoord bevat, zal het pakket geëvalueerd worden met <i>alle</i>
filterregels alvorens de uiteindelijke actie ondernomen wordt. De laatste
regel die overeenstemt is de "winnaar" en zal dicteren welke actie er
met het pakket ondernomen moet worden. Er is een impliciete
<tt>pass all</tt> bij het begin van een filterregelset, wat betekent dat
als een pakket met geen enkele filterregel overeenstemt, de resulterende
actie <tt>pass</tt> zal zijn.

<a name="syntax"></a>
<h2>Regelsyntaxis</h2>
De algemene, <i>erg vereenvoudigde</i> syntaxis voor filterregels is:
<blockquote>
<tt>
<i>actie</i> [<i>richting</i>] [log] [quick] [on <i>interface</i>] 
[<i>af</i>] [proto <i>protocol</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>src_addr</i> [port <i>src_port</i>]] [to 
<i>dst_addr</i> [port <i>dst_port</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>actie</i></tt>
<dd>De actie die moet ondernomen worden voor overeenstemmende pakketten, ofwel
<tt>pass</tt> ofwel <tt>block</tt>. De <tt>pass</tt> actie zal het pakket
terug naar de kernel sturen voor verdere verwerking terwijl de
<tt>block</tt> actie zal reageren op basis van de instelling van de
<a href="options.html#block-policy"><tt>block-policy</tt></a> optie. 
De standaard reactie kan opgeheven worden door ofwel <tt>block
drop</tt> ofwel <tt>block return</tt> te specificeren.

<dt><tt><i>richting</i></tt>
<dd>De richting waarin het pakket beweegt op een interface, ofwel
<tt>in</tt> ofwel <tt>out</tt>.

<dt><tt>log</tt>
<dd>Specificeert dat het pakket gelogd moet worden via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.6"
>pflogd(8)</a>. Als de regel een toestand creëert, dan
wordt alleen het pakket dat de toestand ("state") opricht gelogd.
Om toch alle pakketten te loggen, gebruikt u <tt>log (all)</tt>.

<dt><tt>quick</tt>
<dd>Als een pakket overeenstemt met een regel die <tt>quick</tt>
specificeert, dan wordt die regel als de laatste overeenstemmende regel
beschouwd en wordt de gespecificeerde <tt><i>actie</i></tt> ondernomen.

<dt><tt><i>interface</i></tt>
<dd>De naam of groep van de netwerkinterface waar het pakket doorheen
beweegt.
Interfaces kunnen toegevoegd worden aan willekeurige groepen met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> commando.
Verscheidene groepen worden ook automatisch aangemaakt door de kernel:
<ul>
<li>De <tt>egress</tt> groep, die de interface(s) bevat die de standaard
route(s) bevat.
<li>Interfacefamilie groep voor gekloonde interfaces.
Bijvoorbeeld: <tt>ppp</tt> of <tt>carp</tt>.
</ul>
Dit zou ervoor zorgen dat de regel overeenstemt met gelijk welk pakket dat
respectievelijk gelijk welke <tt>ppp</tt> of <tt>carp</tt> interface
doorkruist.

<dt><tt><i>af</i></tt>
<dd>De adresfamilie van het pakket, ofwel <tt>inet</tt> voor IPv4 ofwel
<tt>inet6</tt> voor IPv6. PF kan deze parameter gewoonlijk bepalen
op basis van het (de) bron- en/of bestemmingsadres(sen).

<dt><tt><i>protocol</i></tt>
<dd>Het Layer 4 protocol van het pakket:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Een geldige protocolnaam uit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5"
><tt>/etc/protocols</tt></a>
<li>Een protocolnummer tussen 0 en 255
<li>Een reeks protocols gebruik makend van een
<a href="macros.html#lists">lijst</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 
<dd>Het bron/bestemmingsadres in de IP header. Adressen kunnen
gespecificeerd worden als:
<ul>
<li>Een enkel IPv4 of IPv6 adres.
<li>Een <a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a> 
netwerkblok.
<li>Een "fully qualified domain name" die via DNS zal vertaald worden wanneer
de regelset geladen wordt. Alle resulterende IP adressen zullen
gesubstitueerd worden in de regel.
<li>De naam van een netwerkinterface of groep.
Gelijk welke IP adressen toegekend
aan de interface zullen gesubstitueerd worden in de regel.
<li>De naam van een netwerkinterface gevolgd door een
<tt>/<i>netmask</i></tt> (i.e., <tt>/24</tt>). Elk IP adres op de interface
wordt gecombineerd met het netmask om een CIDR netwerkblok te vormen dat
gesubstitueerd wordt in de regel.
<li>De naam van een netwerkinterface of groep tussen haakjes <tt>( )</tt>.
Dit vertelt PF om de regel te updaten als het (de) IP adres(sen) op de
genoemde interface verandert (veranderen).
Dit is nuttig op een interface die haar
IP adres via DHCP of dial-up verkrijgt aangezien de regelset niet hoeft
herladen te worden elke keer het adres verandert.
<li>De naam van een netwerkinterface gevolgd door gelijk welke van deze
modifiers: 
  <ul>
  <li><tt>:network</tt> - substitueert het CIDR netwerkblok (bv.
  192.168.0.0/24)
  <li><tt>:broadcast</tt> - substitueert het netwerk broadcast adres
  (bv. 192.168.0.255)
  <li><tt>:peer</tt> - substitueert het IP adres van de peer bij een
  punt-tot-punt verbinding
  </ul>
  <dl>
  <dd>Bijkomend kan de <tt>:0</tt> modifier aan ofwel een interfacenaam
  of aan gelijk welke van de bovenstaande modifiers vastgehangen worden
  om aan te geven dat PF geen ge-aliaste IP adressen in de substitutie
  moet opnemen.
  Deze modifiers kunnen ook gebruikt worden wanneer de interface tussen
  haakjes staat.
  Voorbeeld: <tt>fxp0:network:0</tt>
  </dl>
<li>Een <a href="tables.html">tabel</a>.
<li>Het sleutelwoord <tt>urpf-failed</tt> kan gebruikt worden voor het
bronadres om aan te geven dat het door de
<a href="#urpf">uRPF controle</a> moet.
<li>Gelijk wat van het bovenstaande maar ontkend met de <tt>!</tt> ("not")
modifier.
<li>Een reeks adressen gebruik makend van een
<a href="macros.html#lists">lijst</a>.
<li>Het sleutelwoord <tt>any</tt> dat alle adressen betekent
<li>Het sleutelwoord <tt>all</tt> dat een korte vorm is voor <tt>from any to
any</tt>.
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>De bron/destinatiepoort in de Layer 4 pakkethoofding. Poorten kunnen
gespecificeerd worden als:
<ul>
<li>Een getal tussen 1 en 65535
<li>Een geldige servicenaam uit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5"
><tt>/etc/services</tt></a>
<li>Een reeks poorten gebruik makend van een
<a href="macros.html#lists">lijst</a>
<li>Een bereik:
	<ul>
	<li><tt>!=</tt> (niet gelijk)
	<li><tt>&lt;</tt> (kleiner dan)
	<li><tt>&gt;</tt> (groter dan)
	<li><tt>&lt;=</tt> (kleiner dan of gelijk)
	<li><tt>&gt;=</tt> (groter dan of gelijk)
	<li><tt>&gt;&lt;</tt> (bereik)
	<li><tt>&lt;&gt;</tt> (tegengesteld bereik)
	<dl>
	<dd>De laatste twee zijn binaire operatoren (ze nemen twee argumenten)
        en bevatten de argumenten in het bereik niet.
	</dl>
	<li><tt>:</tt> (inclusief bereik)
	<dl>
	<dd>De inclusief bereik operator is ook een binaire operator en
        bevat de argumenten in het bereik niet.
	</dl>
	</ul>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd>Specificeert de vlaggen die ingesteld moeten zijn in de TCP header
bij gebruik van
<tt>proto tcp</tt>. Vlaggen worden gespecificeerd als
<tt>flags <i>check</i>/<i>mask</i></tt>. Bijvoorbeeld: <tt>flags
S/SA</tt> - dit draagt PF op om enkel naar de S en A (SYN and ACK)
vlaggen te kijken en overeenstemming te vinden als alleen de SYN vlag "aan"
staat.
Vanaf OpenBSD 4.1 worden de standaardvlaggen <tt>S/SA</tt> toegepast op
alle TCP filterregels.

<dt><tt><i>state</i></tt>
<dd>Specificeert of toestandsinformatie bijgehouden wordt voor pakketten die
overeenstemmen met deze regel.
<ul>
<li><tt>keep state</tt> - werkt met TCP, UDP en ICMP.
Vanaf OpenBSD 4.1 is deze optie de standaard voor alle filterregels.
<li><tt>modulate state</tt> - werkt alleen met TCP. PF zal
sterke Initial Sequence Numbers (ISNs) genereren voor pakketten die
overeenstemmen met deze regel.
<li><tt>synproxy state</tt> - binnenkomende TCP verbindingen worden door
de proxy behandeld om servers te helpen beschermen tegen gespoofte
TCP SYN floods.
Deze optie omvat de functionaliteit van <tt>keep state</tt> en
<tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Standaard Weigeren</h2>
Het aanbevolen gebruik bij het opzetten van een firewall is om voor een
"standaard weigeren" aanpak te kiezen. Dat betekent: <i>alles</i>
weigeren en vervolgens selectief bepaald verkeer doorheen de firewall
toelaten. Deze aanpak wordt aanbevolen omdat hij het zekere voor het
onzekere neemt en ook het schrijven van een regelset gemakkelijker maakt.

<p>
Om een standaard weigeren filterbeleid te creëren, zouden de eerste twee
filterregels de volgende moeten zijn:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Dit zal alle verkeer op alle interfaces in elke richting van gelijk waar
naar gelijk waar blokkeren.

<a name="pass"></a>
<h2>Verkeer Doorlaten</h2>
Verkeer moet nu expliciet doorheen de firewall doorgelaten worden ofwel
zal het standaard weigeren beleid het laten vallen. Dit is waar
pakketcriteria zoals bron/bestemmingspoort, bron/bestemmingsadres, en
protocol in het spel komen. Telkens wanneer verkeer toegestaan wordt om
doorheen de firewall te gaan wordt (worden) de regel(s) best zo
beperkend mogelijk geschreven. Dit om te verzekeren dat het bedoelde
verkeer, en alleen het bedoelde verkeer, toegestaan wordt om door te gaan.

<p>
Enkele voorbeelden:
<blockquote>
<tt>
# Laat verkeer binnen op dc0 vanuit het lokale netwerk,<br>
# 192.168.0.0/24, naar het IP adres van de OpenBSD machine,<br>
# 192.168.0.1. Laat ook het terugkerende verkeer naar buiten<br>
# op dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Laat TCP verkeer binnen op fxp0 naar de webserver die draait op<br>
# de OpenBSD machine. De interfacenaam, fxp0, wordt gebruikt als<br>
# het bestemmingsadres zodat pakketten enkel met deze regel<br>
# overeenstemmen als ze bestemd zijn voor de OpenBSD machine.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>Het <tt>quick</tt> Sleutelwoord</h2>
Zoals eerder aangegeven, wordt elk pakket geëvalueerd met de filterregelset
van boven naar onder. Standaard wordt het pakket gemarkeerd voor doorlating,
wat door gelijk welke regel veranderd kan worden, en verscheidene keren
heen en weer zou kunnen veranderd worden voor het einde van de filterregels.
<b>De laatste overeenstemmende regel "wint".</b>  Hierop is een uitzondering:
de <tt>quick</tt> optie bij een filterregel heeft als effect dat alle
verdere regelverwerking geannuleerd wordt en zorgt ervoor dat de
gespecificeerde actie ondernomen wordt. Laten we naar een paar voorbeelden
kijken:

<p>
Fout:
<blockquote>
<tt>
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
In dit geval kan de <tt>block</tt> lijn geëvalueerd worden, maar ze zal
nooit enig effect hebben, aangezien ze gevolgd wordt door een lijn die
alles zal doorlaten.

<p>
Beter:
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Deze regels worden een beetje verschillend geëvalueerd. Als de <tt>block</tt>
overeenstemt, door de <tt>quick</tt> optie, zal het pakket geblokkeerd
worden, en zal de rest van de regelset genegeerd worden.

<a name="state"></a>
<h2>Toestand ("state") Bijhouden</h2>
Eén van Packet Filter's belangrijke mogelijkheden is "toestand bijhouden"
of "stateful inspection". Stateful inspection verwijst naar PF's mogelijkheid
om de toestand, of voortgang, van een netwerkverbinding te volgen. Door
informatie over elke verbinding te bewaren in een toestandstabel ("state
table"), kan PF snel bepalen of een pakket dat doorheen de firewall gaat
bij een reeds opgerichte verbinding hoort. Zo ja, dan wordt het doorheen
de firewall doorgelaten zonder doorheen de evaluatie van de regelset te gaan.

<p>
Toestand bijhouden heeft vele voordelen waaronder eenvoudigere regelsets
en betere pakketfilterpresatie. PF kan pakketten die in <i>gelijk welke</i>
richting bewegen, in overeenstemming brengen met toestandstabel-entries,
wat betekent dat filterregels die terugkerend verkeer doorlaten niet
geschreven hoeven te worden. En, aangezien pakketten die overeenstemmen
met stateful verbindingen niet doorheen regelsetevaluatie hoeven te gaan,
kan de tijd die PF besteedt aan het verwerken van die pakketten
enorm verminderd worden.

<p>
Wanneer een regel een "state" creëert, creëert het eerste
pakket dat overeenstemt met de regel een "state" tussen zender en ontvanger.
Nu stemmen niet alleen pakketten die van zender naar ontvanger gaan, overeen
met de toestand-entry en ze gaan voorbij aan regelsetevaluatie, maar ook de
antwoordpakketten van ontvanger naar zender.

<p>
Beginnend bij OpenBSD 4.1 creëren alle filterregels automatisch een "state
entry" wanneer een pakket overeenstemt met de regel.
In eerdere versies van OpenBSD moest de filterregel expliciet de
<tt>keep state</tt> optie gebruiken.

<p>
Voorbeeld met OpenBSD 4.1 en volgende:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any
</tt>
</blockquote>

<p>
Voorbeeld met OpenBSD 4.0 en vroeger:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
Deze regels laten gelijk welk uitgaand TCP verkeer toe op de
<tt>fxp0</tt> interface
en staan ook toe dat het antwoordverkeer terug doorheen de firewall gaat.
Hoewel toestand bijhouden een leuke functionaliteit is, verbetert het gebruik
ervan aanzienlijk de prestatie van uw firewall aangezien toestandsopzoekingen
spectaculair sneller zijn dan een pakket doorheen de filterregels laten
lopen.

<p>
De <tt>modulate state</tt> optie werkt net zoals <tt>keep state</tt>
behalve dat ze alleen van toepassing is op TCP pakketten. Met
<tt>modulate state</tt> wordt het Initial Sequence Number (ISN) van uitgaande
verbindingen gerandomiseerd. Dit is nuttig om verbindingen te beschermen
die geïnitieerd werden door bepaalde besturingssystemen die slecht ISNs
kiezen.
Beginnend met OpenBSD 3.5, kan de <tt>modulate state</tt> optie gebruikt
worden in regels die andere protocols dan TCP specificeren.

<p>
Toestand bijhouden op uitgaande TCP, UDP en ICMP pakketten en TCP ISNs
moduleren:
<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Een ander voordeel van toestand bijhouden is dat overeenkomstig ICMP verkeer
zal doorgelaten worden doorheen de firewall.
Als bijvoorbeeld een TCP verbinding die door de firewall gaat met "state"
opgevolgd wordt en er komt een ICMP source-quench bericht aan dat
verwijst naar deze TCP
verbinding, dan zal het met de gepaste toestand-entry in overeenstemming
gebracht worden en doorheen de firewall gelaten worden.

<p>
Het bereik van een toestand-entry wordt globaal gecontroleerd door de
<a href="options.html#state-policy"><tt>state-policy</tt></a>
runtime optie en op een per regel basis door de <tt>if-bound</tt>
en <tt>floating</tt> state optie sleutelwoorden.
Deze per regel sleutelwoorden hebben dezelfde betekenis als wanneer
ze gebruikt worden met de <tt>state-policy</tt> optie. Voorbeeld:

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Deze regel zou opdragen dat opdat pakketten zouden overeenstemmen met
de toestand-entry, ze de <tt>fxp0</tt> interface moeten doorkruisen.


<p>
Merk op dat <a href="nat.html"><tt>nat</tt></a>, 
<a href="nat.html#binat"><tt>binat</tt></a> en
<a href="rdr.html"><tt>rdr</tt></a> regels impliciet toestand creëren voor
overeenstemmende verbindingen zolang de verbinding doorgelaten wordt door
de filterregelset.

<a name="udpstate"></a>
<h2>Toestand ("state") Bijhouden voor UDP</h2>
Men zal soms horen zeggen dat, "Men geen toestand mag creëren met UDP
aangezien UDP een toestandloos protocol is!" Hoewel het waar is dat een UDP
communicatiesessie geen concept van toestand (een expliciet begin en einde
van communicatie) heeft, heeft dit geen impact op PF's mogelijkheid om
toestand te creëren voor een UDP sessie. In het geval van protocols zonder
"begin" en "eind" pakketten, houdt PF eenvoudigweg bij hoe lang het
geleden is dat er een overeenstemmend pakket doorgelaten werd. Als de
timeout bereikt wordt, wordt de toestand leeggemaakt. De timeout-waarden
kunnen ingesteld worden in de <a href="options.html">opties</a> sectie
van het <tt>pf.conf</tt> bestand.

<a name="stateopts"></a>
<h2>"Stateful" Traceringsopties</h2>
Filterregels die "state entries" creëren, kunnen verscheidene opties
specificeren om het gedrag van de resulterende "state entry" te controleren.
De volgende opties zijn beschikbaar:

<dl>
<dt><tt>max <i>aantal</i></tt>
<dd>Beperk het maximum aantal toestandsentries die de regel kan aanmaken tot
<i>aantal</i>.
Indien het maximum bereikt is, stemmen pakketten die normaal toestand creëren
niet overeen met deze regel totdat het aantal bestaande toestanden afneemt
tot onder de limiet.

<dt><tt>no state</tt>
<dd>Voorkomt dat de regel automatisch een "state entry" creëert.

<dt><tt>source-track</tt>
<dd>Deze optie schakelt het traceren in van het aantal toestanden aangemaakt
per bron IP adres.
Deze optie heeft twee formaten:
	<ul>
	<li><tt>source-track rule</tt> - Het maximum aantal toestanden
	aangemaakt door deze regel wordt beperkt door de <tt>max-src-nodes</tt>
	en <tt>max-src-states</tt> opties van de regel. Enkel toestandsentries
	aangemaakt door deze bepaalde regel tellen voor de limieten van de
	regel.
	<li><tt>source-track global</tt> - Het aantal toestanden aangemaakt
	door alle regels die deze optie gebruiken, wordt beperkt. Elke regel
	kan verschillende <tt>max-src-nodes</tt> en <tt>max-src-states</tt>
	opties specificeren, toestandsentries aangemaakt door gelijk welke
	deelnemende regel tellen echter voor de limieten van elke individuele
	regel.
	</ul>
Het totale aantal globaal getraceerde bron IP adressen kan geregeld worden
via de
<a href="options.html#limit"><tt>src-nodes</tt> runtime optie</a>.

<dt><tt>max-src-nodes <i>aantal</i></tt>
<dd>Wanneer de <tt>source-track</tt> optie gebruikt wordt,
zal <tt>max-src-nodes</tt> het aantal bron IP adressen beperken die
gelijktijdige toestand kunnen aanmaken.
Deze optie kan alleen gebruikt worden met <tt>source-track rule</tt>.

<dt><tt>max-src-states <i>aantal</i></tt>
<dd>Wanneer de <tt>source-track</tt> optie gebruikt wordt,
zal <tt>max-src-states</tt> het aantal gelijktijdige toestandsentries beperken
die per bron IP adres kunnen aangemaakt worden.
Het bereik van deze limiet (bv. toestanden aangemaakt door alleen deze regel
of toestanden aangemaakt door alle regels die <tt>source-track</tt> gebruiken)
is afhankelijk van de gespecificeerde <tt>source-track</tt> optie.
</dl>

<p>
Opties worden gespecificeerd tussen haakjes en onmiddellijk na één van de
state sleutelwoorden (<tt>keep state</tt>, <tt>modulate state</tt> of
<tt>synproxy state</tt>).
Meerdere opties worden gescheiden door komma's.
Vanaf OpenBSD 4.1 werd de <tt>keep state</tt> optie impliciet de
standaard voor alle filterregels.
Desondanks moet, wanneer men stateful opties specificeert, één van de
state sleutelwoorden nog steeds gebruikt worden vóór de opties.


<p>
Een voorbeeldregel:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max 200, source-track rule, max-src-nodes 100,
max-src-states 3)
</tt>
</blockquote>

<p>
De bovenstaande regel definieert het volgende gedrag:

<ul>
<li>Beperk het absolute maximum aantal toestanden die deze regel kan aanmaken
tot 200
<li>Schakel source tracking in; beperk toestandscreatie gebaseerd op toestanden
aangemaakt door alleen deze regel
<li>Beperk het maximum aantal knooppunten die gelijktijdig toestand kunnen
aanmaken tot 100
<li>Beperk het maximum aantal gelijktijdige toestanden per bron IP adres tot 3
</ul>

<p>
Een afzonderlijk stel beperkingen kan geplaatst worden op "stateful" TCP
verbindingen die de 3-wegs handdruk voltooid hebben.

<dl>
<dt><tt>max-src-conn <i>aantal</i></tt>
<dd>Beperk het maximum aantal gelijktijdige TCP verbindingen die de
3-wegs handdruk voltooid hebben die een enkele host kan maken.
<dt><tt>max-src-conn-rate <i>aantal</i> / <i>interval</i></tt>
<dd>Beperk de snelheid waarmee nieuwe connecties gemaakt worden tot een
bepaalde hoeveelheid per tijdsinterval.
</dl>

<p>
Beide opties roepen automatisch de <tt>source-track rule</tt> optie op
en zijn niet compatibel met <tt>source-track global</tt>.

<p>
Aangezien deze beperkingen alleen geplaatst worden op TCP verbindingen die
de 3-wegs handdruk voltooid hebben, kunnen meer agressieve acties genomen
worden op overtredende IP adressen.

<dl>
<dt><tt>overload &lt;<i>tabel</i>&gt;</tt>
<dd>Zet het IP adres van een overtredende host in de genoemde tabel.
<dt><tt>flush [global]</tt>
<dd>Verwijder andere toestanden die met deze regel overeenstemmen en die
aangemaakt werden door dit bron IP adres.
Wanneer <tt>global</tt> gespecificeerd wordt, verwijder alle toestanden die
overeenstemmen met dit bron IP adres, ongeacht welke regel de toestand
aanmaakte.
</dl>

<p>
Een voorbeeld:

<blockquote>
<tt>
table &lt;abusive_hosts&gt; persist<br>
block in quick from &lt;abusive_hosts&gt;<br>
<br>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www flags S/SA keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max-src-conn 100, max-src-conn-rate 15/5,
overload &lt;abusive_hosts&gt; flush)
</tt>
</blockquote>

<p>
Dit doet het volgende:

<ul>
<li>Beperkt het maximum aantal verbindingen per bron tot 100
<li>Beperkt de snelheid van verbindingen tot 15 in een tijdsspanne van 5
seconden
<li>Zet het IP aders van gelijk welke host die deze beperkingen verbreekt in
de <tt>&lt;abusive_hosts&gt;</tt> tabel.
<li>Voor gelijk welke overtredende IP adressen, "flush" gelijk welke
toestanden aangemaakt door deze regel.
</ul>

<a name="tcpflags"></a>
<h2>TCP Vlaggen</h2>
TCP pakketten overeenstemmen op basis van vlaggen wordt het vaakst gebruikt
om TCP pakketten te filteren die een nieuwe verbinding proberen te openen.
De TCP vlaggen en hun betekenis worden hier opgesomd:
<ul>
<li><b>F</b> : FIN  - Finish; einde van sessie
<li><b>S</b> : SYN  - Synchronize; geeft een verzoek om sessie te beginnen aan
<li><b>R</b> : RST  - Reset; een verbinding laten vallen
<li><b>P</b> : PUSH - Push; pakket wordt onmiddellijk verzonden
<li><b>A</b> : ACK  - Acknowledgement; ontvangstbevestiging
<li><b>U</b> : URG  - Urgent; dringend
<li><b>E</b> : ECE  - Explicit Congestion Notification Echo
<li><b>W</b> : CWR  - Congestion Window Reduced
</ul>

<p>
Om PF de TCP vlaggen te laten inspecteren tijdens de evaluatie van een regel,
wordt het <tt>flags</tt> sleutelwoord gebruikt met de volgende syntaxis:
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i><br>
flags any
</tt>
</blockquote>

<p>
Het <tt><i>mask</i></tt> gedeelte vertelt PF alleen de gespecificeerde
vlaggen te inspecteren en het <tt><i>check</i></tt> gedeelte specificeert
welke vlag(gen) "aan" moeten staan in de hoofding opdat overeenstemming
zou plaatsvinden.
Het gebruik van het <tt>any</tt> sleutelwoord laat gelijk welke combinatie
van vlaggen toe in de hoofding.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
</tt>
</blockquote>

<p>
De bovenstaande regel laat TCP verkeer door met de SYN vlag aangezet
terwijl hij enkel kijkt naar de SYN en ACK vlaggen. Een pakket met de
SYN en ECE vlaggen zou overeenstemmen met de bovenstaande regel, maar
een pakket met SYN en ACK of gewoon ACK niet.

<p>
Vanaf OpenBSD 4.1 zijn de standaardvlaggen die toegepast worden op TCP
regels <tt>flags S/SA</tt>.
In combinatie met de OpenBSD 4.1 standaard <tt>keep state</tt> op
filterregels worden deze twee regels equivalent:
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state<br>
pass out on fxp0 proto tcp all
</tt>
</blockquote>

<p>
Iedere regel zal overeenstemmen met TCP pakketten waarbij die de SYN vlag
aan staat en de ACK vlag uit, en zullen een "state entry" creëren voor
overeenstemmende pakketten.
De standaardvlaggen kunnen overschreden worden door de <tt>flags</tt>
optie zoals hierboven beschreven.

<p>
In OpenBSD 4.0 en vroeger werden standaard geen vlaggen toegepast op
filterregels.
Iedere regel moest specificeren welke vlag(gen) moesten overeenstemmen en
moest ook expliciet de <tt>keep state</tt> optie gebruiken.
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>

<p>
Men moet voorzichtig zijn met het gebruik van vlaggen -- begrijp wat u aan
het doen bent en waarom, en wees voorzichtig met de raad die mensen geven
aangezien veel ervan slecht is. Sommige mensen hebben gesuggereerd toestand
te creëren "alleen als de SYN vlag aangezet is en geen andere". Zo'n regel
zou eindigen op:
<pre>
     . . . flags S/FSRPAUEW  <i>slecht idee!!</i>
</pre>

<p>
De theorie is: creëer toestand alleen bij het begin van de TCP sessie, en
de sessie zou moeten beginnen met een SYN vlag, en geen andere. Het
probleem is dat sommige sites de ECN vlag beginnen te gebruiken en gelijk
welke site die ECN gebruikt en met u probeert te verbinden, zou afgewezen
worden door zulk een regel.
Een veel betere richtlijn is helemaal geen vlaggen specificeren en PF de
standaardvlaggen laten toepassen op uw regels.
Als u werkelijk zelf de vlaggen moet specificeren, dan zou deze combinatie
veilig moeten zijn:
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
Hoewel dit praktisch en veilig is, is het onnodig om de FIN en RST
vlaggen na te kijken indien trafiek ook
<!--XXX scrub-->
geschrobd wordt. Het schrob-proces zal ervoor
zorgen dat PF binnenkomende pakketten met illegale TCP vlag combinaties
(zoals SYN en RST) laat vallen en mogelijk dubbelzinnige combinaties
(zoals SYN en FIN) normaliseert.


<a name="synproxy"></a>
<h2>TCP SYN Proxy</h2>
<p>
Normaal gezien, wanneer een client een TCP verbinding met een server
initieert, zal PF de
<a href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml"
>handdruk</a> ("handshake") pakketten tussen de twee eindpunten doorlaten
als ze aankomen.
PF heeft echter de mogelijkheid om de handdruk te proxy'en.
Wanneer de handdruk geproxied wordt, zal PF zelf de handdruk met de client
voltooien, een handdruk met de server initiëren, en vervolgens pakketten
tussen beide doorsturen.
Het voordeel van dit proces is dat er geen pakketten naar de server
gestuurd worden alvorens de client de handdruk voltooit.
Dit elimineert de bedreiging van gespoofte TCP SYN floods die de server
treffen omdat een gespoofte client verbinding de handdruk niet zal kunnen
voltooien.

<p>
De TCP SYN proxy wordt ingeschakeld met de <tt>synproxy state</tt>
sleutelwoorden in filterregels. Voorbeeld:

<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
Hier zullen verbindingen naar de webserver TCP-geproxied worden door PF.

<p>
Omwille van de manier waarop <tt>synproxy state</tt> werkt, omvat het ook
dezelfde functionaliteit als <tt>keep state</tt> en <tt>modulate state</tt>.

<p>
De SYN proxy zal niet werken als PF draait op een
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a>.

<a name="antispoof"></a>
<h2>Gespoofte Pakketten Blokkeren</h2>
Adres-"spoofing" is wanneer een kwaadwillige gebruiker het bron-IP adres
vervalst in pakketten die hij verstuurt ofwel om zijn echt adres te verbergen
ofwel om zich uit te geven voor een ander knooppunt op het netwerk. Zodra
de gebruiker zijn adres gespooft heeft kan hij een netwerkaanval lanceren
zonder de ware bron van de aanval te onthullen, of toegang proberen te
verkrijgen tot netwerkdiensten die beperkt zijn tot bepaalde IP adressen.

<p>
PF biedt wat bescherming tegen adres-spoofing via het
<tt>antispoof</tt> sleutelwoord:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Specificeert dat overeenstemmende pakketten gelogd moeten worden via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.6"
>pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Als een pakket overeenstemt met deze regel dan zal deze beschouwd worden
als de "winnende" regel en zal de regelsetevaluatie stoppen.

<dt><tt><i>interface</i></tt>
<dd>De netwerkinterface om spoofing-bescherming op te activeren. Dit kan ook
een <a href="macros.html#lists">lijst</a> van interfaces zijn.

<dt><tt><i>af</i></tt>
<dd>De adresfamilie om spoofing-bescherming voor te activeren, ofwel
<tt>inet</tt> voor IPv4 of <tt>inet6</tt> voor IPv6.
</dl>

<p>
Voorbeeld:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Wanneer een regelset geladen wordt, zal het voorkomen van het
<tt>antispoof</tt> sleutelwoord ontvouwen worden in twee filterregels.
In de veronderstelling dat interface <tt>fxp0</tt> IP adres 10.0.0.1 heeft
en een subnet mask van 255.255.255.0 (dus een /24), zou de bovenstaande
<tt>antispoof</tt> regel ontvouwen tot:

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Deze regels bereiken twee dingen:
<ul>
<li>Blokkeert alle verkeer dat afkomstig is van het 10.0.0.0/24 netwerk en
<i>niet</i> via <tt>fxp0</tt> binnenkomt. Aangezien het 10.0.0.0/24 netwerk
op de <tt>fxp0</tt> interface zit, zouden pakketten met een bronadres in dat
netwerkblok nooit via gelijk welke andere interface mogen binnenkomen.
<li>Blokkeert alle ingaand verkeer vanaf 10.0.0.1, het IP adres op
<tt>fxp0</tt>.
De host machine zou nooit pakketten moeten sturen naar zichzelf via een
externe interface, dus gelijk welke binnenkomende pakketten met een
bronadres dat toebehoort aan de machine, kunnen als kwaadwillig beschouwd
worden.
</ul>

<p>
<b>OPMERKING</b>: De filterregels waarin de <tt>antispoof</tt> regel
zich ontvouwt, zullen ook pakketten blokkeren die over de loopback
interface naar lokale adressen verzonden worden.
De beste gewoonte is om het filteren over te slaan op loopback interfaces,
dit wordt echter een noodzaak bij gebruik van antispoof regels:
<blockquote>
<tt>
set skip on lo0<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Gebruik van <tt>antispoof</tt> wordt best beperkt tot interfaces waaraan
een IP adres is toegekend. Gebruik van <tt>antispoof</tt> op een interface
zonder IP adres zal leiden tot filterregels als:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Met deze regels is er een risico om <i>alle</i> ingaand verkeer op
<i>alle</i> interfaces te blokkeren.

<a name="urpf"></a>
<h2>Unicast Reverse Path Forwarding</h2>

<p>
Beginnend met <a href="../../../nl/40.html">OpenBSD 4.0</a>, biedt PF een
Unicast Reverse Path Forwarding (uRPF) functionaliteit.
Wanneer een pakket doorheen de uRPF controle gehaald wordt, wordt het bron
IP adres van het pakket opgezocht in de routeringstabel.
Als de uitgaande interface die gevonden werd in de routeringstabel dezelfde
is als de interface waarop het pakket net binnenkwam, dan slaagt de uRPF
controle.
Als de interfaces niet overeenstemmen, dan is het mogelijk dat het bronadres
van het pakket "gespoofed" werd.

<p>
De uRPF controle kan op pakketten uitgevoerd worden door het
<tt>urpf-failed</tt> sleutelwoord te gebruiken in filterregels:

<blockquote>
<tt>
block in quick from urpf-failed label uRPF
</tt>
</blockquote>

<p>
Merk op dat de uRPF controle alleen steek houdt in een omgeving waar
routering symmetrisch is.

<p>
uRPF biedt dezelfde functionaliteit als
<a href="#antispoof">antispoof</a> regels.


<a name="osfp"></a>
<h2>Passieve Besturingssysteem "Fingerprinting"</h2>

<p>
Passive OS Fingerprinting (OSFP) is een methode om passief het
besturingssysteem van een remote host te detecteren op basis van bepaalde
karakteristieken binnen de TCP SYN pakketten van die host.
Deze informatie kan vervolgens gebruikt worden als criteria binnen
filterregels.

<p>
PF bepaalt het remote besturingssysteem door karakteristieken van een
TCP SYN pakket te vergelijken met het
<a href="options.html#fingerprints">fingerprints bestand</a>, dat
standaard
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.6"
><tt>/etc/pf.os</tt></a> is.
Zodra PF ingeschakeld wordt, kan de huidige fingerprint lijst bekeken
worden met dit commando:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Binnen een filterregel kan een fingerprint gespecificeerd worden per
OS klasse, versie, of subtype/patchniveau.
Elk van deze items wordt opgesomd in de uitvoer van het hierboven
getoonde <tt>pfctl</tt> commando. Om een fingerprint te specificeren in
een filterregel, wordt het <tt>os</tt> sleutelwoord gebruikt:

<blockquote>
<tt>
pass &nbsp;in on $ext_if from any os OpenBSD keep state<br>
block in on $ext_if from any os "Windows 2000"<br>
block in on $ext_if from any os "Linux 2.4 ts"<br>
block in on $ext_if from any os unknown
</tt>
</blockquote>

<p>
De speciale besturingssysteemklasse <tt>unknown</tt> laat toe pakketten
te laten overeenstemmen wanneer de OS fingerprint niet gekend is.

<p>
<font color="#ff0000">NOTEER</font> het volgende:
<ul>
  <li>Besturingssysteem fingerprints zijn nu en dan verkeerd door gespoofte
  en/of gekunstelde pakketten die gemaakt zijn om er uit te zien alsof ze
  van een specifiek besturingssysteem afkomstig zijn.
  <li>Bepaalde revisies of patchniveau's van een besturingssysteem kunnen
  het gedrag van de stack veranderen en ervoor zorgen dat het niet
  overeenstemt met wat er in het fingerprints bestand staat of in het
  geheel met geen andere entry overeenstemt.
  <li>OSFP werkt alleen op het TCP SYN pakket; het zal niet werken op
  andere protocols of op reeds opgerichte verbindingen.
</ul>

<a name="ipopts"></a>
<h2>IP Opties</h2>

Standaard blokkeert PF pakketten waarbij IP opties zijn ingesteld. Dit kan
de taak moeilijker maken voor "OS fingerprinting" utilities zoals nmap.
Als u een toepassing hebt die het doorlaten van deze pakketten vereist,
zoals multicast of IGMP, kan u de <tt>allow-opts</tt> opdracht gebruiken:
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Filterregelset Voorbeeld</h2>
Hieronder staat een voorbeeld van een filterregelset. De machine die PF
draait, fungeert als firewall tussen een klein, intern netwerk en het
Internet.
Alleen de filterregels zijn getoond;
<a href="queueing.html">queueing</a>, 
<a href="nat.html"><tt>nat</tt></a>, 
<a href="rdr.html"><tt>rdr</tt></a>, 
enz. werden uit dit voorbeeld gelaten.
<br>
<br>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# tabel die alle IP adressen bevat die toegekend zijn aan de firewall
table &lt;firewall&gt; const { self }

# filter niet op de loopback interface
set skip on lo0

# schrob binnenkomende pakketen
match in all scrub (no-df)

# stel een standaard weigeren beleid in
block all

# activeer spoofing-bescherming voor alle interfaces
block in quick from urpf-failed

# laat alleen ssh verbindingen toe vanaf het lokale netwerk als het vanaf de
# vertrouwde computer, 192.168.0.15, komt. gebruik "block return" zodat een
# TCP RST verzonden wordt om geblokkeerde verbindingen meteen te sluiten.
# gebruik "quick" zodat deze regel niet opgeheven wordt door de "pass" regels
# hieronder.
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh

# laat alle verkeer naar en vanuit het lokale netwerk door.
# deze regels zullen state entries aanmaken dankzij de standaard
# "keep state" optie die automatisch wordt toegepast.
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net

# laat tcp, udp en icmp naar buiten op de externe (Internet) interface. 
pass out on $ext_if proto { tcp udp icmp } all modulate state

# laat ssh verbindingen binnen op de externe interface zolang ze NIET
# bestemd zijn voor de firewall (ze zijn dus bestemd voor een machine in
# het lokale netwerk). log het initiële pakket zodat we later kunnen
# zeggen wie er probeert te verbinden. gebruik de tcp syn proxy om de
# verbinding te proxy'en.
# de standaard vlaggen "S/SA" worden door PF automatisch toegepast op de
# regel.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
   port ssh synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Vorige: Tabellen</a>]
[<a href="index.html">Inhoud</a>]
[<a href="nat.html">Volgende: Network Address Translation</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[terug]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: filter.html,v 1.53 ]<br>
$Translation: filter.html,v 1.25 2009/11/30 18:22:51 maurice Exp $<br>
-->
$OpenBSD: filter.html,v 1.25 2009/12/09 08:30:06 ajacoutot Exp $
</small>

</body>
</html> 

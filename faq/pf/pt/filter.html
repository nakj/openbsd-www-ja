<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Filtragem de Pacotes</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2007 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../pt/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="tables.html">Anterior: Tabelas</a>]
[<a href="index.html">Conteúdo</a>]
[<a href="nat.html">Próximo: Tradução do Endereço de Rede (NAT)</a>]

<h1><font color="#e00000">PF: Filtragem de Pacotes</font></h1>

<hr>

<h3>Conteúdo</h3>
<ul>
<li><a href="#intro">Introdução</a>
<li><a href="#syntax">Sintaxe das Regras</a>
<li><a href="#defdeny">Negar por Padrão</a>
<li><a href="#pass">Passando o Tráfego</a>
<li><a href="#quick">A Palavra-chave <tt>quick</tt></a>
<li><a href="#state">Mantendo o Estado</a>
<li><a href="#udpstate">Mantendo o Estado para UDP</a>
<li><a href="#stateopts">Opções de Rastreamento de Estado</a>
<li><a href="#tcpflags">Sinalizadores TCP</a>
<li><a href="#synproxy">Proxy de Pacotes TCP SYN</a>
<li><a href="#antispoof">Bloqueio de Pacotes Falsificados</a>
<li><a href="#urpf">Unicast Reverse Path Forwarding</a>
<li><a href="#osfp">Detecção Passiva de Sistema Operacional</a>
<li><a href="#ipopts">Opções IP</a>
<li><a href="#example">Exemplo de Conjunto de Regras de Filtragem</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Introdução</h2>
Filtragem de pacotes é o bloqueio ou liberação de maneira seletiva da
passagem de pacotes de dados, conforme eles atravessam uma interface de
rede. O critério que o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.6"
>pf(4)</a> usa quando inspeciona pacotes é baseado na Camada 3
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a> e
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4"
>IPv6</a>) e na Camada 4
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4"
>ICMP</a> e
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4"
>ICMPv6</a>). Os critérios mais usados são os endereços de origem e
destino, porta de origem e destino, e protocolo.

<p>
Regras de filtragem especificam o critério em que o pacote deve se
enquadrar e a ação resultante que é tomada quando o pacote corresponde
à regra, que pode ser o bloqueio ou a liberação.
As regras de filtragem são avaliadas em sequência, da primeira até a
última.
A menos que o pacote corresponda a uma regra contendo a palavra-chave
<tt>quick</tt>, ele é avaliado por <i>todas</i> as regras de
filtragem antes da ação final ser tomada. A última regra a corresponder
é a "vencedora" e dita qual ação tomar. Existe um <tt>pass all</tt>
implícito no início de um conjunto de regras de filtragem, que significa
que caso o pacote não corresponda a nenhuma regra a ação resultante será
<tt>pass</tt>.

<a name="syntax"></a>
<h2>Sintaxe das Regras</h2>
A forma geral <i>altamente simplificada</i> da sintaxe para regras de
filtragem é:
<blockquote>
<tt>
<i>ação</i> [<i>direção</i>] [log] [quick] [on <i>interface</i>]
[<i>fam_de_end</i>] [proto <i>protocolo</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>end_de_or</i> [port <i>porta_de_or</i>]] [to
<i>end_de_dest</i> [port <i>porta_de_dest</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>sinalizadores_tcp</i>] [<i>estado</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>ação</i></tt>
<dd>A ação executada em pacotes que correspondem à regra; pode ser
<tt>pass</tt> ou <tt>block</tt>. A ação <tt>pass</tt> libera a
passagem do pacote para posterior processamento pelo kernel, enquanto
a ação <tt>block</tt> reage com base na definição da opção
<a href="options.html#block-policy"><tt>block-policy</tt></a>.
A reação padrão pode ser sobrescrita especificando <tt>block drop</tt>
ou <tt>block return</tt> na regra.

<dt><tt><i>direção</i></tt>
<dd>A direção em que o pacote está se movendo em uma interface, pode ser
<tt>in</tt> (entrando) ou <tt>out</tt> (saindo).

<dt><tt>log</tt>
<dd>Especifica que o pacote deve ser registrado via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.6"
>pflogd(8)</a>. Se a regra cria um estado, somente o pacote que
estabeleceu o estado é registrado.
Para registrar todos pacotes, use <tt>log (all)</tt>.

<dt><tt>quick</tt>
<dd>Se um pacote corresponde a uma regra especificada com
<tt>quick</tt>, então essa regra é considerada final e a
<tt><i>ação</i></tt> especificada é executada.

<dt><tt><i>interface</i></tt>
<dd>O nome ou grupo da interface de rede onde o pacote está passando.
Interfaces podem ser adicionadas a um grupo usando o comando
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>.
Vários grupos também são criados automaticamente pelo kernel:
<ul>
<li>O grupo <tt>egress</tt>, que contém a(s) interface(s) que guarda(m)
    a(s) rota(s) padrão.
<li>O grupo da família de interfaces das interfaces clonadas.
    Por exemplo: <tt>ppp</tt> ou <tt>carp</tt>.
</ul>
Isso faria com que a regra correspondesse a qualquer pacote atravessando
qualquer interface <tt>ppp</tt> ou <tt>carp</tt>, respectivamente.

<dt><tt><i>fam_de_end</i></tt>
<dd>A família de endereços do pacote, <tt>inet</tt> para IPv4 ou
<tt>inet6</tt> para IPv6. Geralmente o PF pode determinar essa
informação com base no(s) endereço(s) de origem e/ou destino do pacote.

<dt><tt><i>protocolo</i></tt>
<dd>O protocolo da Camada 4 do pacote:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Um nome de protocolo válido de
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5"
    ><tt>/etc/protocols</tt></a>
<li>Um número de protocolo entre 0 e 255
<li>Um conjunto de protocolos utilizando uma
    <a href="macros.html#lists">lista</a>.
</ul>

<dt><tt><i>end_de_or</i></tt>, <tt><i>end_de_dest</i></tt>
<dd>Os endereços de origem/destino no cabeçalho IP. Endereços podem ser
especificados como:
<ul>
<li>Um único endereço IPv4 ou IPv6.
<li>Um bloco de rede <a href="http://public.pacbell.net/dedicated/cidr.html"
    >CIDR</a>.
<li>Um nome de domínio totalmente qualificado que será resolvido pelo
    DNS quando o conjunto de regras for carregado. Todos os endereços IP
    resultantes serão substituídos na regra.
<li>O nome de uma interface de rede ou grupo. Quaisquer endereços IP na
    interface serão substituídos na regra.
<li>O nome de uma interface de rede seguido de uma
    <tt>/<i>máscara</i></tt> (ou seja, <tt>/24</tt>). Cada endereço IP
    na interface é combinado com a máscara para formar um bloco de rede
    CIDR que será substituído na regra.
<li>O nome de uma interface de rede ou grupo entre parêntesis
    <tt>( )</tt>. Isso informa ao PF para atualizar a regra caso o(s)
    endereço(s) da interface em questão mude(m). Isso é útil em uma
    interface que obtém seu endereço IP via DHCP ou discada, pois o
    conjunto de regras não precisa ser recarregado toda vez que o
    endereço mudar.
<li>O nome de uma interface de rede seguido de um destes modificadores:
    <ul>
    <li><tt>:network</tt> - substitui o bloco de rede CIDR (por exemplo,
        192.168.0.0/24)
    <li><tt>:broadcast</tt> - substitui o endereço de broadcast
        (por exemplo, 192.168.0.255)
    <li><tt>:peer</tt> - substitui o endereço IP da outra ponta em um
        link ponto a ponto
    </ul>
    <dl>
    <dd>Além disso, o modificador <tt>:0</tt> pode ser acrescentado a um
    nome de interface ou a qualquer um dos modificadores acima para
    dizer ao PF para não incluir apelidos de endereços IP na
    substituição.
    Esses modificadores também podem ser usados quando a interface está
    entre parêntesis.
    Exemplo: <tt>fxp0:network:0</tt>
    </dl>
<li>Uma <a href="tables.html">tabela</a>.
<li>A palavra-chave <tt>urpf-failed</tt> pode ser usada no
    endereço de origem para indicar que ele deve continuar
    através de uma <a href="#urpf">verificação uRPF</a>.
<li>Qualquer um dos apresentados acima, mas negado usando o modificador
    <tt>!</tt> ("não").
<li>Um grupo de endereços usando-se uma <a href="macros.html#lists">
    lista</a>.
<li>A palavra-chave <tt>any</tt>, indicando todos os endereços
<li>A palavra-chave <tt>all</tt>, que é um atalho para <tt>from any to
    any</tt>.
</ul>

<dt><tt><i>porta_de_or</i></tt>, <tt><i>porta_de_dest</i></tt>
<dd>A porta de origem/destino no cabeçalho da Camada 4 do pacote. Portas
podem ser especificadas da seguinte forma:
<ul>
<li>Um número entre 1 e 65535
<li>Um nome de serviço válido de
    <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5"
    ><tt>/etc/services</tt></a>
<li>Um grupo de portas usando-se uma <a href="macros.html#lists">lista</a>
<li>Uma faixa:
	<ul>
	<li><tt>!=</tt> (diferente de)
	<li><tt>&lt;</tt> (menor que)
	<li><tt>&gt;</tt> (maior que)
	<li><tt>&lt;=</tt> (menor ou igual a)
	<li><tt>&gt;=</tt> (maior ou igual a)
	<li><tt>&gt;&lt;</tt> (faixa)
	<li><tt>&lt;&gt;</tt> (faixa inversa)
	<dl>
	<dd>Os dois últimos são operadores binários (recebem dois
	argumentos) e não incluem os argumentos na faixa.
	</dl>
	<li><tt>:</tt> (faixa inclusiva)
	<dl>
	<dd>O operador de faixa inclusiva também é um operador binário
	e inclui os argumentos na faixa.
	</dl>
	</ul>
</ul>

<dt><tt><i>sinalizadores_tcp</i></tt>
<dd>Especifica os sinalizadores que precisam estar definidos no
cabeçalho TCP quando <tt>proto tcp</tt> for utilizado. Sinalizadores
são especificados como:
<tt>flags <i>a_verificar</i>/<i>máscara</i></tt>. Por exemplo: <tt>flags
S/SA</tt> - instrui o PF a verificar somente os sinalizadores S e A
(SYN e ACK) e corresponder somente se apenas o sinalizador SYN estiver
"ligado". No OpenBSD 4.1 e versões recentes, os sinalizadores padrão
<tt>S/SA</tt> são aplicados em todas as regras de filtragem TCP.

<dt><tt><i>estado</i></tt>
<dd>Especifica se a informação de estado deve ser mantida em pacotes
que correspondam à regra.
<ul>
<li><tt>keep state</tt> - funciona com TCP, UDP e ICMP.
    No OpenBSD 4.1 e versões recentes, essa opção é o padrão para todas
    as regras de filtragem.
<li><tt>modulate state</tt> - funciona apenas com TCP. O PF irá gerar
    Números de Sequência Inicial (ISN - "Initial Sequence Number")
    seguros para os pacotes que correspondam à regra.
<li><tt>synproxy state</tt> - faz proxy de pedidos de conexão TCP para
    ajudar a proteger servidores contra a inundação de pacotes TCP SYN
    falsificados. Essa opção inclui a funcionalidade <tt>keep state</tt>
    e <tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Negar por Padrão</h2>
A prática recomendada ao configurar um firewall é usar uma política
"negar por padrão". Isto é, bloquear <i>tudo</i> e depois ir
permitindo certos tipos de tráfego através do firewall. Essa é a
abordagem recomendada por ser mais cautelosa, além de facilitar a
configuração do conjunto de regras.

<p>
Para criar uma política de filtragem de negar por padrão, as primeiras
duas regras de filtragem devem ser:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Isso bloqueia todo o tráfego em todas interfaces em qualquer direção,
de qualquer lugar para qualquer lugar.

<a name="pass"></a>
<h2>Passando o Tráfego</h2>
O tráfego agora deve ser explicitamente permitido ou será barrado pela
política padrão do firewall. É aqui que os critérios de filtragem
como porta de origem/destino, endereço de origem/destino e protocolo
entram em cena. Sempre que o tráfego tiver permissão de cruzar o
firewall, as regras devem ser escritas da maneira mais restritiva
possível. Isso é para nos certificarmos de que o tráfego válido, e
somente tráfego válido, terá permissão para passar.

<p>
Alguns exemplos:
<blockquote>
<tt>
# Libera o tráfego entrando na interface dc0, vindo da rede local<br>
# 192.168.0.0/24 e indo para a máquina OpenBSD com o endereço IP<br>
# 192.168.0.1. Também permite o tráfego de retorno saindo da dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Libera o tráfego TCP chegando em fxp0 e indo para o servidor Web<br>
# em execução na máquina OpenBSD. O nome da interface, fxp0, é usado<br>
# como endereço de destino, de modo que aqueles pacotes somente<br>
# correspondam à regra se eles têm como destino a máquina OpenBSD.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>A palavra-chave <tt>quick</tt></h2>
Como dito anteriormente, cada pacote é avaliado pelo conjunto de regras
de filtragem de cima para baixo. Por padrão, o pacote é marcado para
passagem, o que pode ser alterado por qualquer regra e depois alterado
novamente várias vezes antes do fim das regras de filtragem. <b>A última
regra que corresponde "vence".</b>  Mas, há uma exceção à regra: a
opção <tt>quick</tt> em uma regra de filtragem tem o efeito de cancelar
o processamento de qualquer outra regra que venha em seguida e executa
imediatamente a ação especificada.
Vejamos alguns exemplos:

<p>
Errado:
<blockquote>
<tt>
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Nesse caso, a linha <tt>block</tt> será avaliada, mas jamais terá efeito
algum, pois é seguida de uma linha que permite a passagem de tudo.

<p>
Melhor:
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Essas regras são avaliadas de maneira ligeiramente diferente.
Caso a linha <tt>block</tt> corresponda à regra, devido ao uso da opção
<tt>quick</tt>, o pacote será bloqueado e o restante do
conjunto de regras será ignorado.

<a name="state"></a>
<h2>Mantendo o Estado</h2>
Uma das características importantes do Packet Filter é manter o estado
das conexões. O PF é capaz de registrar o estado, ou progresso, de
uma conexão de rede. Ao armazenar informações sobre o estado de cada
conexão em uma tabela de estados, o PF pode rapidamente determinar se um
pacote passando pelo firewall pertence a uma conexão já estabelecida.
Caso afirmativo, o pacote passa direto pelo firewall sem ser avaliado
pelo conjunto de regras.

<p>
Manter informações do estado das conexões traz muitas vantagens,
incluindo simplicidade na configuração do conjunto de regras e melhor
desempenho na filtragem de pacotes. O PF é capaz de comparar os pacotes,
indo em <i>qualquer</i> direção, com as entradas na tabela de estados,
o que significa que regras de filtragem que autorizam o tráfego de
retorno não precisam ser escritas. E, como pacotes que correspondem às
conexões com o estado mantido não são avaliados pelo conjunto de regras,
o tempo que o PF gasta processando aqueles pacotes pode ser reduzido
drasticamente.

<p>
Quando uma regra cria estado, o primeiro pacote que corresponde à regra
cria um "estado" entre o transmissor e o receptor.
Agora, não somente os pacotes do transmissor para o receptor
correspondem à entrada na tabela e passam direto pela avaliação do
conjunto de regras, mas também os pacotes de resposta do receptor
para o transmissor.

<p>
A partir do OpenBSD 4.1, todas as regras de filtragem criam
automaticamente uma entrada de estado quando um pacote corresponde à
regra.
Em versões antigas do OpenBSD, a regra de filtragem tinha que
usar explicitamente a opção <tt>keep state</tt>.

<p>
Exemplo de uso no OpenBSD 4.1 e versões recentes:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any
</tt>
</blockquote>

<p>
Exemplo de uso no OpenBSD 4.0 e versões anteriores:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
Isso permite qualquer tráfego TCP saindo pela interface <tt>fxp0</tt>,
bem como o tráfego retornando em resposta ao firewall. Além do recurso
de manter estado ser uma excelente característica, seu uso ainda
melhora o desempenho do firewall, pois pesquisas na tabela de estados
são muito mais rápidas do que passar o pacote por todas as regras de
filtragem.

<p>
A opção <tt>modulate state</tt> funciona como a <tt>keep state</tt>,
exceto que ela se aplica apenas a pacotes TCP. Com
<tt>modulate state</tt>, o Número de Sequência Inicial
de conexões saindo do firewall é aleatório.
Isso é útil para proteger conexões iniciadas por certos
sistemas operacionais que não fazem um bom trabalho ao escolher ISNs.
Desde o OpenBSD 3.5, a opção <tt>modulate state</tt> pode ser usada
também em regras que especifiquem protocolos diferentes do TCP.

<p>
Para manter o estado em pacotes TCP, UDP e ICMP, e modular ISNs TCP:
<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Outra vantagem de se manter o estado é que o tráfego ICMP correspondente
também passa pelo firewall. Por exemplo, se existe uma conexão TCP
passando através do firewall, com o estado sendo mantido, e chega
uma mensagem de congestionamento ("source-quench") ICMP referenciando
esta conexão TCP, ela será correspondida à entrada apropriada na
tabela de estados e passará direto pelo firewall.

<p>
O escopo de uma entrada na tabela de estados é controlado globalmente
pela opção em tempo de execução
<a href="options.html#state-policy"><tt>state-policy</tt></a>
e ao nível de cada regra pelas palavras-chave de opções de estado
<tt>if-bound</tt> e <tt>floating</tt>.
Essas palavras-chave usadas nas regras têm o mesmo efeito de
quando são usadas na opção <tt>state-policy</tt>. Exemplo:

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Essa regra define que para um pacote corresponder à entrada na tabela de
estados, ele deve estar transitando na interface <tt>fxp0</tt>.


<p>
Perceba que para regras
<a href="nat.html"><tt>nat</tt></a>,
<a href="nat.html#binat"><tt>binat</tt></a> e
<a href="rdr.html"><tt>rdr</tt></a> é implícita
a criação de estados para conexões válidas desde que os pacotes tenham
passado pelo conjunto de regras de filtragem.

<a name="udpstate"></a>
<h2>Mantendo o Estado Para UDP</h2>
Algumas vezes você pode ouvir que: "Não se pode criar estados para
conexões UDP, pelo fato do UDP ser um protocolo que não mantém o
estado das conexões!". Enquanto é verdade que uma sessão de
comunicação UDP não possui nenhum conceito de estado (um início e fim
explícito na comunicação), isso não causa nenhum impacto na habilidade
do PF em criar estados para sessões UDP. No caso de protocolos sem
pacotes de "início" e "fim", o PF simplesmente mantém um registro do
tempo desde a última ocorrência de um pacote para dada conexão. Caso
o tempo de expiração seja atingido, o registro de estado é eliminado.
Valores para esse intervalo podem ser definidos na seção de
<a href="options.html">opções</a> do arquivo <tt>pf.conf</tt>.

<a name="stateopts"></a>
<h2>Opções de Rastreamento de Estado</h2>
Regras de filtragem que criam entradas na tabela de estados podem
especificar várias opções para controlar o comportamento resultante
da criação de estado.
As seguintes opções estão disponíveis:

<dl>
<dt><tt>max <i>número</i></tt>
<dd>Limita o número máximo de entradas de estado que a regra pode
criar para <i>número</i>.
Se o máximo for alcançado, pacotes que normalmente criariam estados
falham na correspondência à regra até que o número de estados existentes
diminua abaixo do limite.

<dt><tt>no state</tt>
<dd>Previne a regra de criar automaticamente uma entrada na tabela de
estados.

<dt><tt>source-track</tt>
<dd>Essa opção habilita o rastreamento do número de estados criados
por endereço IP de origem.
Essa opção tem dois formatos:
       <ul>
       <li><tt>source-track rule</tt> - O número máximo de estados
           criados por essa regra é limitado pelas opções
           <tt>max-src-nodes</tt> e <tt>max-src-states</tt>
           da regra. Somente entradas de estado criadas por essa regra
           em particular conta para os limites da regra.
       <li><tt>source-track global</tt> - O número de estados criados
           por todas as regras que usam essa opção é limitado.
           Cada regra pode especificar diferentes opções
           <tt>max-src-nodes</tt> e <tt>max-src-states</tt>,
           no entanto, entradas de estado criadas por qualquer regra
           participante conta para os limites individuais da regra.
       </ul>
O número total de endereços IP de origem rastreados globalmente pode
ser controlado pela
<a href="options.html#limit">opção em tempo de execução <tt>src-nodes</tt></a>.

<dt><tt>max-src-nodes <i>número</i></tt>
<dd>Quando a opção <tt>source-track</tt> é usada,
<tt>max-src-nodes</tt> limita o número de endereços IP de origem que
podem criar estados simultaneamente.
Essa opção só pode ser usada com <tt>source-track rule</tt>.

<dt><tt>max-src-states <i>número</i></tt>
<dd>Quando a opção <tt>source-track</tt> é usada,
<tt>max-src-states</tt> limita o número de estados simultâneos que podem
ser criados por endereço IP de origem.
O escopo desse limite (ou seja, estados criados por somente essa regra
ou estados criados por todas as regras que usam  <tt>source-track</tt>)
é dependente da opção <tt>source-track</tt> especificada.
</dl>

<p>
Opções são especificadas dentro de parêntesis e imediatamente depois
de uma das palavras-chave de estado (<tt>keep state</tt>,
<tt>modulate state</tt> ou <tt>synproxy state</tt>).
Múltiplas opções são separadas por vírgulas.
No OpenBSD 4.1 e versões recentes, a opção <tt>keep state</tt> se tornou
o padrão implícito para todas as regras de filtragem.
Apesar disso, quando se especifica opções de manter estado, uma
das palavras-chave deve ainda ser usada antes das opções.


<p>
Uma regra de exemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max 200, source-track rule, max-src-nodes 100,
max-src-states 3)
</tt>
</blockquote>

<p>
A regra acima define o seguinte comportamento:

<ul>
<li>Limita o número máximo de estados que essa regra pode criar para 200
<li>Habilita o rastreamento por origem; limita a criação de estados
    baseando-se em estados criados apenas por essa regra
<li>Limita o número máximo de nós que podem criar estados
    simultaneamente para 100
<li>Limita o número máximo de estados simultâneos por
    IP de origem para 3
</ul>

<p>
Um conjunto separado de restrições pode ser colocado em conexões TCP,
com o estado mantido, que completaram o aperto de mão triplo
("3-way handshake").

<dl>
<dt><tt>max-src-conn <i>número</i></tt>
<dd>Limita o número máximo de conexões TCP simultâneas, que completaram
o aperto de mão triplo, que uma única máquina pode fazer.
<dt><tt>max-src-conn-rate <i>número</i> / <i>intervalo</i></tt>
<dd>Limita a taxa de novas conexões a uma certa quantidade por
intervalo de tempo.
</dl>

<p>
Ambas as opções chamam automaticamente a opção
<tt>source-track rule</tt> e são incompatíveis com
<tt>source-track global</tt>.

<p>
Uma vez que esses limites são colocados em conexões TCP que completaram
o aperto de mão triplo, ações mais agressivas podem ser tomadas em
endereços IP ofensivos.

<dl>
<dt><tt>overload &lt;<i>tabela</i>&gt;</tt>
<dd>Coloca um endereço IP de uma máquina ofensiva na tabela nomeada.
<dt><tt>flush [global]</tt>
<dd>Mata qualquer outro estado que corresponda à regra e que foi
criado por esse IP de origem.
Quando <tt>global</tt> é especificado, mata todos os estados que
correspondam a esse IP de origem, sem levar em consideração qual regra
criou o estado.
</dl>

<p>
Um exemplo:

<blockquote>
<tt>
table &lt;abusive_hosts&gt; persist<br>
block in quick from &lt;abusive_hosts&gt;<br>
<br>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www flags S/SA keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max-src-conn 100, max-src-conn-rate 15/5,
overload &lt;abusive_hosts&gt; flush)
</tt>
</blockquote>

<p>
Isso faz o seguinte:

<ul>
<li>Limita o número máximo de conexões por origem para 100
<li>Limita a taxa de número de conexões para 15, em medições de
    5 segundos
<li>Coloca o endereço IP de qualquer máquina que quebre esses limites na
    tabela <tt>&lt;abusive_hosts&gt;</tt>
<li>Para qualquer endereço IP ofensivo, libera quaisquer estados criados
    por essa regra.
</ul>

<a name="tcpflags"></a>
<h2>Sinalizadores TCP</h2>
Comparar pacotes TCP com base em seus sinalizadores é geralmente usado
na filtragem de pacotes que tentam abrir novas conexões.
Os sinalizadores TCP e seus significados são listados aqui:
<ul>
<li><b>F</b> : FIN  - "Finish" (Fim); término da sessão
<li><b>S</b> : SYN  - "Synchronize" (Sincronização); indica a requisição
    de conexão
<li><b>R</b> : RST  - "Reset" (Reconfiguração); derruba uma conexão
<li><b>P</b> : PUSH - "Push" (Passar adiante); o pacote é enviado
    imediatamente
<li><b>A</b> : ACK  - "Acknowledgement" (Reconhecimento)
<li><b>U</b> : URG  - "Urgent" (Urgente)
<li><b>E</b> : ECE  - "Explicit Congestion Notification Echo" (Mensagem
    de Notificação de Congestionamento Explícita)
<li><b>W</b> : CWR  - "Congestion Window Reduced" (Janela de
    Congestionamento Reduzida)
</ul>

<p>
Para que o PF inspecione os sinalizadores TCP durante a avaliação de uma
regra, a palavra-chave <tt>flags</tt> é usada com a seguinte sintaxe:
<blockquote>
<tt>
flags <i>a_verificar</i>/<i>máscara</i><br>
flags any
</tt>
</blockquote>

<p>
A parte <tt><i>máscara</i></tt> diz ao PF para verificar apenas os
sinalizadores indicados, e a parte <tt><i>a_verificar</i></tt> informa
o(s) sinalizador(s) que deve(m) estar "ligado(s)" no cabeçalho para que
o pacote corresponda à regra.
O uso da palavra-chave <tt>any</tt> permite que qualquer combinação de
sinalizadores esteja definida no cabeçalho.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
</tt>
</blockquote>

<p>
A regra acima autoriza tráfego TCP com o sinalizador SYN definido, mas
verifica somente os sinalizadores SYN e ACK. Um pacote com os
sinalizadores SYN e ECE corresponderia à regra acima, enquanto um pacote
com SYN e ACK ou somente ACK não corresponderia.

<p>
No OpenBSD 4.1 e versões recentes, os sinalizadores aplicados por padrão
nas regras TCP são <tt>flags S/SA</tt>.
Combinando com o padrão do OpenBSD 4.1 de "<tt>keep state</tt>" (manter
o estado) nas regras de filtragem, estas duas regras se tornaram
equivalentes:
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state<br>
pass out on fxp0 proto tcp all
</tt>
</blockquote>

<p>
Cada regra corresponde à pacotes TCP com o sinalizador SYN marcado
e o sinalizador ACK desmarcado, e cada uma cria um estado para os
pacotes que corresponderam.
Os sinalizadores padrão podem ser sobrescritos usando a opção
<tt>flags</tt> conforme descrito acima.

<p>
No OpenBSD 4.0 e versões anteriores, não existiam sinalizadores padrão
aplicados a nenhuma regra de filtragem.
Cada regra tinha que especificar qual(is) sinalizador(es) corresponder,
e também tinha que explicitar o uso da opção <tt>keep state</tt>.
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>

<p>
Deve-se tomar cuidado ao usar sinalizadores -- entenda o que você está
fazendo e o porquê, e tenha cuidado com conselhos dados pelos outros,
pois grande parte deles são incorretos. Algumas pessoas sugerem a
criação de estado "somente se o sinalizador SYN estiver marcado, e
nenhum outro". Essa regra deve ficar assim:
<pre>
     . . . flags S/FSRPAUEW  <i>má ideia!!</i>
</pre>

<p>
A teoria é criar estado apenas no início da sessão TCP, e a sessão
deve ser iniciada somente com um sinalizador SYN, e nenhum outro.
O problema é que alguns lugares estão começando a usar o
sinalizador ECN, e qualquer um que use ECN e tente se conectar ao seu
servidor seria rejeitado por essa regra. Uma abordagem muito melhor
seria não especificar sinalizador nenhum e deixar o PF aplicar os
sinalizadores padrão nas suas regras.
Se você realmente necessita de especificar os sinalizadores você mesmo,
então esta combinação seria segura:
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
Além de ser prático e seguro, também não é necessário verificar os
sinalizadores FIN e RST caso o tráfego passe antes por regras de
<!--XXX scrub-->
scrub. No processo de normalização o PF descarta quaisquer pacotes que
cheguem com combinações de sinalizadores TCP inválidas (como SYN e RST)
e normaliza combinações ambíguas em potencial (como SYN e FIN).


<a name="synproxy"></a>
<h2>Proxy de Pacotes TCP SYN</h2>
<p>
Normalmente quando um cliente inicia uma conexão TCP com o servidor,
o PF transfere os pacotes de
<a href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml"
>aperto de mão ("handshake")</a>
da forma como eles vieram. O PF, porém, possui a habilidade de fazer
proxy no aperto de mão. Com o uso de proxy no aperto de mão, o próprio
PF completa o aperto de mão com o cliente, inicia um aperto de mão com
o servidor, e então transfere pacotes entre os dois.
O benefício desse procedimento é que nenhum pacote é enviado ao servidor
antes do cliente completar o aperto de mão.
Isso evita que ataques de inundação de pacotes TCP SYN falsificados
atinjam o servidor porque uma conexão falsificada não conseguirá
completar o aperto de mão.

<p>
O proxy de pacotes TCP SYN é habilitado usando as palavras-chave
<tt>synproxy state</tt> em regras de filtragem. Exemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
Aqui as conexões para o servidor Web passarão pelo proxy TCP do PF.

<p>
Pela forma como o <tt>synproxy state</tt> funciona, ele também inclui as
mesmas funcionalidades de <tt>keep state</tt> e <tt>modulate state</tt>.

<p>
O proxy de pacotes SYN não funciona caso o PF esteja atuando em uma
ponte
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a>).

<a name="antispoof"></a>
<h2>Bloqueio de Pacotes Falsificados</h2>
"Spoofing" (dissimulação, falsificação) é quando um usuário malicioso
falsifica o endereço IP de origem nos pacotes transmitidos por ele para
esconder seu endereço real ou personificar outro nó na rede. Uma vez
que o usuário tenha falsificado seu endereço, ele pode lançar um ataque
na rede sem que sua verdadeira origem seja descoberta, ou ainda tentar
ganhar acesso a serviços restritos a determinados endereços IP.

<p>
O PF oferece uma proteção contra falsificações através do uso da
palavra-chave <tt>antispoof</tt>:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>fam_de_end</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Especifica que os pacotes que correspondam à regra devem ser
registrados via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.6"
>pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Caso um pacote corresponda à regra, ela é considerada a regra
"vencedora" e a avaliação do conjunto de regras termina.

<dt><tt><i>interface</i></tt>
<dd>A interface de rede onde ativar a proteção contra falsificações.
Pode ser também uma <a href="macros.html#lists">lista</a> de interfaces.

<dt><tt><i>fam_de_end</i></tt>
<dd>A família de endereços onde se deve ativar a proteção
contra falsificações, <tt>inet</tt> para IPv4 ou
<tt>inet6</tt> para IPv6.
</dl>

<p>
Exemplo:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Quando um conjunto de regras é carregado, quaisquer ocorrências da
palavra-chave <tt>antispoof</tt> são expandidas em duas regras de
filtragem.
Assumindo que a interface <tt>fxp0</tt> possui o endereço IP 10.0.0.1 e
a máscara de sub-rede 255.255.255.0 (ou seja, /24), a regra
<tt>antispoof</tt> acima expandiria para:

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Essas regras fazem duas coisas:
<ul>
<li>Bloqueia todo tráfego vindo da rede 10.0.0.0/24 que <i>não</i> venha
    por <tt>fxp0</tt>. Como a rede 10.0.0.0/24 está na interface
    <tt>fxp0</tt>, pacotes com endereço de origem nesse bloco de rede
    jamais devem ser vistos em qualquer outra interface.
<li>Bloqueia todo tráfego vindo de 10.0.0.1, o endereço IP em
    <tt>fxp0</tt>. A máquina nunca deve enviar pacotes para ela mesma
    pela interface externa, portanto qualquer pacote chegando com
    endereço de origem da própria máquina deve ser considerado
    malicioso.
</ul>

<p>
<b>NOTA</b>: As regras de filtragem <tt>antispoof</tt> expandidas
também bloquearão pacotes enviados pela interface de loopback para
o endereço local.
Recomenda-se evitar qualquer tipo de filtragem na interface de
loopback, mas isso se torna uma necessidade quando usamos regras
contra falsificações:
<blockquote>
<tt>
set skip on lo0<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
O uso de <tt>antispoof</tt> deve ser restrito à interfaces que possuam
um endereço IP. Usar <tt>antispoof</tt> em uma interface sem um endereço
IP resulta em regras como:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Nessas regras existe o risco de se bloquear <i>todo</i> o tráfego
de entrada em <i>todas</i> as interfaces.

<a name="urpf"></a>
<h2>Unicast Reverse Path Forwarding</h2>

<p>
A partir do <a href="../../../40.html">OpenBSD 4.0</a>, o PF oferece o
recurso de "Unicast Reverse Path Forwarding" (uRPF).
Quando um pacote passa por uma verificação uRPF, o endereço
de origem do pacote é procurado na tabela de roteamento.
Se a interface de saída encontrada na entrada da tabela de roteamento
é a mesma que a interface que o pacote está chegando, então a
verificação uRPF libera a passagem do pacote.
Se as interfaces não correspondem, então é possível que o pacote teve
seu endereço de origem falsificado.

<p>
A verificação uRPF pode ser feita nos pacotes usando a palavra-chave
<tt>urpf-failed</tt> nas regras de filtragem:

<blockquote>
<tt>
block in quick from urpf-failed label uRPF
</tt>
</blockquote>

<p>
Note que a verificação uRPF somente faz sentido em um ambiente onde
as rotas são simétricas.

<p>
uRPF fornece a mesma funcionalidade das regras
<a href="#antispoof">antispoof</a>.

<a name="osfp"></a>
<h2>Detecção Passiva de Sistema Operacional</h2>

<p>
"Passive OS Fingerprinting" (OSFP) é um método para identificar de
maneira passiva o sistema operacional de uma máquina remota com
base em certas características dos pacotes TCP SYN gerados pela máquina.
Essa informação pode então ser usada como critério em regras de
filtragem.

<p>
O PF determina o sistema operacional remoto comparando as
características do pacote TCP SYN contra um
<a href="options.html#fingerprints">arquivo de impressões digitais</a>,
que por padrão é o
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.6"
><tt>/etc/pf.os</tt></a>.
Quando o PF está habilitado, a lista atual de impressões digitais pode
ser vista com o comando:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Em uma regra de filtragem, a impressão digital pode ser especificada
pela classe do SO, versão ou subtipo/revisão.
Cada um dos itens é listado na saída do comando <tt>pfctl</tt>
mostrado acima. Para especificar uma impressão digital em uma regra
de filtragem, a palavra-chave <tt>os</tt> é usada:

<blockquote>
<tt>
pass &nbsp;in on $ext_if from any os OpenBSD keep state<br>
block in on $ext_if from any os "Windows 2000"<br>
block in on $ext_if from any os "Linux 2.4 ts"<br>
block in on $ext_if from any os unknown
</tt>
</blockquote>

<p>
A classe de sistema operacional <tt>unknown</tt> permite o enquadramento
de pacotes quando a impressão digital do SO não é conhecida.

<p>
<font color="#ff0000">TOME NOTA</font>:
<ul>
  <li>Impressões digitais de sistemas operacionais ocasionalmente
      podem estar erradas, devido à pacotes falsificados e/ou
      trabalhados para que pareçam-se originados de um
      sistema operacional em específico.
  <li>Determinadas revisões ou níveis de correção de um sistema
      operacional podem alterar o comportamento da pilha, fazendo com
      que ela não corresponda à impressão digital do arquivo ou até
      mesmo fique igual a de outro.
  <li>OSFP funciona apenas com pacotes TCP SYN; ele não funciona com
      outros protocolos ou em conexões já estabelecidas.
</ul>

<a name="ipopts"></a>
<h2>Opções IP</h2>
Por padrão, o PF bloqueia pacotes com opções IP definidas. Isso pode
dificultar o trabalho de ferramentas de "detecção de sistema
operacional", como o nmap. Caso você possua algum aplicativo que faça
uso desses pacotes, como multicast ou IGMP, você pode usar a diretiva
<tt>allow-opts</tt>:
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Exemplo de Conjunto de Regras de Filtragem</h2>
Abaixo está um exemplo de conjunto de regras de filtragem. A máquina
executando o PF funciona como firewall entre uma pequena rede interna
e a Internet. São mostradas apenas as regras de filtragem; regras de
<a href="queueing.html">enfileiramento</a>,
<a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>,
etc., foram deixadas de fora deste exemplo.
<br>
<br>
<table border="0" width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# Tabela contendo todos os endereços IP atribuídos ao firewall
table &lt;firewall&gt; const { self }

# Não filtra na interface loopback
set skip on lo0

# Faz scrub em pacotes que chegam
match in all scrub (no-df)

# Define a política "negar por padrão"
block all

# Ativa a proteção contra falsificações para todas as interfaces
block in quick from urpf-failed

# Permite conexões ssh vindas apenas da rede interna e se forem
# de um computador confiável, 192.168.0.15. "block return" faz com que
# um pacote TCP RST seja enviado para derrubar conexões bloqueadas.
# "quick" assegura que esta regra não seja invalidada por alguma
# regra "pass" abaixo.
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh

# Permite tráfego indo para e vindo da rede interna.
# Estas regras criam entradas na tabela de estados devido
# à opção padrão "keep state" que é aplicada automaticamente.
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net

# Permite tráfego tcp, udp e icmp saindo pela interface externa (Internet).
# Conexões tcp serão moduladas, udp/icmp manterão o estado.
pass out on $ext_if proto { tcp udp icmp } all modulate state

# Permite conexões ssh na interface externa contanto que NÃO sejam
# destinadas ao firewall (ou seja, conexões destinadas à máquinas na
# rede local). Registra o pacote inicial para que mais tarde possamos
# saber quem tentou se conectar. Usa o tcp syn proxy nas conexões.
# Os sinalizadores "S/SA" padrão serão aplicados automaticamente na
# regra pelo PF.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
   port ssh synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Anterior: Tabelas</a>]
[<a href="index.html">Conteúdo</a>]
[<a href="nat.html">Próximo: Tradução do Endereço de Rede (NAT)</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[voltar]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: filter.html,v 1.53 ]<br>
$Translation: filter.html,v 1.16 2009/11/30 09:29:57 alan Exp $<br>
-->
$OpenBSD: filter.html,v 1.16 2009/11/30 13:23:49 ajacoutot Exp $
</small>

</body>
</html>

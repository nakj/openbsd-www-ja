<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF : Redirection de Trafic ("Forwarding"
            de Ports)</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003, Nick Holland <nick@openbsd.org>
Copyright (c) 2003-2005, Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../fr/index.html">
<img alt="[OpenBSD]" height="30" width="141" src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="nat.html">Précédent : Traduction d'Adresses
Réseau</a>]
[<a href="index.html">Index</a>]
[<a href="shortcuts.html">Suivant : Raccourcis pour la Création
de Jeux de Règles</a>]

<h1><font color="#e00000">PF : Redirection de Trafic ("Forwarding" de
    Ports)</font></h1>

<hr>

<h3>Table des Matières</h3>
<ul>
<li><a href="#intro">Introduction</a>
<li><a href="#filter">Redirection et Filtrage de Paquets</a>
<li><a href="#security">Implications au niveau de la
    Sécurité</a>
<li><a href="#reflect">Redirection et Réflexion</a>
        <ul>
        <li><a href="#splitdns">DNS en "Split-Horizon"</a>
        <li><a href="#sepnet">Déplacer le Serveur Vers un
            Réseau Local Séparé</a>
        <li><a href="#tcpproxy">Mandater les Connexions TCP ("TCP
            Proxying")</a>
        <li><a href="#rdrnat">Combinaison RDR et NAT</a>
        </ul>
</ul>

<hr>

<a name="intro"></a>
<h2>Introduction</h2>
Quand vous utilisez la NAT, les machines sur votre réseau peuvent
accéder à la totalité des ressources Internet. Qu'en est-il lorsqu'une
de vos machines derrière la passerelle NAT a besoin d'être accédée
depuis Internet ? la redirection est utilisée pour résoudre ce genre de
problèmes. Elle permet au trafic entrant d'être acheminé vers une
machine derrière la passerelle NAT.

<p>
Prenons un exemple :
<blockquote>
<tt>
rdr on tl0 proto tcp from any to any port 80 -&gt; 192.168.1.20
</tt>
</blockquote>

<p>
La ligne ci-dessus redirige le trafic à destination du port TCP 80
(serveur web) vers une machine sur le réseau d'adresse IP 192.168.1.20.
Ainsi, même si cette machine est derrière votre passerelle, le monde
externe peut y avoir accès.

<p>
La partie <tt>from any to any</tt> de la ligne <tt>rdr</tt> précitée
peut être assez utile. Si vous voulez restreindre les adresses ou les
sous-réseaux autorisés à avoir accès au serveur web sur le port 80, vous
pouvez le faire de la façon suivante :
<blockquote>
<tt>
rdr on tl0 proto tcp from 27.146.49.0/24 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20
</tt>
</blockquote>

<p>
Ceci aura pour effet de rediriger uniquement le trafic en provenance du
sous-réseau spécifié. Notez que cela implique la possibilité de
rediriger différentes machines en entrée vers des machines derrière la
passerelle. Une telle fonctionnalité est utile. Par exemple, vous pouvez
autoriser des utilisateurs sur des sites distants à accèder à leur
propre machine dans la mesure où vous connaissez leur adresse IP :
<blockquote>
<tt>
rdr on tl0 proto tcp from 27.146.49.14 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20<br>
rdr on tl0 proto tcp from 16.114.4.89 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.22<br>
rdr on tl0 proto tcp from 24.2.74.178 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.23
</tt>
</blockquote>

<p>
Une plage de ports peut aussi être redirigée par une même règle :
<blockquote>
<tt>
rdr on tl0 proto tcp from any to any port 5000:5500 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20<br>
rdr on tl0 proto tcp from any to any port 5000:5500 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20 port 6000<br>
rdr on tl0 proto tcp from any to any port 5000:5500 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20 port 7000:*<br>
</tt>
</blockquote>

<p>
Les exemples précédents permettent de rediriger tout port entre 5000 et
5500 inclus vers 192.168.1.20.
Dans la première règle, on a une correspondance de ports 1 à 1. Ainsi le
port 5000 est redirigé vers le port 5000 de la machine destination, le
port 5001 est redirigé vers le port 5001 et ainsi de suite.
Dans la deuxième règle, la plage de ports toute entière est redirigée
vers le port 6000.
Enfin, dans la troisième règle, le port 5000 est redirigé vers le port
7000, 5001 vers 7001 et ainsi de suite.

<a name="filter"></a>
<h2>Redirection et Filtrage de Paquets</h2>
<font color="#ff0000">REMARQUE :</font> Les paquets redirigés doivent
encore être autorisés par le moteur de filtrage. Ils seront bloqués ou
autorisés selon les règles de filtrage qui ont été définies.

<p>
La <i>seule</i> exception à cette règle est lorsque le mot-clé
<tt>pass</tt> est utilisé dans la règle <tt>rdr</tt>. Dans ce cas, les
paquets redirigés passeront à travers le moteur de filtrage et l'état de
connexion sera préservé : Les règles de filtrage ne seront pas
considérées pour ces paquets.
Ceci est un raccourci utile pour éviter de rajouter des règles de
filtrage <tt>pass</tt> pour chaque règle de redirection.
Il faut voir cela comme une règle <tt>rdr</tt> normale (sans mot-clé
<tt>pass</tt>) associée à une règle de filtrage <tt>pass</tt> avec le
mot-clé <tt>keep state</tt>. Cependant, si vous voulez mettre en oeuvre
des options de filtrage spécifiques telles que <tt>synproxy</tt>,
<tt>modulate state</tt>, etc... vous devrez utiliser une règle de filtrage
<tt>pass</tt> dédiée étant donné que ces options ne sont pas
implémentées au niveau des règles de redirection.

<p>
Notez aussi que la traduction est effectuée <i>avant</i> le filtrage. Le
moteur de filtrage verra le paquet <i>traduit</i>, c'est à dire après que son
adresse IP destination et/ou port de destination soient modifiés pour
correspondre à l'adresse/au port de redirection spécifié(e) dans la
règle <tt>rdr</tt>. Considérons le cas suivant :
<ul>
<li>192.0.2.1 - hôte sur Internet
<li>24.65.1.13 - adresse IP externe du routeur OpenBSD
<li>192.168.1.5 - adresse IP interne du serveur web
</ul>

<p>
Règle de redirection :
<blockquote>
<tt>
rdr on tl0 proto tcp from 192.0.2.1 to 24.65.1.13 port 80 \<br>
&nbsp;&nbsp;&nbsp;-&gt; 192.168.1.5 port 8000
</tt>
</blockquote>

<p>
Avant que la règle de redirection <tt>rdr</tt> ne soit utilisée, le paquet est
traité :

<ul>
<li>Adresse source : 192.0.2.1
<li>Port source : 4028 (choisi de manière arbitraire par le système
    d'exploitation)
<li>Adresse de destination : 24.65.1.13
<li>Port de destination : 80
</ul>

<p>
Puis la règle de redirection <tt>rdr</tt> est évaluée :
<ul>
<li>Adresse source : 192.0.2.1
<li>Port source : 4028
<li>Adresse de destination : 192.168.1.5
<li>Port de destination : 8000
</ul>

<p>
Le moteur de filtrage verra le paquet IP tel qu'il apparaît après la
traduction effectuée par le mécanisme de redirection.

<a name="security"></a>
<h2>Implications au niveau de la Sécurité</h2>
La redirection a des implications au niveau de la sécurité. La création
d'une ouverture pour autoriser le trafic à destination du réseau interne
protégé peut causer la compromission d'une machine sur ce dernier. Par
exemple, si le trafic est redirigé vers un serveur web interne et que
par malheur, une vulnérabilité est découverte dans le service web ou
dans un script CGI executé par le serveur, alors la machine peut être
compromise par un utilisateur distant. Une fois cette compromission
réalisée, l'utilisateur malveillant peut rebondir à partir de cette
machine vers le réseau interne ce qui, bien entendu, ne peut être bloqué
par le pare-feu étant donné qu'il ne voit pas ce trafic.

<p>
Ces risques peuvent être minimisés en confinant de manière stricte le
système accédé depuis l'extérieur à un réseau séparé. Ce réseau est
souvent appelé zone démilitarisée (DMZ) ou réseau de service privé
(Private Service Network, PSN). De cette façon, si le serveur web est
compromis, les effets peuvent être limités au réseau DMZ/PSN en filtrant
soigneusement le trafic autorisé entre DMZ/PSN et vos autres réseaux.

<a name="reflect"></a>
<h2>Redirection et Réflexion</h2>
Souvent, les règles de redirection sont utilisées pour faire suivre des
connexions Internet entrantes à un serveur local disposant d'une adresse
privée sur le réseau interne comme le montre l'exemple suivant :
<blockquote>
<tt>
server = 192.168.1.40<br>
<br>
rdr on $ext_if proto tcp from any to $ext_if port 80 -&gt; $server \<br>
&nbsp;&nbsp;&nbsp;port 80
</tt>
</blockquote>

<p>
Mais lorsque la règle de redirection est testée par un client du LAN,
elle ne fonctionne pas. C'est normal car les règles de redirection ne
s'appliquent qu'aux paquets qui passent à travers l'interface spécifiée
dans chacune d'elles (dans l'exemple précité, c'est l'interface externe
<tt>$ext_if</tt>). Cependant, une connexion émanant d'un client interne
et à destination de l'adresse externe du pare-feu n'implique pas que les
paquets vont passer à travers l'interface externe du pare-feu. La pile
TCP/IP sur le pare- feu compare l'adresse de destination des paquets
entrants avec ses propres adresses et aliases et détecte les connexions
qui lui sont destinées lorsque les paquets constituant celles-ci passent
son interface interne. De tels paquets ne passent pas physiquement à
travers l'interface externe, et de toute façon la pile ne simule pas ce
passage. Ainsi, PF ne voit jamais ces paquets sur l'interface externe.
Du coup, la règle de redirection sur l'interface externe n'est jamais
appliquée.

<p>
Que doit-on faire alors ? ajouter une seconde règle de redirection sur
l'interface interne ? non, ça ne fonctionnera pas mieux. Lorsque le
client local se connecte à l'interface externe du pare-feu, le paquet
initial de l'échange TCP atteint le pare-feu via son interface interne.
La nouvelle règle de redirection s'applique et l'adresse de destination
est remplacée par celle du serveur interne. Le paquet et alors redirigé
par l'interface interne du pare-feu vers le serveur interne. Mais
l'adresse source n'a pas été modifiée. Elle contient l'adresse du client
local. Le serveur envoie alors directement les réponses au client. Le
pare-feu ne voit jamais le retour et n'a aucune chance de traduire
correctement les paquets de retour. Le client reçoit une réponse à
partir d'une source inattendue. Il met alors fin à cette connexion.

<p>
Cependant, il est souvent souhaitable que les clients sur le LAN se
connectent au même serveur interne que les clients externes et de
manière aussi transparente. Il existe plusieurs solutions à ce problème
:

<a name="splitdns"></a>
<h3>DNS en "Split-Horizon"</h3>

<p>
Il est possible de configurer les serveurs DNS pour fournir une réponse
différente selon la provenance de la requête : clients internes ou
externes. Ainsi les clients internes recevront l'adresse interne du
serveur en réponse à leur demande de résolution de nom. Ils pourront
alors se connecter directement au serveur local sans impliquer le pare-feu. 
Ce dernier sera alors moins sollicité.

<a name="sepnet"></a>
<h3>Déplacer le Serveur Vers un Réseau Local Séparé</h3>

<p>
Une autre solution consiste à ajouter une carte réseau au pare-feu et à
déplacer le serveur local vers un réseau dédié de type DMZ. Les
connexions des clients locaux seront alors redirigées de la même manière
que les connexions en provenance d'Internet. L'utilisation de réseaux
séparés a plusieurs avantages. Entre autres, une amélioration du niveau
de sécurité en isolant le serveur des machines internes. Si le serveur
(qui, nous le rappelons, est joignable à partir d'Internet) est
compromis, il ne peut se connecter à des machines internes directement
vu que toutes ces connexions doivent passer à travers le pare-feu.

<a name="tcpproxy"></a>
<h3>Mandater les Connexions TCP ("TCP Proxying")</h3>

<p>
Un mandataire TCP générique peut être mis en place sur le pare-feu. Ce
mandataire devra écouter sur le port de redirection ou accepter les
connexions sur l'interface interne et redirigées sur le port sur lequel
il écoute. Lorsqu'un client se connecte sur le pare-feu, le mandataire
accepte la connexion, établit une seconde connexion au serveur interne,
et véhicule les données entre les deux connexions.

<p>
Des mandataires simples peuvent être crées avec 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8"
>inetd(8)</a> et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nc&amp;sektion=1"
>nc(1)</a>.
L'entrée suivante dans le fichier <tt>/etc/inetd.conf</tt> crée une
socket d'écoute rattachée à l'adresse de loopback (127.0.0.1) et le port
5000. Les connexions sont redirigées sur le port 80 du serveur
192.168.1.10.
La redirection est faite avec l'utilisateur "proxy".
<blockquote>
<tt>
127.0.0.1:5000 stream tcp nowait proxy /usr/bin/nc nc -w \<br>
&nbsp;&nbsp;&nbsp;20 192.168.1.10 80
</tt>
</blockquote>

<p>
La règle de redirection suivante redirige le port 80 sur l'interface
interne du mandataire :
<blockquote>
<tt>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;127.0.0.1 port 5000
</tt>
</blockquote>

<a name="rdrnat"></a>
<h3>Combinaison RDR et NAT</h3>

<p>
A l'aide d'une règle NAT supplémentaire sur l'interface interne, la
traduction manquante d'adresse source décrite plus haut peut être
réalisée.
<blockquote>
<tt>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;$server
<br>
no nat on $int_if proto tcp from $int_if to $int_net<br>
nat on $int_if proto tcp from $int_net to $server port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;$int_if
</tt>
</blockquote>

<p>
Ceci aura pour effet d'effectuer une autre traduction d'adresse du
paquet initial envoyé par le client lorsque celui-ci est redirigé à
travers l'interface interne. Cette seconde opération de traduction
remplacera l'adresse source du client par l'adresse interne du pare-feu.
Le serveur interne répondra alors à l'adresse interne du pare-feu, qui
effectuera les opérations de NAT et de RDR inverses avant de faire
suivre le paquet au client. Cette méthode est relativement complexe.
Elle crée deux états séparés pour chaque connexion redirigée. Il faut
prendre des précautions pour éviter que la règle de NAT ne s'applique au
reste du trafic tel que les connexions en provenance de hôtes externes
(via d'autres redirections) ou en provenance du pare-feu lui-même. La
règle <tt>rdr</tt> précitée soumettra à la pile TCP/IP des paquets en
provenance du réseau interne et à destination de ce dernier.

<p>
Nous recommandons cependant de privilégier plutôt les autres solutions
précédemment mentionnées.

<p>
[<a href="nat.html">Précédent : Traduction d'Adresses
Réseau</a>]
[<a href="index.html">Index</a>]
[<a href="shortcuts.html">Suivant : Raccourcis pour la Création
de Jeux de Règles</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: rdr.html,v 1.28 ]<br>
$Translation: rdr.html,v 1.25 2009/06/22 12:16:54 benoit Exp $<br>
-->
$OpenBSD: rdr.html,v 1.22 2009/06/29 17:19:48 ajacoutot Exp $
</small>

</body>
</html> 

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF : Gestion de La Bande Passante</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description" content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2005 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../fr/index.html">
<img alt="[OpenBSD]" height="30" width="141" src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="anchors.html">Précédent : Ancres</a>]
[<a href="index.html">Sommaire</a>]
[<a href="pools.html">Suivant : Ensembles d'adresses (&quot;Pools&quot;) et
Partage de Charge</a>]

<p>
<h1><font color="#e00000">PF : Gestion de La Bande Passante</font></h1>


<hr>

<h3>Table des Matières</h3>
<ul>
<li><a href="#queueing">Mise en queue</a>
<li><a href="#sched">Planificateurs</a>
 <ul>
 <li><a href="#cbq">Mise en queue par classes</a>
 <li><a href="#priq">Mise en queue par priorités</a>
 <li><a href="#red">Détection Aléatoire Anticipée</a>
 <li><a href="#ecn">Notification Explicite de Congestion</a>
 </ul>
<li><a href="#altq">Configuration de la Mise en queue</a>
<li><a href="#assign">Assignation du Trafic dans une Queue</a>
<li><a href="#example1">Exemple #1 : Réseau domestique</a>
<li><a href="#example2">Exemple #2 : Réseau d'entreprise</a>
</ul>

<hr>

<a name="queueing"></a>
<h2>Mise en queue</h2>
<p>
Mettre en queue quelque chose signifie stocker, de manière ordonnée,
cette chose pendant qu'elle attend un traitement. Dans un réseau
informatique, quand les paquets de données sont envoyés à l'extérieur de
l'hôte, ils entrent dans une queue où ils attendent un traitement par le
système d'exploitation. Celui-ci décide ensuite quelle queue et quel(s)
paquet(s) de cette queue doivent être traités. L'ordre dans lequel le
système d'exploitation sélectionne les paquets à traiter peut affecter
les performances du réseau. Par exemple, imaginez un utilisateur
lançant deux applications réseau : SSH et FTP. Idéalement, les paquets
SSH devraient être traités avant les paquets FTP à cause de la
sensibilité au temps de SSH; quand une clef est entrée dans le client
SSH, une réponse immédiate est attendue, mais un transfert FTP retardé
de quelques secondes n'attirera pratiquement pas l'attention. Mais que
se passe-t-il si le routeur manipulant ces connexions traite un grand
nombre de paquets provenant de la connexion FTP avant de traiter la
connexion SSH ? Les paquets de la connexion SSH resteront dans la queue
(ou seront rejetés par le routeur si la queue n'est pas assez grande
pour accueillir tous les paquets) et la session SSH apparaitra
certainement comme ralentie ou haletante. En modifiant la stratégie de
mise en queue utilisée, la bande passante du réseau peut être partagée
de façon juste entre les différents applications, utilisateurs et
ordinateurs.

<p>
Notez que la mise en queue est utile uniquement pour les paquets sortant
("<i>outbound</i>"). Une fois qu'un paquet arrive sur une interface dans
la direction entrante il est déjà trop tard pour le mettre en queue --
la bande passante a déjà été consommée et l'interface le reçoit
simplement. La seule solution est d'activer la mise en queue sur un
routeur adjacent ou, si l'hôte recevant le paquet agit comme un routeur,
d'activer la mise en queue sur l'interface interne sur laquelle les
paquets quittent le routeur.

<a name="sched"></a>
<h2>Planificateurs</h2>
L'algorithme décide des queues à traiter et dans quel ordre. Par défaut,
OpenBSD utilise un algorithme "First In First Out" (FIFO). Une queue
FIFO travaille comme une caisse de supermarché -- le premier article de
la queue est le premier traité. Au fur et à mesure que des nouveaux
paquets arrivent, ils sont ajoutés à la queue. Si la queue est pleine -
et c'est là que l'analogie avec la caisse de supermarché s'arrête - les
nouveaux paquets sont rejetés. Ceci est connu sous le nom de "tail-
drop".

<p>
OpenBSD supporte deux algorithmes additionnels :
<ul>
<li>Mise en queue par classes
<li>Mise en queue par priorités
</ul>

<a name="cbq"></a>
<h3>Mise en queue par classes</h3>
La Mise en queue par classes (CBQ) est un algorithme de mise en queue
qui divise la bande passante des multiples connexions réseau en queues
ou en classes. Chaque queue se voit ainsi assigner un trafic sur les
bases d'une adresse source ou de destination, d'un numéro de port, d'un
protocole, etc... Une queue peut optionnellement être configurée pour
emprunter de la bande passante aux queues parentes si celles-ci sont sous-
utilisées. Les queues ont aussi une priorité selon qu'elles contiennent
du trafic interactif, comme SSH, et peuvent avoir leurs paquets traités
avant les queues contenant le trafic volumineux, comme FTP.

<p>
Les queues CBQ sont ordonnées de manière hiérarchique. Au sommet de la
hiérarchie se trouve la queue "root" qui définit la totalité de la bande
passante disponible. Les queues enfant sont crées sous la queue "root",
chacune d'elle peut se voir assigner une partie de la bande passante de
la queue "root". Par exemple, les queues peuvent être définies comme
suit :

<dl>
<dd>Root Queue (2Mbps)
        <dl>
        <dd>Queue A (1Mbps)
        <dd>Queue B (500Kbps)
        <dd>Queue C (500Kbps)
        </dl>
</dl>

<p>
Dans ce cas, la totalité de la bande passante est fixée à 2 megabits par
seconde (Mbps). Cette bande passante est ensuite subdivisée en trois
queues enfant.

<p>
La hiérarchie peut encore être approfondie en définissant des queues
dans les queues. Pour subdiviser équitablement la bande passante entre
les différents utilisateurs et aussi classer leur trafic pour éviter que
certains protocoles ne privent de bande passante d'autres protocoles,
une structure de mise en queue comme celle-ci peut être définie :

<dl>
<dd>Root Queue (2Mbps)
        <dl>
        <dd>UserA (1Mbps)
                <dl>
                <dd>ssh (50Kbps)
                <dd>bulk (950Kbps)
                </dl>
        <dd>UserB (1Mbps)
                <dl>
                <dd>audio (250Kbps)
                <dd>bulk (750Kbps)
                        <dl>
                        <dd>http (100Kbps)
                        <dd>other (650Kbps)
                        </dl>
                </dl>
        </dl>
</dl>

<p>
Notez qu' à chaque niveau, la somme des bandes passantes assignées à
chaque queue ne doit pas être supérieure à celle assignée à la queue
parent.

<p>
Une queue peut être configurée pour emprunter de la bande passante aux
queues parent si ces dernières en ont en excès suite à la non-utilisation 
par d'autres queues enfant. Considérez le réglage de mise en queue suivant :

<dl>
<dd>Root Queue (2Mbps)
        <dl>
        <dd>UserA (1Mbps)
                <dl>
                <dd>ssh (100Kbps)
                <dd>ftp (900Kbps, borrow)
                </dl>
        <dd>UserB (1Mbps)
        </dl>
</dl>

<p>
Si le trafic dans la queue <tt>ftp</tt> excède 900Kbps et le trafic dans
la queue <tt>UserA</tt> est inférieur à 1Mbps (parce que la queue
<tt>ssh</tt> utilise moins que les 100Kbps qu'elle dispose), la queue
<tt>ftp</tt> empruntera l'excès de bande passante de <tt>UserA</tt>.
Dans cette optique la queue <tt>ftp</tt> est en mesure d'utiliser
davantage de bande passante que ce qui lui est assigné quand elle fait
face à une surcharge. Quand la queue <tt>ssh</tt> verra sa charge
augmenter, la bande passante empruntée sera restituée.

<p>
CBQ assigne une priorité à chaque queue. Les queues avec une priorité
élevée sont préférées aux queues avec une priorité inférieure pendant
une congestion tant que les deux queues partagent le même parent (en
d'autres termes, tant que les deux queues appartiennent à une même
branche de la hiérarchie). Les queues avec une même priorité sont
traitées dans un mode "round-robin". Par exemple :

<dl>
<dd>Root Queue (2Mbps)
        <dl>
        <dd>UserA (1Mbps, priority 1)
                <dl>
                <dd>ssh (100Kbps, priority 5)
                <dd>ftp (900Kbps, priority 3)
                </dl>
        <dd>UserB (1Mbps, priority 1)
        </dl>
</dl>

<p>
CBQ traitera les queues <tt>UserA</tt> et <tt>UserB</tt> dans un mode
"round-robin" -- aucune queue ne sera préférée à une autre. Pendant le
temps ou la queue <tt>UserA</tt> est traitée, CBQ traitera aussi les
queues enfant. Dans ce cas, la queue <tt>ssh</tt> a une priorité plus
élevée et aura un traitement préférentiel vis à vis de la queue
<tt>ftp</tt> si le réseau est congestionné. Notez que les queues
<tt>ssh</tt> et <tt>ftp</tt> n'ont pas leurs priorités comparées à
celles de <tt>UserA</tt> et <tt>UserB</tt> à cause du fait qu'elles ne
sont pas dans une même branche de la hiérarchie.

<p>
Pour un regard plus détaillé sur la théorie du fonctionnement de CBQ,
veuillez consulter les
<a href="http://www.icir.org/floyd/cbq.html">Références sur CBQ</a>.

<a name="priq"></a>
<h3>Mise en queue par priorités</h3>
La Mise en queue par priorités (PRIQ) assigne des queues à une interface
réseau et chaque queue possède une priorité. Une queue avec une priorité
plus élevée est <i>toujours</i> traitée avant une queue avec une
priorité moindre.
Si plusieurs queues ont la même priorité elles sont traitées en
"round-robin".

<p>
La structure des queues de PRIQ est plate -- vous ne pouvez pas définir
de queue au sein d'une autre queue. La queue "root" est définie et
possède la totalité de la bande passante disponible, et les sous-queues
sont définies ensuite en aval. Considérez l'exemple suivant :
<dl>
<dd>Root Queue (2Mbps)
        <dl>
        <dd>Queue A (priority 1)
        <dd>Queue B (priority 2)
        <dd>Queue C (priority 3)
        </dl>
</dl>

<p>
La queue "root" est définie comme ayant 2Mbps de bande passante
disponible et trois sous-queues sont définies. La queue avec la plus
haute priorité (le nombre priorité le plus grand) est servie en premier.
Une fois que tous les paquets dans cette queue ont été traités, ou si la
queue est vide, PRIQ s'occupe de la queue avec la priorité suivante. Au
sein d'une queue donnée, les paquets sont traités selon la manière
"First In First Out" (FIFO).

<p>
Il est important de noter que si vous utilisez PRIQ, vous devez créer
vos queues très prudemment. A cause du fait que PRIQ traite
<i>toujours</i> une queue avec une grande priorité avant une queue avec
une priorité basse, il est possible qu'une queue avec une priorité
élevée cause la suppression ou la disparition des paquets d'une queue
avec une priorité basse si la queue avec la priorité élevée reçoit un
flux constant de paquets.

<a name="red"></a>
<h3>Détection Aléatoire Anticipée</h3>
La Détection Aléatoire Anticipée (RED) est un algorithme d'évitement des
congestions. Sa fonction est d'éviter les congestions en s'assurant que
la queue ne devienne pas pleine. Elle réalise cela en calculant en
permanence la largeur moyenne (taille) de la queue et en la comparant à
deux valeurs de seuil, un seuil minimum et un seuil maximum. Si la
taille moyenne de la queue est au dessous du seuil minimal, aucun paquet
n'est rejeté. Si la moyenne est au dessus du seuil maximum alors
<i>tous</i> les nouveaux paquets arrivant sont rejetés. Si la moyenne
est comprise entre les seuils minimum et maximum les paquets sont
rejetés suivant une probabilité calculée grâce à la taille de la queue.
En d'autres mots, quand l'occupation de la queue approche le seuil
maximum, de plus en plus de paquets sont rejetés. Quand il rejete des
paquets, RED rejette aléatoirement la connexion pour laquelle il va
rejeter les paquets. Les connexions utilisant largement la bande
passante ont une plus grande probabilité de voir leurs paquets rejetés.

<p>
RED est utile car il évite la situation connue sous le nom de
synchronisation globale et il peut s'adapter à des bonds du trafic. La
synchronisation globale se réfère à une perte totale des données
sortantes due à la suppression simultanée de paquets de plusieurs
connexions. Par exemple, si la congestion apparait sur un routeur
supportant le trafic de 10 connexions FTP et tous les paquets de ces
connexions sont rejetés (comme c'est le cas avec une mise en queue
FIFO), la totalité du trafic sortant sera rejeté; brusquement. Ce n'est
pas une situation idéale car elle entraîne une réduction du trafic de
toutes les connexions FTP ce qui signifie que le réseau n'est plus
utilisé avec son potentiel maximum. RED évite cela en choisissant
aléatoirement une de ces connexions plutôt que de choisir toutes les
connexions. Les connexions utilisant une large partie de la bande
passante ont une probabilité supérieure de voir leurs paquets rejetés.
Dans cette optique, les connexions avec une haute bande passante seront
étranglées, la congestion sera évitée, et les pertes violentes de trafic
de sortie n'auront pas lieu. De plus, RED est capable de supporter des
explosions du trafic car il commence la suppression des paquets
<i>avant</i> que la queue ne devienne pleine. Si une explosion du trafic
se produit, il y aura assez d'espace pour mémoriser les nouveaux
paquets.

<p>
RED ne devrait être utilisé que quand le protocole est capable de
répondre aux indicateurs de congestion du réseau. Dans beaucoup de cas
cela signifie que RED devrait être utilisé pour mettre en queue du
trafic TCP et non du trafic UDP ou ICMP.

<p>
Pour un regard plus détaillé sur la théorie derrière RED, veuillez
consulter
<a href="http://www.icir.org/floyd/red.html">References on RED</a>.

<a name="ecn"></a>
<h3>Notification Explicite de Congestion</h3>
La Notification Explicite de Congestion (Early Congestion Notification
ou ECN) travaille en conjonction avec RED pour notifier deux hôtes
communicant via le réseau d'une congestion le long du chemin de
communication. Ceci est fait en autorisant RED à fixer un drapeau dans
l'entête du paquet plutôt que de rejeter le paquet. Si l'on part du
principe que l'hôte expéditeur supporte ECN, il pourra lire ce drapeau
et diminuer son trafic réseau en fonction.

<p>
Pour plus d'informations sur ECN, veuillez consulter
<a href="http://www.rfc-editor.org/rfc/rfc3168.txt">RFC 3168</a>.

<a name="altq"></a>
<h2>Configuration de la Mise en queue</h2>
Depuis OpenBSD 3.0 la
<a href="http://www.csl.sony.co.jp/person/kjc/kjc/software.html#ALTQ" >Mise en queue alternée (ALTQ)</a>, 
implémentation de la mise en queue, fait partie du système de base. En
commençant avec OpenBSD 3.3 ALTQ a été intégrée dans PF.
L'implémentation de ALTQ dans OpenBSD supporte les algorithmes de Mise
en Queue par classes (CBQ) et de Mise en Queue par priorités (PRIQ).
Elle supporte aussi la Détection Aléatoire Anticipée (RED) et la
Notification de Congestion Explicite (ECN).

<p>
Parce que ALTQ a été fusionnée avec PF, ce dernier doit être activé pour
que la mise en queue fonctionne. Les instructions sur la procédure
d'activation de PF peuvent être trouvées dans les
<a href="config.html#activate">Principes de base</a>.

<p>
La Mise en queue est configurée dans <tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.6"
>pf.conf</a></tt>.
Il y a deux types de directives utilisées pour configurer la Mise en
Queue :
<ul>
<li><tt>altq on</tt> - active la mise en queue sur une interface,
    définit l'algorithme à utiliser et créée la queue "root"
<li><tt>queue</tt> - définit les propriétés d'une queue enfant
</ul>

<p>
La syntaxe de la directive <tt>altq on</tt> est :
<blockquote>
<tt>
altq on <i>interface scheduler</i> bandwidth <i>bw</i> qlimit 
<i>qlim</i> \<br>
&nbsp;&nbsp;&nbsp;tbrsize <i>size</i> queue { <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>interface</i></tt> - l'interface réseau sur laquelle activer
    la mise en queue.
<li><tt><i>scheduler</i></tt> - l'algorithme à utiliser. Les valeurs
    possibles sont <tt>cbq</tt> et <tt>priq</tt>. Actuellement, seul un
    algorithme à la fois peut être activé sur une interface.
<li><tt><i>bw</i></tt> - la quantité totale de bande passante disponible
    pour l'algorithme. Elle peut être spécifiée avec une valeur absolue
    en utilisant les suffixes <tt>b</tt>, <tt>Kb</tt>, <tt>Mb</tt>, et
    <tt>Gb</tt> signifiant bits, kilobits, megabits, et gigabits par
    seconde, en valeur ou en pourcentage de la bande passante de l'
    <tt><i>interface</i></tt>.
<li><tt><i>qlim</i></tt> - le nombre maximum de paquets à stocker dans
    une queue. Ce paramètre est optionnel. Il est par défaut de 50.
<li><tt><i>size</i></tt> - la taille du régulateur en octets. Si elle
    n'est pas spécifiée, la taille utilisée est basée sur la bande
    passante de l' <tt><i>interface</i></tt>.
<li><tt><i>queue_list</i></tt> - une liste de queues enfant à créer en
    dessous de la queue "root".
</ul>

<p>
Par exemple :
<blockquote>
<tt>
altq on fxp0 cbq bandwidth 2Mb queue { std, ssh, ftp }
</tt>
</blockquote>
Ceci active CBQ sur l'interface <tt>fxp0</tt>. La totalité de la bande
passante disponible est fixée à 2Mbps. Trois queues enfant sont définies
: <tt>std</tt>, <tt>ssh</tt> et <tt>ftp</tt>.

<p>
La syntaxe pour la directive <tt>queue</tt> est :
<blockquote>
<tt>
queue <i>name</i> [on <i>interface</i>] bandwidth <i>bw</i> [priority 
<i>pri</i>] [qlimit <i>qlim</i>] \<br>
&nbsp;&nbsp;&nbsp;<i>scheduler</i> ( <i>sched_options</i> )
{ <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>name</i></tt> - le nom de la queue. Il doit correspondre à un
    des noms de queues définies dans la directive <tt>altq on</tt>
    <tt><i>queue_list</i></tt>. Pour <tt>cbq</tt> il peut aussi
    correspondre au nom d'une queue dans la directive <tt>queue</tt>
    précédente <tt><i>queue_list</i></tt>. Les noms de queue ne doivent
    pas être plus longs que 15 caractères.
<li><tt><i>interface</i></tt> - l'interface réseau pour laquelle la
    queue est valide. Cette valeur est optionnelle et si elle n'est pas
    précisée, la queue sera valide pour toutes les interfaces.
<li><tt><i>bw</i></tt> - la quantité totale de bande passante disponible
    pour la queue. Elle doit être spécifiée avec une valeur absolue en
    utilisant les suffixes <tt>b</tt>, <tt>Kb</tt>, <tt>Mb</tt>, et
    <tt>Gb</tt> signifiant bits, kilobits, megabits, et gigabits par
    seconde, en valeur ou en pourcentage de la bande passante de la
    queue parent. Ce paramètre n'est applicable que lorsque l'on utilise
    l'algorithme <tt>cbq</tt>.
	 Si non spécifié, 100% de la bande passante de la queue mère est
	 utilisée.
<li><tt><i>pri</i></tt> - la priorité de la queue. Pour <tt>cbq</tt> la
    gamme de priorités va de 0 à 7 et pour <tt>priq</tt> la gamme va de
    0 à 15. La priorité 0 est la priorité la plus basse. Quand elle
    n'est pas spécifiée, elle est par défaut de 1.
<li><tt><i>qlim</i></tt> - le nombre maximum de paquets acceptables dans
    une queue. Quand il n'est pas spécifié, la valeur utilisée par
    défaut est de 50.
<li><tt><i>scheduler</i></tt> - l'algorithme utilisé, soit <tt>cbq</tt>
    soit <tt>priq</tt>. Il doit être le même que celui de la queue
    "root".
<li><tt><i>sched_options</i></tt> - d'autres options peuvent être
    passées à l'algorithme pour contrôler son comportement :
        <ul>
        <li><tt>default</tt> - définit une queue par défaut dans
            laquelle tous les paquets ne répondant pas à une quelconque
            règle vont. Cette queue par défaut doit être unique.
        <li><tt>red</tt> - active la Détection Aléatoire Anticipée (RED)
            pour cette queue.
        <li><tt>rio</tt> - active RED dans les sens ENTREE/SORTIE. Dans
            ce mode, RED maintiendra des longueurs moyennes de queues et
            des valeurs de seuil, une pour chaque niveau de Qualité de
            service.
        <li><tt>ecn</tt> - active la Notification Explicite de
            Congestion (ECN) pour cette queue. <tt>Ecn</tt> implique
            <tt>red</tt>.
        <li><tt>borrow</tt> - la queue peut emprunter de la bande
            passante aux queues parent. Ceci n'est valable que lorsque
            vous utilisez l'algorithme <tt>cbq</tt>.
        </ul>
<li><tt><i>queue_list</i></tt> - une liste de queues enfant &agrave
    créer sous cette queue. Une <tt><i>queue_list</i></tt> ne peut être
    définie que lorsque l'on utilise l'algorithme <tt>cbq</tt>.
</ul>

<p>
Suite de l'exemple ci-dessus :
<blockquote>
<tt>
queue std bandwidth 50% cbq(default)<br>
queue ssh bandwidth 25% { ssh_login, ssh_bulk }<br>
&nbsp;&nbsp;queue ssh_login bandwidth 25% priority 4 cbq(ecn)<br>
&nbsp;&nbsp;queue ssh_bulk  bandwidth 75% cbq(ecn)<br>
queue ftp bandwidth 500Kb priority 3 cbq(borrow red)<br>
</tt>
</blockquote>

<p>
Ici, les paramètres des queues enfant définies précédemment sont
définis. La queue <tt>std</tt> se voit attribuer une bande passante
correspondant à 50% de celle de la queue "root" (1 Mbps) et est définie
comme queue par défaut. La queue <tt>ssh</tt> se voit assigner 25% de la bande
passante de la queue racine (500kb) et contient également deux autres queues,
<tt>ssh_login</tt> et <tt>ssh_bulk</tt>. La queue <tt>ssh_login</tt> a
une priorité plus élevée que <tt>ssh_bulk</tt> et les deux ont ECN
activé. La queue <tt>ftp</tt> obtient une bande passante de 500Kbps et
obtient une priorité de 3. Elle peut aussi emprunter de la bande
passante quand une quantité supplémentaire est disponible et RED est
activé.

<p>
<b>REMARQUE :</b> Chaque définition de queue enfant a sa bande passante
spécifiée.
Sans spécifier la bande passante, PF donnera 100% de la bande passante
de la queue parente.
Dans cette situation, ceci causera une erreur lors du chargement des
règles sauf s'il y a une queue avec 100% de la bande passante, aucune
autre queue ne peut être déclarée à ce niveau, car il n'y a plus de
bande passante à allouer.

<a name="assign"></a>
<h3>Assignation du Trafic à une Queue</h3>
<p>
Pour assigner du trafic à une queue, le mot-clé <tt>queue</tt> est
utilisé en conjonction avec les <a href="filter.html">règles de
filtrage</a> de PF. Par exemple, considérons un jeu de règles de
filtrage contenant une ligne comme :
<blockquote>
<tt>pass out on fxp0 from any to any port 22</tt>
</blockquote>

<p>
Les paquets répondant à cette règle peuvent être assignés à une queue
spécifique en utilisant le mot-clé <tt>queue</tt> :
<blockquote>
<tt>pass out on fxp0 from any to any port 22 queue ssh</tt>
</blockquote>

<p>
Lorsque l'on utilise le mot-clé <tt>queue</tt> avec les directives
<tt>block</tt>, les paquets TCP RST ou ICMP Unreachable résultants sont
assignés dans la queue spécifiée.

<p>
Notez que la désignation des queues est possible sur une interface
différente de celle définie dans la directive <tt>altq on</tt> :
<blockquote>
<tt> 
altq on fxp0 cbq bandwidth 2Mb queue { std, ftp }<br>
queue std bandwidth 500Kb cbq(default)<br>
queue ftp bandwidth 1.5Mb<br>
<br>
pass in on dc0 from any to any port 21 queue ftp<br>
</tt>
</blockquote>

<p>
La Mise en queue est activée sur <tt>fxp0</tt> mais la désignation
concerne <tt>dc0</tt>.
Si les paquets répondant à la règle <tt>pass</tt> sortent de l'interface
<tt>fxp0</tt>, ils seront mis en queue dans <tt>ftp</tt>. Ce type de
mise en queue peut être très pratique sur les routeurs.

<p>
Normalement, un seul nom de queue est donné avec le mot-clé
<tt>queue</tt>, mais si un deuxième nom est spécifié cette queue sera
utilisée pour les paquets avec un
<a href="http://www.rfc-editor.org/rfc/rfc791.txt">Type de Service (ToS)</a>
"low-delay" et pour les paquets TCP ACK sans donnée. Un bon exemple de
ceci est l'utilisation de SSH. Les connexions de sessions SSH mettent le
ToS en "low-delay" contrairement aux sessions SCP et SFTP. PF peut
utiliser cette information pour mettre les paquets correspondant à une
connexion dans une queue différente que celles pour les connexions sans
ouverture de session. Ceci peut être utile pour donner la priorité aux
connexions avec ouverture de session sur les paquets de transfert de
fichiers.
<blockquote>
<tt>pass out on fxp0 from any to any port 22 queue(ssh_bulk, ssh_login)</tt>
</blockquote>

<p>
Ceci assigne les paquets correspondant aux connexions d'ouverture de
session SSH à la queue <tt>ssh_login</tt> et les paquets correspondant
aux connexions SCP et SFTP dans la queue <tt>ssh_bulk</tt>. Les
connexions d'ouverture de session auront leurs paquets traités avant
ceux des connexions SCP et SFTP car la queue <tt>ssh_login</tt> a une
priorité plus élevée.

<p>
L'assignation des paquets TCP ACK à une queue ayant une priorité élevée
est utile pour les connexions asymétriques, c'est à dire les connexions
qui ont des bandes passantes différentes en envoi et en réception, comme
les lignes ADSL. Avec une ligne ADSL, si le canal d'envoi est utilisé à
son maximum et si un téléchargement est lancé, le téléchargement en
souffrira car les paquets TCP ACK devant être envoyés seront
congestionnés quand ils essaieront de traverser le canal d'envoi. Des
tests ont montré que pour réaliser les meilleurs résultats, la bande
passante de la queue d'envoi doit être inférieure à la capacité
maximale. Par exemple, si une ligne ADSL a un envoi maximum de 640Kbps,
le fait de régler la <tt>bande passante</tt> de la queue "root" sur une
valeur comme 600Kb entraînera de meilleures performances. C'est après
des essais et des erreurs que vous obtiendrez les meilleurs réglages de
<tt>bande passante</tt>.

<p>
Quand on utilise le mot-clé <tt>queue</tt> avec des règles qui
<tt>gardent l'état</tt> comme :
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port 22 flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state queue ssh
</tt>
</blockquote>

<p>
PF enregistrera la queue dans la table d'états ce qui entraînera que les
paquets traversant <tt>fxp0</tt> au retour et répondant à la connexion
"stateful" termineront dans la queue <tt>ssh</tt>. Notez que même si le mot-clé
<tt>queue</tt> est utilisé dans une règle filtrant le trafic entrant, le
but est de spécifier une queue pour le trafic sortant correspondant; la
règle ci-dessus ne mettra pas en queue les paquets entrants.

<a name="example1"></a>
<h2>Exemple #1 : Réseau domestique</h2>
<pre>
  
    [ Alice ]    [ Charlie ]
        |             |                              ADSL
     ---+-----+-------+------ dc0 [ OpenBSD ] fxp0 -------- ( Internet )
              |
           [ Bob ]

</pre>

<p>
Dans cet exemple, OpenBSD est utilisé sur une passerelle Internet pour
un petit réseau à domicile avec trois stations de travail. La passerelle
réalise le filtrage de paquets et la NAT. La connexion Internet via une
ligne ADSL possède une bande passante descendante de 2MBps et montante
de 640Kbps.

<p>
La politique de mise en queue pour ce réseau :
<ul>
<li>Réserver une bande passante de 80Kbps en téléchargement pour Bob
    afin qu'il puisse jouer aux jeux en ligne sans être ralenti par les
    téléchargements d'Alice et de Charlie. Autoriser Bob à utiliser plus
    de 80Kbps quand ceci est possible.
<li>Le trafic généré par le SSH interactif et la messagerie instantanée
    aura une plus haute priorité que le trafic régulier.
<li>Les requêtes et les réponses DNS auront la seconde plus haute
    priorité.
<li>Les paquets TCP ACK sortants auront une priorité plus haute que tout
    autre trafic sortant.
</ul>

<p>
Le jeu de règles ci-dessous permet cette politique réseau. Notez que
seules les directives de <tt>pf.conf</tt> qui concernent directement la
politique ci-dessus sont présentes;
<a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>, <a href="options.html">options</a>,
etc... ne sont pas montrées.

<p>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# active la mise en queue sur l'interface externe pour contrôler 
# le trafic allant sur Internet. utilise l'algorithme priq pour 
# contrôler uniquement les priorités. 
# fixe la bande passante à 610Kbps pour avoir les meilleures
# performances à la sortie de la queue TCP ACK.

altq on fxp0 priq bandwidth 610Kb queue { std_out, ssh_im_out, dns_out, \
        tcp_ack_out }

# définit les paramètres pour les queues enfant.
# std_out      - la queue standard. toute règle de filtrage ci-dessous 
#                qui ne spécifie pas explicitement une queue aura
#                son trafic ajouté à cette queue.
# ssh_im_out   - trafic généré par le SSH interactif et
#                la messagerie instantanée
#                variés.
# dns_out      - requêtes DNS.
# tcp_ack_out  - paquets TCP ACK sans donnée.

queue std_out     priq(default)
queue ssh_im_out  priority 4 priq(red)
queue dns_out     priority 5
queue tcp_ack_out priority 6

# active la mise en queue sur l'interface interne en vue de contrôler
# le trafic provenant d'Internet. utilise l'algorithme cbq pour
# contrôler la bande passante. la bande passante maximale est de
# 2Mbps.

altq on dc0 cbq bandwidth 2Mb queue { std_in, ssh_im_in, dns_in, bob_in }

# définit les paramètres pour les queues enfant.
# std_in      - la queue standard. toute règle de filtrage ci-dessous 
#               qui ne spécifie pas explicitement une queue aura
#               son trafic ajouté à cette queue.
# ssh_im_in   - trafic généré par le SSH interactif et
#               par la messagerie instantanée.
# dns_in      - réponses DNS.
# bob_in      - bande passante réservée à la station
#               de travail de Bob. l'autorise à emprunter.

queue std_in    bandwidth 1.6Mb cbq(default)
queue ssh_im_in bandwidth 200Kb priority 4
queue dns_in    bandwidth 120Kb priority 5
queue bob_in    bandwidth 80Kb cbq(borrow)


# ... dans la section filtrage de pf.conf ...

alice         = "192.168.0.2"
bob           = "192.168.0.3"
charlie       = "192.168.0.4"
local_net     = "192.168.0.0/24"
ssh_ports     = "{ 22 2022 }"
im_ports      = "{ 1863 5190 5222 }"

# règles de filtrage pour l'entrée en fxp0
block in on fxp0 all

# règles de filtrage pour la sortie en fxp0
block out on fxp0 all
pass  out on fxp0 inet proto tcp from (fxp0) to any flags S/SA \
        keep state queue(std_out, tcp_ack_out)
pass  out on fxp0 inet proto { udp icmp } from (fxp0) to any keep state
pass  out on fxp0 inet proto { tcp udp } from (fxp0) to any port domain \
        keep state queue dns_out
pass  out on fxp0 inet proto tcp from (fxp0) to any port $ssh_ports \
        flags S/SA keep state queue(std_out, ssh_im_out)
pass  out on fxp0 inet proto tcp from (fxp0) to any port $im_ports \
        flags S/SA keep state queue(ssh_im_out, tcp_ack_out)

# règles de filtrage pour l'entrée en dc0
block in on dc0 all
pass  in on dc0 from $local_net

# règles de filtrage pour la sortie en dc0
block out on dc0 all
pass  out on dc0 from any to $local_net
pass  out on dc0 proto { tcp udp } from any port domain to $local_net \
        queue dns_in
pass  out on dc0 proto tcp from any port $ssh_ports to $local_net \
        queue(std_in, ssh_im_in)
pass  out on dc0 proto tcp from any port $im_ports to $local_net \
        queue ssh_im_in
pass  out on dc0 from any to $bob queue bob_in
</pre>
</td></tr>
</table>

<a name="example2"></a>
<h2>Exemple #2 : Réseau d'entreprise</h2>
<pre>

  ( IT Dept )  [ Boss's PC ]
       |          |                                   T1
     --+----+-----+---------- dc0 [ OpenBSD ] fxp0 -------- ( Internet )
            |                         fxp1
         [ COMP1 ]    [ WWW ]         /
                         |           / 
                       --+----------' 

</pre>

<p>
Dans cet exemple, l'hôte OpenBSD agit en pare-feu pour le réseau d'une
entreprise. L'entreprise utilise un serveur WWW dans la partie DMZ de
son réseau où les clients envoient leurs sites via FTP. Le département
IT a son propre sous-réseau connecté au réseau principal, et le
directeur a un PC sur son bureau utilisé pour les emails et le surf sur
Internet. La connexion à Internet se fait via une ligne T1 avec une
bande passante de 1.5Mbps dans les deux directions. Tous les autres
segments du réseau utilisent Fast Ethernet (100Mbps).

<p>
L'administrateur réseau a décidé de la politique suivante :
<ul>
<li>Limiter tout le trafic entre le serveur WWW et Internet à 500Kbps dans
chaque direction
	<ul>
	<li>Réserver 250Kbps pour le trafic HTTP.
	<li>Réserver 250Kbps pour le reste (trafic non-HTTP, etc...)
	<li>Permettre autrement de pouvoir emprunter dans les 500Kbps.
	<li>Donner au trafic HTTP entre le serveur WWW et Internet une
		 priorité plus élevée que les autres trafics entre le serveur WWW
		 et Internet (comme les envois FTP).
	</ul>
<li>Le trafic entre le serveur WWW et le réseau interne peut utiliser
	 davantage que les 100Mbps offerts par le réseau.
<li>Réserver 500Kbps pour le réseau du département IT pour qu'ils
    puissent télécharger les dernières mises à jour de logiciels de
    façon rapide. Ils devront pouvoir utiliser plus de 500Kbps quand de
    la bande passante additionnelle sera disponible.
<li>Donner une priorité plus élevée au trafic entre le PC du directeur
    et Internet que tout autre trafic allant ou venant d'Internet.
</ul>

<p>
Le jeu de règles ci-dessous permet cette politique réseau. Notez que
seul les directives de <tt>pf.conf</tt> qui concernent directement la
politique ci-dessus sont présentes;
<a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>, <a href="options.html">options</a>,
etc... ne sont pas montrées.

<p>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# active la mise en queue sur l'interface externe pour les paquets sortant sur 
# Internet. utilise l'algorithme cbq, afin que la bande passante de chaque 
# queue puisse être contrôlée. la bande passante sortante
# maximale est de 1.5Mbps.

altq on fxp0 cbq bandwidth 1.5Mb queue { std_ext, www_ext, boss_ext }

# définit les paramètres pour les queues enfant.
# std_ext        - la queue standard. également queue par défaut 
#                  pour le trafic sortant sur fxp0.
# www_ext        - queue contenant les queues du serveur WWW. limitée à
#                  500Kbps.
#   www_ext_http - trafic http du serveur WWW; plus haute priorité.
#   www_ext_misc - tout le trafic non-http du serveur WWW.
# boss_ext       - trafic venant de l'ordinateur du patron.

queue std_ext        bandwidth 500Kb cbq(default borrow)
queue www_ext        bandwidth 500Kb { www_ext_http, www_ext_misc }
  queue www_ext_http bandwidth 50% priority 3 cbq(red borrow)
  queue www_ext_misc bandwidth 50% priority 1 cbq(borrow)
queue boss_ext       bandwidth 500Kb priority 3 cbq(borrow)

# active la mise en queue sur l'interface interne pour contrôler le trafic
# venant d'Internet ou de la DMZ. utilise l'algorithme cbq pour contrôler
# la bande passante de chaque queue. la bande passante sur cette interface
# est fixée au maximum. le trafic venant de la DMZ sera en mesure
# d'utiliser la totalité de cette bande passante alors que le trafic
# venant de l'Internet sera limité à 1.0Mbps (car 0.5Mbps
# (500Kbps) sont alloués à fxp1).

altq on dc0 cbq bandwidth 100% queue { net_int, www_int }

# définit les paramètres pour les queues enfant.
# net_int    - queue contenant le trafic provenant de Internet. la bande
#              passante est de 1.0Mbps.
#   std_int  - la queue standard. également queue par défaut pour
#              le trafic sortant en dc0.
#   it_int   - trafic vers le réseau du département informatique;
#					réserver 500Kbps.
#   boss_int - trafic vers le PC du patron; assigner la plus haute
#   				priorité.
# www_int    - trafic du serveur WWW de la DMZ; vitesse maximale.

queue net_int    bandwidth 1.0Mb { std_int, it_int, boss_int }
  queue std_int  bandwidth 250Kb cbq(default borrow)
  queue it_int   bandwidth 500Kb cbq(borrow)
  queue boss_int bandwidth 250Kb priority 3 cbq(borrow)
queue www_int    bandwidth 99Mb cbq(red borrow)

# active la mise en queue sur l'interface de la DMZ pour contrôler
# le trafic destiné au serveur WWW. cbq sera utilisé
# sur cette interface tant que le contrôle détaillé de la bande
# passante sera nécessaire. la bande passante sur cette interface
# est fixée au maximum. le trafic provenant du réseau
# interne sera en mesure d'utiliser la totalité de la bande passante
# alors que le trafic provenant d'Internet sera limité à 500Kbps.

altq on fxp1 cbq bandwidth 100% queue { internal_dmz, net_dmz }

# définit les paramètres pour les queues enfant.
# internal_dmz   - trafic provenant du réseau interne.
# net_dmz        - queue contenant le trafic provenant de Internet.
#   net_dmz_http - trafic http; plus haute priorité.
#   net_dmz_misc - tout autre trafic. c'est aussi la queue par défaut.

queue internal_dmz   bandwidth 99Mb cbq(borrow)
queue net_dmz        bandwidth 500Kb { net_dmz_http, net_dmz_misc }
  queue net_dmz_http bandwidth 50% priority 3 cbq(red borrow)
  queue net_dmz_misc bandwidth 50% priority 1 cbq(default borrow)


# ... dans la section filtrage du pf.conf ...

main_net  = "192.168.0.0/24"
it_net    = "192.168.1.0/24"
int_nets  = "{ 192.168.0.0/24, 192.168.1.0/24 }"
dmz_net   = "10.0.0.0/24"

boss      = "192.168.0.200"
wwwserv   = "10.0.0.100"

# refus par défaut
block on { fxp0, fxp1, dc0 } all

# règles de filtrage pour l'entrée de fxp0
pass in on fxp0 proto tcp from any to $wwwserv port { 21, \
        &gt; 49151 } flags S/SA keep state queue www_ext_misc
pass in on fxp0 proto tcp from any to $wwwserv port 80 \
        flags S/SA keep state queue www_ext_http

# règles de filtrage pour la sortie de fxp0
pass out on fxp0 from $int_nets to any keep state
pass out on fxp0 from $boss to any keep state queue boss_ext

# règles de filtrage pour l'entrée de dc0
pass in on dc0 from $int_nets to any keep state
pass in on dc0 from $it_net to any queue it_int
pass in on dc0 from $boss to any queue boss_int
pass in on dc0 proto tcp from $int_nets to $wwwserv port { 21, 80, \
        &gt; 49151 } flags S/SA keep state queue www_int

# règles de filtrage pour la sortie de dc0
pass out on dc0 from dc0 to $int_nets

# règles de filtrage pour l'entrée de fxp1
pass in on fxp1 proto { tcp, udp } from $wwwserv to any port 53 \
        keep state

# règles de filtrages pour la sortie de fxp1
pass out on fxp1 proto tcp from any to $wwwserv port { 21, \
        &gt; 49151 } flags S/SA keep state queue net_dmz_misc
pass out on fxp1 proto tcp from any to $wwwserv port 80 \
        flags S/SA keep state queue net_dmz_http
pass out on fxp1 proto tcp from $int_nets to $wwwserv port { 80, \
        21, &gt; 49151 } flags S/SA keep state queue internal_dmz
</pre>
</td></tr>
</table>

<p>
[<a href="anchors.html">Précédent : Ancres</a>]
[<a href="index.html">Index</a>]
[<a href="pools.html">Suivant : Ensembles d'adresses (&quot;Pools&quot;) et
Partage de Charge</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: queueing.html,v 1.38 ]<br>
$Translation: queueing.html,v 1.28 2009/10/19 15:48:30 benoit Exp $<br>
-->
$OpenBSD: queueing.html,v 1.22 2009/10/20 20:44:42 ajacoutot Exp $
</small>

</body>
</html> 

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Pakete filtern</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2007 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="tables.html">Zurück: Tabellen</a>]
[<a href="index.html">Inhalt</a>]
[<a href="nat.html">Weiter: Network Address Translation</a>]

<h1><font color="#e00000">PF: Pakete filtern</font></h1>

<hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#intro">Einführung</a>
<li><a href="#syntax">Regelsyntax</a>
<li><a href="#defdeny">Standardmäßiges Blocken</a>
<li><a href="#pass">Verkehr durchlassen</a>
<li><a href="#quick">Das <tt>quick</tt>-Schlüsselwort</a>
<li><a href="#state">Status halten</a>
<li><a href="#udpstate">Status für UDP halten</a>
<li><a href="#stateopts">Optionen für zustandsabhängiges Tracking</a>
<li><a href="#tcpflags">TCP-Flags</a>
<li><a href="#synproxy">TCP-SYN-Proxy</a>
<li><a href="#antispoof">gefälschte Pakete blocken</a>
<li><a href="#urpf">Unicast Reverse Path Forwarding</a>
<li><a href="#osfp">Passives Betriebssystemfingerprinting</a>
<li><a href="#ipopts">IP-Optionen</a>
<li><a href="#example">Beispiel-Filterregelsatz</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Einführung</h2>
Mit dem Filtern von Paketen ist das selekte Durchlassen oder Blocken
von Datenpaketen gemeint, sobald sie durch das Netzwerkinterface
gehen. Die Kriterien, die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.6"
>pf(4)</a> verwendet, wenn Pakete untersucht werden, basieren auf den
Layer-3-
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4"
>IPv6</a>) und Layer-4-
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4"
>ICMP</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4"
>ICMPv6</a>) Headern. Die meistgenutzten Kriterien sind Quell- und
Zieladressen sowie Zielport und das Protokoll.

<p>
Filterregeln geben sowohl die Kriterien an, auf die ein Paket zutreffen
muss, als auch die resultierende Handlung (blocken oder durchlassen), die
durchgeführt wird, wenn eine Übereintreffung gefunden wird. Filterregeln
werden in sequenzieller Reihenfolge verarbeitet: von der ersten bis zur
letzten. Solange das Paket nicht auf eine Regel trifft, die das
<tt>quick</tt>-Schlüsselwort beinhaltet, werden <i>alle</i> Filterregeln
überprüft, bevor die schlussendliche Aktion durchgeführt wird. Die letzte
Regel, die zutrifft, ist der Gewinner und wird die Aktion angeben, die
auf das Paket angewandt wird. Es gibt ein impliziertes <tt>pass all</tt>
am Anfang des Filterregelsatzes, das bedeutet, dass falls ein Paket auf
keine Filterregel zutrifft, die resultierende Aktion <tt>pass</tt> sein
wird.

<a name="syntax"></a>
<h2>Regelsyntax</h2>
Die generelle <i>höchstgradig vereinfachte</i> Syntax für Filterregeln
ist:
<blockquote>
<tt>
<i>action</i> [<i>direction</i>] [log] [quick] [on <i>interface</i>]
[<i>af</i>] [proto <i>protocol</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>src_addr</i> [port <i>src_port</i>]] [to
<i>dst_addr</i> [port <i>dst_port</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>action</i></tt>
<dd>Die Aktion, die für zutreffende Pakete angewandt werden soll:
<tt>pass</tt> oder <tt>block</tt>. Die <tt>pass</tt>-Aktion wird das
Paket zurück zum Kernel für weitere Verarbeitung lassen, während die
<tt>block</tt>-Aktion je nach der
<a href="options.html#block-policy"><tt>block-policy</tt></a>-Option
anders reagieren wird. Die standardmäßige Reaktion kann entweder durch
Angabe von <tt>block drop</tt> oder <tt>block return</tt>
verändert werden.

<dt><tt><i>direction</i></tt>
<dd>Die Richtung, in die das Paket sich bewegt: rein (<tt>in</tt>)
oder raus (<tt>out</tt>).

<dt><tt>log</tt>
<dd>Gibt an, dass das Paket per
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.6"
>pflogd(8)</a> aufgezeichnet werden soll. Wenn die Regel zustandsbezogen
ist, dann wird nur das Paket aufgezeichnet, das den Status aufgebaut hat.
Um alle Pakete unabhängig davon aufzuzeichnen, verwende
<tt>log (all)</tt>.

<dt><tt>quick</tt>
<dd>Wenn ein Paket auf eine Regel zutrifft, die <tt>quick</tt> angibt,
dann wird die Regel als letzte zutreffende Regel angesehen, wodurch
sie die Aktion (<tt><i>action</i></tt>) angibt, die durchgeführt werden
soll.

<dt><tt><i>interface</i></tt>
<dd>Der Name eines Netzwerkinterfaces (bzw. die Gruppe von
Netzwerkinterfaces) durch das sich das Paket bewegt.
Interfaces können mit dem
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>-Kommando zu beliebigen Gruppen hinzugefügt werden.
Einige Gruppen werden automatisch vom Kernel erstellt:
<ul>
<li>Die <tt>egress</tt>-Gruppe, die Interfaces enthält, die die
Standardroute(n) enthalten.
<li>Interfacefamiliengruppe für geklonte Interfaces.
Zum Beispiel <tt>ppp</tt> oder <tt>carp</tt>.
</ul>
Dies wird dazu führen, dass die Regel für jedes Paket zutrifft, das
das <tt>ppp</tt>- oder <tt>carp</tt>-Interface durchläuft - je nachdem.

<dt><tt><i>af</i></tt>
<dd>Die Adressfamilie des Pakets: <tt>inet</tt> für IPv4 oder
<tt>inet6</tt> für IPv6. PF ist normalerweise in der Lage, anhand der
Parameter für die Quell- und/oder Zieladresse(n) das selbst zu
erkennen.

<dt><tt><i>protocol</i></tt>
<dd>Die Layer-4-Protokolle des Pakets:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Ein gültiger Protokollname aus
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5"
><tt>/etc/protocols</tt></a>
<li>Eine Protokollnummer zwischen 0 und 255
<li>Ein Satz an Protokollen unter Verwendung einer
    <a href="macros.html#lists">Liste</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt>
<dd>Die Quell/Zieladresse im IP-Header. Adressen können wie folgt
angegeben werden:
<ul>
<li>Eine einzelne IPv4- oder IPv6-Adresse.
<li>Ein
<a href="http://public.pacbell.net/dedicated/cidr.html"
>CIDR</a>-Netzwerkblock
<li>Ein »fully qualified domain name«, der per DNS aufgelöst wird, wenn
der Regelsatz geladen wird. Alle resultierenden IP-Adressen werden in
die Regel eingesetzt.
<li>Der Name des Netzwerkinterfaces. Jegliche IP-Adressen, die dem
Interface zugewiesen worden sind, werden in die Regel eingesetzt.
<li>Der Name des Netzwerkinterfaces gefolgt von
<tt>/<i>netmask</i></tt> (z.&nbsp;B. <tt>/24</tt>). Jede IP-Adresse auf
dem Interface wird mit der Netzmaske kombiniert, um einen
CIDR-Netzwerkblock zu formen, welcher in die Regel eingesetzt wird.
<li>Der Name des Netzwerkinterfaces oder der Gruppe in Klammern
<tt>( )</tt>. Die Klammern teilen PF mit, dass die Regel sich
aktualisieren soll, wenn sich die IP-Adresse(n) des genannten
Interfaces ändert/ändern. Dies ist insbesondere dann sinnvoll, wenn die
IP-Adresse per DHCP oder dial-up erhalten wird, da der Regelsatz so
nicht jedes Mal neugeladen werden muss, wenn sich die Adresse ändert.
<li>Der Name eines Netzwerkinterfaces gefolgt von einem dieser
Modifizierer:
  <ul>
  <li><tt>:network</tt> - fügt den CIDR-Netzwerkblock ein (z.&nbsp;B.
  192.168.0.0/24)
  <li><tt>:broadcast</tt> - fügt die Netzwerk-Broadcastadresse ein
  (z.&nbsp;B. 192.168.0.255)
  <li><tt>:peer</tt> - fügt die IP-Adresse des Peers auf einem
  Point-to-Point-Link ein
  </ul>
  <dl>
  <dd>Zusätzlich kann der <tt>:0</tt>-Modifizierer einem Interfacenamen
  oder einem der vorherigen Modifizierer angehängt werden, um darauf
  hinzuweisen, dass PF keine IP-Adressaliase in die Einfügung mit
  übernehmen soll. Diese Modifizierer können ebenfalls verwendet werden,
  wenn sich das Interface in Klammern befindet.
  Beispiel: <tt>fxp0:network:0</tt>
  </dl>
<li>Eine <a href="tables.html">Tabelle</a>.
<li>Das Schlüsselwort <tt>urpf-failed</tt> kann für die Quelladresse
verwendet werden, um anzugeben, dass diese durch den
<a href="#urpf">uRPF-Check</a> geschickt werden soll.
<li>Irgendeine der oben genannten, unter Verwendung der <tt>!</tt>-
("nicht") Modifikation.
<li>Ein Satz an Adressen unter Verwendung einer
<a href="macros.html#lists">Liste</a>.
<li>Das Schlüsselwort <tt>any</tt>, das bedeutet für alle Adressen
  steht.
<li>Das Schlüsselwort <tt>all</tt>, das eine Kurzschreibweise für
<tt>from any to any</tt> ist.
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>Der Quell/Ziel-Port in dem Layer-4-Paket-Header. Ports können
wie folgt angegeben werden:
<ul>
<li>Eine Nummer zwischen 1 und 65535
<li>Ein gültiger Servicename aus
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5"
><tt>/etc/services</tt></a>
<li>Ein Satz an Ports unter Verwendung einer
<a href="macros.html#lists">Liste</a>
<li>Ein Bereich:
	<ul>
	<li><tt>!=</tt> (ungleich)
	<li><tt>&lt;</tt> (kleiner als)
	<li><tt>&gt;</tt> (größer als)
	<li><tt>&lt;=</tt> (kleiner oder gleich)
	<li><tt>&gt;=</tt> (größer oder gleich)
	<li><tt>&gt;&lt;</tt> (Bereich)
	<li><tt>&lt;&gt;</tt> (invertierter Bereich)
	<dl>
	<dd>Die letzten beiden sind Binäroperatoren (sie benötigen zwei
	Argumente) und fügen die Argumente nicht in den Bereich ein.
	</dl>
	<li><tt>:</tt> (inklusiver Bereich)
	<dl>
	<dd>Der Operator für den inklusiven Bereich ist ebenfalls ein
	Binäroperator und fügt die Argumente mit in den Bereich ein.
	</dl>
	</ul>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd>Gibt die Flags an, die in dem TCP-Header gesetzt sein müssen, wenn
<tt>proto tcp</tt> verwendet wird. Flags werden als
<tt>flags <i>check</i>/<i>mask</i></tt> angegeben. <tt>flags
S/SA</tt> zum Beispiel dies sagt PF, dass nur auf die S- und A- (SYN und
ACK) Flags geachtet werden und zutreffen soll, wenn nur das SYN-Flag
aktiviert ist.
In OpenBSD 4.1 und späteren Versionen werden die Standardflags
<tt>S/SA</tt> an alle TCP-Filterregeln übergeben.

<dt><tt><i>state</i></tt>
<dd>Gibt an, ob die Statusinformation für das Paket gehalten werden
soll, das auf diese Regel zutrifft.
<ul>
<li><tt>keep state</tt> - funktioniert mit TCP, UDP und ICMP.
In OpenBSD 4.1 und späteren Versionen ist diese Option Standard für
alle Filterregeln.
<li><tt>modulate state</tt> - funktioniert nur mit TCP. PF wird
starke »Initial Sequence Numbers« (ISNs) für Pakete erstellen, die auf
diese Regel zutreffen.
<li><tt>synproxy state</tt> - eingehende TCP-Verbindungen werden durch
den Proxy geschickt, um beim Beschützen der Server vor Floods von
gefälschten TCP-SYNs zu helfen. Diese Option beinhaltet die
Funktionalität von <tt>keep state</tt> und <tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Standardmäßiges Blocken</h2>
Die empfohlene Praxis, wenn eine Firewall aufgesetzt wird ist, einen
»standardmäßig block«-Weg einzuschlagen. Dies bedeutet, dass
<i>alles</i> geblockt und dann selektiv bestimmter Verkehr durch
die Firewall gelassen wird. Dieser Weg ist empfohlen, da man trotz
entstehender Fehler auf der sicheren Seite ist und das Schreiben eines
Regelsatzes einfacher wird.

<p>
Um eine »standardmäßig block«-Richtlinie zu erstellen, sollten die
ersten beiden Filterregeln wie folgt sein:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Dies wird den gesamten Verkehr auf allen Interfaces blocken - egal in
welche Richtung und von wo nach wo.

<a name="pass"></a>
<h2>Verkehr durchlassen</h2>
Verkehr muss nun explizit durch die Firewall gelassen werden oder er
wird wegen der »standardmäßig blocken«-Richtlinie fallen gelassen.
Nun kommen Paketkriterien wie Quell/Zielports, Quell/Zieladressen
und das Protokoll ins Spiel. Wann auch immer Verkehr durch die
Firewall gelassen wird, sollte(n) die Regel(n) so restriktiv wie möglich
geschrieben werden. Dies stellt sicher, dass der beabsichtigte Verkehr -
und zwar nur der beabsichtigte Verkehr - durchgelassen wird.

<p>
Einige Beispiele:
<blockquote>
<tt>
# Lasse den Verkehr auf dc0 vom lokalen Netzwerk 192.168.0.0/24<br>
# zur OpenBSD-Maschine mit der IP-Adresse 192.168.0.1 herein. Lasse<br>
# ebenfalls den Antwort-Verkehr durch dc0 wieder raus.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Lasse TCP-Verkehr auf fxp0 vom Webserver herein, der auf der<br>
# OpenBSD-Maschine läuft. Der Interfacename fxp0 wird als Zieladresse<br>
# verwendet, sodass Pakete mit dieser Regel nur übereinstimmen, wenn<br>
# sie für die OpenBSD-Maschine gedacht sind.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>Das <tt>quick</tt>-Schlüsselwort</h2>
Wie zuvor angedeutet wurde, wird jedes Paket mit dem gesamten
Filterregelsatz von oben nach unten überprüft. Standardmäßig wird das
Paket als durchgelassen markiert, was aber von jeglicher Regel geändert
werden kann. Das wiederum kann mehrmals wechseln, bevor das Ende
der Filterregeln erreicht ist. <b>Die letzte zutreffende Regel
gewinnt.</b> Es gibt eine Ausnahme dafür: Die <tt>quick</tt>-Option
einer Filterregel hat zur Folge, dass jegliche Verarbeitung der weiteren
Regeln abgebrochen und die angegebene Aktion durchgeführt wird.
Lass uns nun einige Beispiele dafür ansehen:

<p>
Falsch:
<blockquote>
<tt>
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
In diesem Fall wird die <tt>block</tt>-Zeile zwar verarbeitet, aber
keinen Effekt haben, da sie von einer Zeile gefolgt wird, die alles
durchlässt.

<p>
Besser:
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Diese Regeln werden auf eine etwas unterschiedliche Weise verarbeitet. Wenn
die <tt>block</tt>-Zeile zutrifft, wird das Paket geblockt und wegen
der <tt>quick</tt>-Option wird der Rest des Regelsatzes ignoriert.

<a name="state"></a>
<h2>Status halten</h2>
Eine der wichtigen Fähigkeiten von Packet Filter ist »keeping state«
(bzw. »stateful inspection«. »Stateful inspection« verweist auf PFs
Fähigkeit, den Status (oder Fortschritt) auf der Netzwerkverbindung
nachweisen zu können. Durch die Aufbewahrung der Informationen über
jede Verbindung in einer Statustabelle ist PF in der Lage, schnell
herauszufinden, ob ein Paket, das durch die Firewall gelassen wird,
zu einer bereits erstellten Verbindung gehört. Wenn es das tut, wird
es durch die Firewall gelassen, ohne durch die Regelsätze geschickt
zu werden.

<p>
Den Status zu halten hat viele Vorteilen, einschließlich einfacherer
Regelsätze und besserer Leistung beim Paketfiltern. PF ist in der
Lage, Pakete mit den Einträgen in der Statustabelle zu überprüfen,
<i>egal</i> in welche Richtung sich das Paket bewegt. Das bedeutet, dass
Filterregeln, die den Antwortverkehr hereinlassen, nicht geschrieben
werden müssen. Und da Pakete, die mit zustandsabhängigen Verbindungen
übereinstimmen, nicht durch die Regelsatzüberprüfung gehen, kann
die Zeit, die PF zur Verarbeitung der Pakete benötigt, drastisch
verringert werden.

<p>
Wenn eine Regel einen Status erstellt, dann wird das erste zutreffende
Paket diesen Status zwischen Sender und Empfänger erstellen.
Nun werden nicht nur die Pakete ohne Überprüfung durchgelassen,
die vom Sender zum Empfänger gehen, sondern auch die Antwortpakete
vom Empfänger zum Sender.

<p>
Beginnend mit OpenBSD 4.1 erstellen alle Filterregeln automatisch einen
Statuseintrag, wenn ein Paket auf eine Regel zutrifft. In früheren
OpenBSD-Versionen musste man für die Filterregel explizit die Option
<tt>keep state</tt> angeben.

<p>
Beispiel für OpenBSD 4.1 und späteren Versionen:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any
</tt>
</blockquote>

<p>
Beispiel für OpenBSD 4.0 und ältere Versionen:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
Diese Regeln erlauben jeglichen ausgehenden TCP-Verkehr auf dem
<tt>fxp0</tt>-Interface und lassen ebenfalls Antwortverkehr zu, der
zurück durch die Firewall geht.
Während das Halten von Zuständen eine schöne Funktionalität ist, kann
es die Leistung deiner Firewall signifikant erhöhen, da
Zustandsüberprüfungen um ein vielfaches schneller sind als das Paket
durch die Filterregeln zu schicken.

<p>
Die <tt>modulate state</tt>-Option funktioniert genauso wie
<tt>keep state</tt> - mit der Ausnahme, dass es nur auf TCP-Pakete
zutrifft. Mit <tt>modulate state</tt> wird die »Initial Sequence
Number« (ISN) des ausgehenden Verkehrs zufällig gewählt. Dies ist
sinnvoll, um Verbindungen zu schützen, die von bestimmten
Betriebssystemen erstellt worden sind, die eine schlechte Leistung
beim Wählen von ISNs an den Tag legen.
Beginnend mit OpenBSD 3.5 kann die <tt>modulate state</tt>-Option
in Regeln genutzt werden, die andere Protokolle als TCP angeben.

<p>
Den Zustand von ausgehenden TCP-, UDP-, und ICMP-Paketen und
,modulate'-TCP-ISNs halten:
<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Ein anderer Vorteil beim Halten von Zuständen ist, dass der
dazugehörige ICMP-Verkehr durch die Firewall gelassen wird. Wenn zum
Beispiel eine TCP-Verbindung - deren Status überwacht wird - durch die
Firewall gelassen wird und eine ICMP-Source-Quench-Nachricht für diese
TCP-Verbindung ankommt, wird sie mit dem dazugehörigem Status
übereinstimmen und durch die Firewall gelassen.

<p>
Der Bereich des Statuseintrags wird systemweit durch die
<a href="options.html#state-policy"
><tt>state-policy</tt></a>-Laufzeitoption auf einer regelspezifischen
Basis durch die <tt>if-bound</tt>- und
<tt>floating</tt>-state-Optionsschlüsselwörter kontrolliert. Diese
regelspezifischen Schlüsselwörter haben die gleiche Bedeutung als wenn
sie mit der <tt>state-policy</tt>-Option verwendet werden. Beispiel:

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Diese Regel bestimmt, dass nur Pakete, die durch das Interface
<tt>fx0</tt> gelangen, mit dem Statuseintrag übereinstimmen können.


<p>
Bedenke, dass <a href="nat.html"><tt>nat-</tt></a>,
<a href="nat.html#binat"><tt>binat-</tt></a> und
<a href="rdr.html"><tt>rdr-</tt></a>Regeln implizit einen Status
für zutreffende Verbindungen erstellen, solange die Verbindung
durch den Filterregelsatz gelassen wird.

<a name="udpstate"></a>
<h2>,state' für UDP halten</h2>
Man wird ab und zu hören, dass jemand sagt: »Man kann keinen Zustand
mit UDP erstellen, da UDP ein zustandsloses Protokoll ist!« Obwohl es
stimmt, dass UDP-Verbindungssitzungen kein Konzept eines Zustands
haben (einen expliziten Anfang und ein explizites Ende), hat dies keine
Wirkung auf PFs Fähigkeit, einen Status für eine UDP-Sitzung zu
erstellen. In dem Fall von Protokollen ohne Start- und Endpakete,
merkt sich PF einfach, wie lange es her ist, dass ein zutreffendes
Paket durchgelassen wurde. Wenn der Timeout erreicht wurde, wird
der Status gelöscht. Der Timeout-Wert kann in der
<a href="options.html">options</a>-Sektion in der Datei
<tt>pf.conf</tt> gesetzt werden.

<a name="stateopts"></a>
<h2>Optionen für zustandsabhängiges Tracking</h2>
Filterregeln, die einen Statuseintrag erstellen, können mehrere
Optionen angeben, um das Verhalten des resultierenden Statuseintrags
zu kontrollieren. Die folgenden Optionen sind verfügbar:

<dl>
<dt><tt>max <i>anzahl</i></tt>
<dd>Begrenzt die maximale Anzahl Statuseinträge, die die Regel
erstellen kann, auf <i>anzahl</i>.
Wenn das Maximum erreicht wurde, werden Pakete, die normalerweise
einen Status erstellen würden, nicht auf diese Regel zutreffen, bis
die Anzahl vorhandener Zustände wieder unterhalb der Obergrenze liegt.

<dt><tt>no state</tt>
<dd>Die Regel wird davon abgehalten, automatisch einen Statuseintrag
anzulegen.

<dt><tt>source-track</tt>
<dd>Diese Option aktiviert das Tracking der Anzahl der Zustände, die
für jede einzelne IP-Adresse erstellt wurden.
Diese Option hat zwei Formate:
	<ul>
	<li><tt>source-track rule</tt> - Die maximale Anzahl der
	Zustände, die durch diese Regel erstellt werden können, wird
	durch die <tt>max-src-nodes</tt>- und
	<tt>max-src-states</tt>-Optionen dieser Regel begrenzt. Nur
	Statuseinträge, die durch diese bestimmte Regel erstellt
	wurden, werden gezählt und mit der Grenze dieser Regel
	überprüft.
	<li><tt>source-track global</tt> - Die Anzahl der Zustände
	aller Regeln, die diese Option nutzen, werden begrenzt. Jede
	Regel kann unterschiedliche <tt>max-src-nodes</tt>- und
	<tt>max-src-states</tt>-Optionen angeben, jedoch werden
	Statuseinträge, die durch eine der teilnehmenden Regeln
	erstellt wurden, mit der individuellen Begrenzung der Regel
	überprüft.
	</ul>
Die gesamte Anzahl der Quell-IP-Adressen, die verfolgt werden, kann
systemweit durch die Verwendung der
<a href="options.html#limit"><tt>src-nodes</tt>-Laufzeitoption</a>
kontrolliert werden.

<dt><tt>max-src-nodes <i>anzahl</i></tt>
<dd>Wenn die <tt>source-track</tt>-Option genutzt wird, wird
<tt>max-src-nodes</tt> die Anzahl der Quell-IP-Adressen begrenzen, die
gleichzeitig einen Status anlegen können. Diese Option kann nur zusammen
mit <tt>source-track rule</tt> genutzt werden.

<dt><tt>max-src-states <i>anzahl</i></tt>
<dd>Wenn die <tt>source-track</tt>-Option verwendet wird,
wird <tt>max-src-states</tt> die Anzahl gleichzeitig erstellter
Statuseinträge begrenzen, die pro Quell-IP-Adresse angelegt werden
können.
Der Bereich dieser Begrenzung (z.&nbsp;B. Zustände, die nur durch
diese Regel erstellt wurden, oder  die durch alle Regeln unter
Verwendung von <tt>source-track</tt> erstellt wurden) ist abhängig von
der angegebenen <tt>source-track</tt>-Option.
</dl>

<p>
Optionen werden in Klammern und direkt nach einem der
Statusschlüsselwörter (<tt>keep state</tt>, <tt>modulate state</tt> oder
<tt>synproxy state</tt>) angegeben. Mehrere Optionen werden mit Kommas
getrennt. In OpenBSD 4.1 und späteren Versionen ist die Option
<tt>keep state</tt> implizierter Standard für alle Filterregeln.
Trotzdem muss bei der Angabe von Statusoptionen eines dieser
Statusschlüsselwörter vor der Option stehen.


<p>
Eine Beispielregel:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max 200, source-track rule, max-src-nodes 100,
max-src-states 3)
</tt>
</blockquote>

<p>
Die oben angegebene Regel sorgt für folgendes Verhalten:

<ul>
<li>Begrenze die maximale Anzahl der Zustände, die diese Regel
erstellen kann, auf 200
<li>Aktiviere Sourcetracking; begrenze die Anzahl möglicher
Statuserstellungen nur für diese Regel
<li>Begrenze die maximale Anzahl der Nodes, die gleichzeitig Zustände
erstellen, auf 100
<li>Begrenze die maximale Anzahl gleichzeitiger Zustände pro
Quell-IP auf 3
</ul>

<p>
Ein separater Satz von Begrenzungen kann auf zustandsabhängigen
TCP-Verbindungen gesetzt werden, die den dreifachen Handschlag vollzogen
haben.

<dl>
<dt><tt>max-src-conn <i>Nummer</i></tt>
<dd>Begrenzt die maximale Anzahl gleichzeitiger TCP-Verbindungen,
die den dreifachen Handschlag vollzogen haben, die ein einzelner Host
erstellen kann.
<dt><tt>max-src-conn-rate <i>Nummer</i> / <i>Intervall</i></tt>
<dd>Begrenzt die Rate der neuen Verbindungen, die zu einem bestimmten
Zeitintervall aufgebaut werden können.
</dl>

<p>
Beide Optionen beziehen automatisch die <tt>source-track
rule</tt>-Option mit ein und sind inkompatibel zu <tt>source-track
global</tt>.

<p>
Da diese Begrenzungen nur für TCP-Verbindungen gültig sind, die den
dreifachen Handschlag vollzogen haben, können aggressivere Aktionen
gegen die offensiven IP-Adressen durchgeführt werden.

<dl>
<dt><tt>overload &lt;<i>Tabelle</i>&gt;</tt>
<dd>Schreibt den IP-Adresse des offensiven Hosts in die benannte
Tabelle.
<dt><tt>flush [global]</tt>
<dd>Zerstöre alle anderen ,states', die auf diese Regel zutreffen und
die von dieser Quell-IP stammen.
Wenn <tt>global</tt> angegeben wird, zerstöre alle ,states', die auf
diese Quell-IP zutreffen, unabhängig davon, welche Regel diesen ,state'
erzeugt hat.
</dl>

<p>
Ein Beispiel:

<blockquote>
<tt>
table &lt;abusive_hosts&gt; persist<br>
block in quick from &lt;abusive_hosts&gt;<br>
<br>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www flags S/SA keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max-src-conn 100, max-src-conn-rate 15/5,
overload &lt;abusive_hosts&gt; flush)
</tt>
</blockquote>

<p>
Dies macht Folgendes:

<ul>
<li>Begrenzt die maximale Anzahl der Verbindungen pro Quelle auf 100
<li>Begrenzt die Rate der Anzahl der Verbindungen auf 15 pro
5-sekündiger Zeitspanne
<li>Schreibt die IP-Adresse jeglichen Hosts, der diese Begrenzungen
bricht, in die Tabelle <tt>&lt;abusive_hosts&gt;</tt>
<li>Für jegliche offensive IP-Adresse gilt, dass alle ,states', die
von dieser Regel erzeugt wurden, gelöscht werden.
</ul>

<a name="tcpflags"></a>
<h2>TCP-Flags</h2>
TCP-Pakete anhand ihrer Flags zu überprüfen wird meistens verwendet, um
TCP-Pakete zu filtern, die versuchen, eine neue Verbindung zu eröffnen.
Die TCP-Flags und ihre Bedeutungen sind hier aufgeführt:
<ul>
<li><b>F</b> : FIN  - Finish; Ende der Sitzung
<li><b>S</b> : SYN  - Synchronize; Weist auf eine Anfrage hin, eine Sitzung zu beginnen
<li><b>R</b> : RST  - Reset; Lasse eine Verbindung fallen
<li><b>P</b> : PUSH - Push; Paket wird umgehend gesendet
<li><b>A</b> : ACK  - Acknowledgement; Erhalten
<li><b>U</b> : URG  - Urgent; Dringend
<li><b>E</b> : ECE  - Explicit Congestion Notification Echo
<li><b>W</b> : CWR  - Congestion Window Reduced
</ul>

<p>
Damit PF die TCP-Flags während der Überprüfung einer Regel inspiziert,
muss das <tt>flags</tt>-Schlüsselwort mit folgender Syntax verwendet
werden:
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i><br>
flags any
</tt>
</blockquote>

<p>
Der <tt><i>mask</i></tt>-Teil teilt PF mit, nur die angegebenen Flags
zu inspizieren und der <tt><i>check</i></tt>-Teil gibt an, welche(r)
Flag(s) im Header aktiviert sein müssen, damit eine Übereinstimmung
stattfinden kann. Das Schlüsselwort <tt>any</tt> ermöglicht jede
erdenkliche Kombination der zu setzenden Optionen im Header.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
</tt>
</blockquote>

<p>
Die hier angegebene Regel lässt TCP-Verkehr mit gesetztem SYN-Flag
durch, während nur die SYN- und ACK-Flags überprüft werden. Ein
Paket mit den SYN- und ECE-Flags würde der oben genannten Regel
entsprechen, während ein Paket mit SYN und ACK oder nur ACK keine
Übereinstimmung hätte.

<p>
In OpenBSD 4.1 und späteren Versionen wird standardmäßig
<tt>flags S/SA</tt> für TCP-Regeln verwendet. Zusammen mit dem
OpenBSD-4.1-Standard <tt>keep state</tt> für Filterregeln sind diese
beiden Regeln gleichwertig:
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state<br>
pass out on fxp0 proto tcp all
</tt>
</blockquote>

<p>
Jede Regel wird auf TCP-Pakete reagieren, deren SYN-Flag gesetzt und
ACK-Flag nicht gesetzt ist, und einen Statuseintrag für die
zutreffenden Pakete anlegen. Die Standardflags können mit der Option
<tt>flags</tt> wie oben erläutert überschrieben werden.

<p>
In OpenBSD 4.0 und älteren Versionen wurden keine Standardflags
für Filterregeln angegeben. Jede Regel musste daher zu überprüfende
Flag(s) übergeben bekommen und explizit die Option <tt>keep state</tt>
gesetzt haben.
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>

<p>
Man sollte vorsichtig bei der Verwendung mit Flags sein - zu verstehen,
was du warum tust, und vorsichtig mit den Ratschlägen von Leuten zu
sein, die häufig schlechte geben. Einige Leute empfehlen das Erstellen
von ,states', "nur, wenn das SYN-Flag gesetzt ist und kein anderes".
Solch eine Regel würde wie folgt enden:
<pre>
     . . . flags S/FSRPAUEW  <i>bad idea!!</i>
</pre>

<p>
Die Theorie dahinter ist, dass nur am Anfang der TCP-Sitzung ein ,state'
erzeugt wird und die Sitzung nur mit einem SYN-Flag starten sollte, keinem
anderen. Das Problem ist, dass einige Seiten anfangen, das ECN-Flag zu
verwenden und jegliche Seite, die ECN verwendet und versucht,
sich zu dir zu verbinden, bei einer solchen Regel abgeblockt werden würde.
Eine bessere Möglichkeit ist es, überhaupt keine Flags anzugeben und
PF die Standardflags für deine Regeln übernehmen lassen. Wenn du
wirklich unbedingt selbst Flags angeben musst, dann sollte diese
Option sicher sein:
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
Während dies praktisch und sicher ist, ist das Überprüfen für die
FIN- und RST-Flags unnötig, wenn der Verkehr ebenfalls
<!--XXX scrub-->
,gescrubbed' wird. Der ,scrubbing'-Prozess
wird PF veranlassen, jegliche eingehenden Pakete mit ungültigen
TCP-Flag-Kombinationen (wie zum Beispiel SYN und RST) fallen zu
lassen und potenziell unklare Kombinationen (z.&nbsp;B. SYN und
FIN) zu normalisieren.


<a name="synproxy"></a>
<h2>TCP-SYN-Proxy</h2>
<p>
Wenn ein Client normalerweise eine TCP-Verbindung zu einem Server
aufbaut, wird PF die <a
href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml"
>Handschlag</a>-Pakete zwischen den beiden Endpunkten durchlassen, sobald
sie ankommen. PF hat jedoch die Fähigkeit, den Handschlag durch einen
Proxy zu senden.
Mit einem Handschlag, der durch einen Proxy gesendet wurde, wird PF selbst
den Handschlag mit dem Client absolvieren, einen Handschlag mit dem
Server beginnen und dann die Pakete zwischen den beiden durchlassen.
Der Vorteil von diesem Prozess ist, dass keine Pakete zum Server gesendet
werden, bevor der Client den Handschlag abgeschlossen hat.
Dies eliminiert die Gefahr eines ,spoofed' TCP-SYN-Floods, die den
Server beeinträchtigen könnten, weil die ,spoofed' Client-Verbindung
nicht in der Lage ist, den Handschlag zu vollenden.

<p>
Der TCP-SYN-Proxy wird durch die Verwendung der
<tt>synproxy state</tt>-Schlüsselworte in den Filterregeln aktiviert.
Beispiel:

<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
Hier werden die Verbindungen zum Webserver durch den TCP-Proxy von
PF gesendet.

<p>
Wegen der Funktionsweise von <tt>synproxy state</tt> beinhaltet es
die gleiche Funktionalität wie <tt>keep state</tt> und <tt>modulate
state</tt>.

<p>
Der SYN-Proxy wird nicht mit PF funktionieren, wenn dieser auf einer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a> läuft.

<a name="antispoof"></a>
<h2>,spoofed' Pakete blocken</h2>
Adress-,spoofing' liegt vor, wenn ein böswilliger Benutzer die
Quell-IP-Adresse in den Paketen ändert, die versendet werden, um entweder
seine tatsächliche Adresse zu verbergen oder um so zu wirken, als würde
er ein anderes Gerät im Netzwerk bedienen. Sobald ein Benutzer eine
,spoofed' Adresse hat, kann er Netzwerkattacken durchführen, ohne seine
wahre Herkunft offenzulegen, oder erreicht Zugriff auf Netzwerkdienste,
die nur bestimmten IP-Adressen ermöglicht werden sollen.

<p>
PF bietet einen gewissen Schutz gegen Adress-,spoofing' durch das
<tt>antispoof</tt>-Schlüsselwort:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Gibt ab, ob das zutreffende Paket via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.6"
>pflogd(8)</a> aufgezeichnet werden soll.

<dt><tt>quick</tt>
<dd>Wenn ein Paket auf diese Zeile zutrifft, wird es als ,Gewinner'-Regel
angesehen und die Verarbeitung des Regelsatzes angehalten.

<dt><tt><i>interface</i></tt>
<dd>Das Netzwerk-Interface, auf dem ,spoofing'-Schutz aktiviert werden
soll. Dies kann ebenfalls eine <a href="macros.html#lists">Liste</a>
von Interfaces sein.

<dt><tt><i>af</i></tt>
<dd>Die Adress-Familie, für die der ,spoofing'-Schutz aktiviert werden
soll, entweder <tt>inet</tt> für IPv4 oder <tt>inet6</tt> für IPv6.
</dl>

<p>
Beispiel:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Wenn ein Regelsatz geladen wird, wird jedes Vorkommen des
<tt>antispoof</tt>-Schlüsselwortes in zwei Filterregeln eingesetzt.
Angenommen, dass das Interface <tt>fxp0</tt> die IP-Adresse 10.0.0.1 und eine
Subnetz-Maske von 255.255.255.0 hat (z.&nbsp;B. /24), dann würde die
oben angegebene <tt>antispoof</tt>-Regel wie folgt entwickelt werden:

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Diese Regeln erreichen zwei Dinge:
<ul>
<li>Blockt den gesamten Verkehr, der vom 10.0.0.0/24-Netzwerk kommt, der
<i>nicht</i> durch <tt>fxp0</tt> hereinkommt. Da das 10.0.0.0/24-Netzwerk
auf dem <tt>fxp0</tt>-Interface liegt, dürften Pakete mit Quell-Adressen aus
diesem Netzwerkblock niemals auf anderen Interfaces gesehen werden können.
<li>Blockt den gesamten Verkehr von 10.0.0.1, der IP-Adresse von
<tt>fxp0</tt>.
Die Host-Maschine dürfte niemals Pakete zu sich selbst durch ein externes
Interface senden, sodass alle eingehenden Pakete mit der Source-Adresse,
die an dieser Maschine ankommen, als böswillig angesehen werden können.
</ul>

<p>
<b>HINWEIS</b>. Die Filterregeln, die aus der <tt>antispoof</tt>-Regel
hervorgehen, blocken ebenfalls Pakete, die über das Loopback-Interface
zur lokalen Adresse gesendet werden. Es ist sowieso ein guter Stil, wenn
man auf Loopbackinterfaces nicht filtert - doch bei der Verwendung von
antispoof-Regeln ist das eine Notwendigkeit:
<blockquote>
<tt>
set skip on lo0 all<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Die Verwendung von <tt>antispoof</tt> sollte auf Interfaces beschränkt
werden, denen eine IP-Adresse zugewiesen wurde. Wenn <tt>antispoof</tt>
auf ein Interface angewandt wird, das keine IP-Adresse hat, wird das in
Filterregeln enden, die so ähnlich wie folgende aussehen werden:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Mit diesen Regeln besteht die Gefahr, dass der <i>gesamte</i> eingehende
Verkehr auf <i>allen</i> Interfaces geblockt wird.

<a name="urpf"></a>
<h2>Unicast Reverse Path Forwarding</h2>

<p>
Beginnend mit <a href="../../../de/40.html">OpenBSD 4.0</a> bietet
PF »Unicast Reverse Path Forwarding« (uRPF) an. Wenn ein Paket durch
eine uRPF-Routine überprüft wird, so wird die Quell-IP-Adresse des
Pakets in der Routingtabelle nachgesehen. Wenn das weiterführende
Interface das gleiche ist, über das das Paket hereingekommen ist, so
wird die uRPF-Überprüfung das Paket durchlassen. Sollten sich die
Interfaces unterscheiden, so kann es sich um eine gefälschte
Quelladresse handeln.

<p>
Die uRPF-Überprüfung für Pakete kann mit dem
<tt>urpf-failed</tt>-Schlüsselwort in den Filterregelsätzen aktiviert
werden:

<blockquote>
<tt>
block in quick from urpf-failed label uRPF
</tt>
</blockquote>

<p>
Denk daran, dass die uRPF-Überprüfung nur in Umgebungen Sinn macht,
in denen das Routing symmetrisch abläuft.

<p>
uRPF bietet die gleiche Funktionalität wie
<a href="#antispoof">Antispoof</a>-Regeln.


<a name="osfp"></a>
<h2>Passives Betriebssystem-,Fingerprinting'</h2>

<p>
Passives OS-,Fingerprinting' (OSFP) ist eine Methode zum passiven
Ermitteln des Betriebssystems auf dem gegenüberliegendem Host, basierend
auf bestimmten Kriterien in den TCP-SYN-Paketen des Hosts. Diese
Information kann dann als Kriterium in Filterregeln verwendet werden.

<p>
PF ermittelt das entfernte Betriebssystem, indem die Charakteristiken
des TCP-SYN-Pakets mit denen in der
<a href="options.html#fingerprints">,fingerprints'-Datei</a> verglichen
werden, welche standardmäßig
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.6"
><tt>/etc/pf.os</tt></a> ist.
Sobald PF aktiviert wurde, kann die aktuelle ,fingerprint'-Liste mit diesem
Kommando angesehen werden:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Innerhalb der Filterregel kann ein ,fingerprint' anhand der OS-Klasse,
-Version oder -Untertyp/-Patchlevel angegeben werden.
Jedes dieser Objekte wird in der Ausgabe des angegebenen
<tt>pfctl</tt>-Kommandos aufgelistet. Um einen ,fingerprint' in einer
Filterregel anzugeben, wird das <tt>os</tt>-Schlüsselwort verwendet:

<blockquote>
<tt>
pass &nbsp;in on $ext_if from any os OpenBSD keep state<br>
block in on $ext_if from any os "Windows 2000"<br>
block in on $ext_if from any os "Linux 2.4 ts"<br>
block in on $ext_if from any os unknown
</tt>
</blockquote>

<p>
Die spezielle Betriebssystem-Klasse <tt>unknown</tt> erlaubt es, dass
alle Pakete zutreffen, wenn der ,fingerprint' des OS unbekannt ist.

<p>
Folgendes sollte <font color="#ff0000">ZUR KENNTNIS GENOMMEN WERDEN</font>:
<ul>
  <li>Betriebssystem-,fingerprints' sind ab und zu falsch, da ,spoofed'
  oder erstellte Pakete so gemacht worden sind, dass sie so aussehen,
  als wenn sie von einem spezifischen Betriebssystem kommen würden.
  <li>Bestimmte Revisionen oder Patchlevel eines Betriebssystems können
  das Verhalten vom ,stack' ändern und daher dazu führen, dass der
  ,fingerprint' nicht mehr übereinstimmt oder wie ein anderer Eintrag
  wirkt.
  <li>OSFP funktioniert nur mit TCP-SYN-Paketen; es wird nicht mit anderen
  Protokollen oder bereits aufgebauten Verbindungen funktionieren.
</ul>

<a name="ipopts"></a>
<h2>IP-Optionen</h2>
Standardmäßig blockt PF alle Pakete, die IP-Optionen haben. Dies kann
die Arbeit für ,OS fingerprinting'-Anwendungen wie nmap erschweren.
Wenn du eine Applikation hast, die das Durchlassen dieser Pakete
erfordert, wie zum Beispiel Multicast oder IGMP, kannst du die
<tt>allow-opts</tt>-Direktive verwenden:
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Beispiel-Filterregelsatz</h2>
Weiter unten ist ein Beispiel für einen Filterregelsatz. Auf der
Maschine läuft PF, die als Firewall zwischen einem kleinen, internen
Netzwerk und dem Internet fungiert. Nur die Filterregeln werden
angezeigt;
<a href="queueing.html">queueing</a>,
<a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>
etc. wurden aus diesem Beispiel herausgelassen.
<br>
<br>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# tabelle, die alle IP-Adressen beinhaltet, die der firewall zugewiesen
# worden sind
table &lt;firewall&gt; const { self }

# filtere nicht das loopback-interface
set skip on lo0

# ,scrub' auf alle eingehenden pakete anwenden
match in all scrub (no-df)

# eine richtlinie zum standardmäßigen blocken errichten
block all

# ,spoofing'-schutz für alle interfaces.
block in quick from urpf-failed

# nur ssh-verbindungen vom lokalen netzwerk erlauben, wenn es von dem
# computer 192.168.0.15 kommt, dem man vertrauen kann. verwende
# ,block return', sodass ein TCP-RST gesendet wird, um blockierte
# Verbindungen sofort zu schließen. verwende ,quick', sodass diese
# regel nicht von der ,pass'-regel weiter unten überschrieben wird.
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh

# den gesamten verkehr von und zum lokalen netzwerk durchlassen.
# diese regeln werden statuseinträge erstellen, da die standardoption
# "keep state" automatisch übernommen wird.
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net

# tcp, udp und icmp durch das externe (internet-)interface rauslassen.
# tcp-verbindungen werden reguliert, udp/icmp-verbindungen werden
# statusüberwacht.
pass out on $ext_if proto { tcp udp icmp } all modulate state

# erlaube eingehende ssh-verbindungen auf dem externen interface, so
# lange sie NICHT für die firewall bestimmt sind (z.&nbsp;B. wenn sie an
# eine maschine im lokalen netzwerk gerichtet sind). zeichne das erste
# paket auf, sodass wir später sagen können, wer versucht, zu verbinden.
# verwende den tcp-syn-proxy um einen proxy für diese verbindung
# aufzubauen. die standardflags "S/SA" werden dieser regel automatisch
# von PF übergeben.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
   port ssh synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Zurück: Tabellen</a>]
[<a href="index.html">Inhalt</a>]
[<a href="nat.html">Weiter: Network Address Translation</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[zurück]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: filter.html,v 1.53 ]<br>
$Translation: filter.html,v 1.40 2009/12/20 13:19:16 tobias Exp $<br>
-->
$OpenBSD: filter.html,v 1.37 2009/12/22 17:49:10 ajacoutot Exp $
</small>

</body>
</html>

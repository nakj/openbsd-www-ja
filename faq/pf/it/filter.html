<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Packet Filtering</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2007 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../it/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="tables.html">Precedente: Tabelle</a>]
[<a href="index.html">Indice</a>]
[<a href="nat.html">Successivo: Network Address Translation</a>]

<h1><font color="#e00000">PF: Packet Filtering</font></h1>

<hr>

<h3>Table of Contents</h3>
<ul>
<li><a href="#intro">Introduzione</a>
<li><a href="#syntax">Sintassi della regola</a>
<li><a href="#defdeny">Rifiuto di default</a>
<li><a href="#pass">Traffico passante</a>
<li><a href="#quick">La keyword <tt>quick</tt></a>
<li><a href="#state">Keeping State</a>
<li><a href="#udpstate">Keeping State per l'UDP</a>
<li><a href="#stateopts">Opzioni di Stateful Tracking</a>
<li><a href="#tcpflags">I flag TCP</a>
<li><a href="#synproxy">TCP SYN Proxy</a>
<li><a href="#antispoof">Blocco di pacchetti contraffatti</a>
<li><a href="#urpf">Unicast Reverse Path Forwarding</a>
<li><a href="#osfp">Riconoscimento passivo di sistema operativo</a>
<li><a href="#ipopts">Opzioni IP</a>
<li><a href="#example">Esempio di regole di configurazione</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Introduzione</h2>
Il Packet filtering è il selettivo passaggio o blocco di pacchetti 
attraverso un'interfaccia di rete. I criteri utilizzati da 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.2"
>pf(4)</a> nell'analisi dei pacchetti sono basati sugli headers dei Layer 3 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a> e 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4"
>IPv6</a>) e Layer 4
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4"
>ICMP</a>, e
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4"
>ICMPv6</a>). I criteri più spesso utilizzati sono l'indirizzo sorgente e 
destinazione, porta sorgente e destinazione e protocollo.

<p>
Le regole di filtraggio specificano il criterio da utilizzare per 
analizzare un pacchetto deve essere confrontato e l'azione da 
intraprendere, blocco o passaggio, quando vi è una corrispondenza. 
Le regole di filtraggio sono valutate in ordine sequenziale, 
dalla prima alll'ultima. A meno che non si abbia una 
corrispondenza con una regola contenente la keyword 
<tt>quick</tt>, il pacchetto sarà controllato con <i>tutte</i> le 
regole di filtraggio prima di intraprendere l'azione finale. L'ultima 
regola di confronto è la "vincente" e decide quale azione eseguire sul 
pacchetto. Esiste una regola implicita del <tt>pass all</tt> all'inizio 
delle regole di configurazione, questo significa che se non vi dovesse 
essere alcuna corrispondenza con le regole del filtro, il pacchetto 
sarà fatto passare.

<a name="syntax"></a>
<h2>Sintassi della regola</h2>
La sintassi <i>semplificata</i> per la regola di filtraggio è:
<blockquote>
<tt>
<i>action</i> [<i>direction</i>] [log] [quick] [on <i>interface</i>] 
[<i>af</i>] [proto <i>protocol</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>src_addr</i> [port <i>src_port</i>]] [to 
<i>dst_addr</i> [port <i>dst_port</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>action</i></tt>
<dd>L'azione da intraprendere per i pacchetti per i quali c'è una 
corrispondenza sarà <tt>pass</tt> o <tt>block</tt>. L'azione di 
<tt>pass</tt> porta il pacchetto al kernel per processarlo 
ulteriormente mentre l'azione di <tt>block</tt> sarà dettata dalle 
opzioni stabilite nella 
<a href="options.html#block-policy"><tt>block-policy</tt></a>. 
L'azione di default può essere esclusa specificando 
<tt>block drop</tt> o <tt>block return</tt>. 

<dt><tt><i>direction</i></tt>
<dd>La direzione con la quale il pacchetto si muove attraverso 
l'interfaccia, <tt>in</tt> oppure <tt>out</tt>. 

<dt><tt>log</tt>
<dd>Specifica che il pacchetto dovrebbe essere loggato con 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.2"
>pflogd(8)</a>. Se la regola crea uno stato solo il pacchetto 
che stabilisce lo stato viene loggato. Per erffettuare il log di 
tutti i pacchetti usare <TT>log-all</TT>. 

<dt><tt>quick</tt>
<dd>Se un pacchetto ha una corrispondenza con una regola che
specifica <tt>quick</tt>, quella regola viene considerata l'ultima 
regola di confronto e viene intrapresa quella specifica 
<tt><i>azione</i></tt>.

<dt><tt><i>interface</i></tt>
<dd>Il nome o il gruppo di interfaccia di rete attraverso la quale 
il pacchetto si sta muovendo.
Le interfaccie possono essere aggiunte a gruppi arbitrari usando il comando:
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>.
Alcuni gruppi vengono creati automaticamente anche dal kernel:
<ul>
<li>Il gruppo <tt>egress</tt>, che ospita le interfaccie che contengono le
rotte di default.
<li>Il gruppo di famiglia di interfaccia per le copie di interfaccie.
Per esempio: <tt>ppp</tt> o <tt>carp</tt>.
</ul>
Questo permetterebbe di avere regole con corrispondenza a ogni pacchetto
che attraversa qualsiasi interfaccia <tt>ppp</tt> o <tt>carp</tt>.

<dt><tt><i>af</i></tt>
<dd>La famiglia di indirizzi del pacchetto, <tt>inet</tt> per IPv4 
oppure <tt>inet6</tt> per IPv6. Di solito PF è in grado di determinare 
questo parametro basandosi sull'indirizzo sorgente e/o destinazione. 

<dt><tt><i>protocol</i></tt>
<dd>Il protocollo del Layer 4 del pacchetto: 
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Un nome di protocollo valido da 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5"
><tt>/etc/protocols</tt></a>
<li>Un numero di protocollo compreso tra 0 e 255
<li>Un insieme di protocolli usando una <a href="macros.html#lists">lista</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 
<dd>L'indirizzo sorgente/destinazione dell'header IP. Gli indirizzi 
possono essere specificati come:
<ul>
<li>Un singolo indirizzo IPv4 e IPv6. 
<li>Un blocco di <a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a> 
network.
<li>Un nome di dominio assegnato che viene risolto via DNS 
quando vengono caricate le regole di configurazione. Tutti gli 
indirizzi IP corrispondenti saranno sostituiti nelle regole. 
<li>Il nome di un'interfaccia di rete o di un gruppo di interfaccie. 
Ogni indirizzo IP assegnato all'interfaccia sarà sostituito nella regola.
<li>Il nome di un'interfaccia di rete seguita da
<tt>/<i>netmask</i></tt> (per esempio, <tt>/24</tt>). Ogni indirizzo 
IP di un'interfaccia è associata con la netmask per formare un blocco 
CIDR network sostituito nelle regole.
<li>Il nome di un'interfaccia di rete tra parentesi <tt>( )</tt>. 
Questo suggerisce a PF di aggiornare le regole se dovessero cambiare 
gli indirizzi dell'interfaccia. E' utile per un'interfaccia che ottiene 
il suo indirizzo IP via DHCP o in dial-up così da evitare di ricaricare 
le regole di configurazione ogni volta che cambia l'indirizzo.
<li>Il nome di un'interfaccia di rete seguita da uno di questi 
parametri:
  <ul>
  <li><tt>:network</tt> - sostituisce il blocco di CIDR network 
  (per esempio, 192.168.0.0/24) 
  <li><tt>:broadcast</tt> - sostituisce l'indirizzo di broadcast 
  (per esempio, 192.168.0.255) 
  <li><tt>:peer</tt> - sostituisce l'indirizzo peer IP in un 
  collegamento point-to-point 
  </ul>
  <dl>
  <dd>Inoltre il parametro <TT>:0</TT> può seguire sia il nome di 
  un'interfaccia oppure ognuno dei parametri visti precedentemente e 
  indica che PF non dovrebbe includere indirizzi IP alias nella 
  sostituzione. Questi parametri possono anche essere usati quando 
  l'interfaccia è contenuta tra parentesi.
  Esempio: <tt>fxp0:network:0</tt>
  </dl>
<li>Una <a href="tables.html">tabella</a>.
<li>La keyword <tt>urpf-failed</tt> può essere usata per un indirizzo sorgente 
ad indicare che dovrebbe essere eseguita attraverso il
<a href="#urpf">controllo uRPF</a>.
<li>Ognuno dei parametri precedenti ma negati usando il parametro <tt>!</tt> ("not"). 
<li>Un set di indirizzi usando una <a href="macros.html#lists">lista</a>.
<li>La keyword <tt>any</tt> ad indicare tutti gli indirizzi 
<li>La keyword <tt>all</tt> che indica <tt>from any to any</tt> 
cioè da ovunque a ovunque. 
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>La porta sorgente/destinazione nell'header dell'Layer 4. Le porte 
possono essere specificate come: 
<ul>
<li>Un numero tra 1 e 65535 
<li>Un nome di servizio valido da 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5"
><tt>/etc/services</tt></a>
<li>Un set di porte usando una <a href="macros.html#lists">lista</a>
<li>Un range: 
	<ul>
	<li><tt>!=</tt> (diverso)
	<li><tt>&lt;</tt> (minore)
	<li><tt>&gt;</tt> (maggiore)
	<li><tt>&lt;=</tt> (minore o uguale)
	<li><tt>&gt;=</tt> (maggiore o uguale)
	<li><tt>&gt;&lt;</tt> (range)
	<li><tt>&lt;&gt;</tt> (range inverso)
	<dl>
	<dd>Gli ultimi due operatori sono binari (prendono due 
        argomenti) e non includono gli argomenti nel range.
	</dl>
	<li><tt>:</tt> (range inclusivo)
	<dl>
	<dd>Anche l'operatore di range inclusivo è un operatore binario 
        e include gli argomenti nel range.
	</dl>
	</ul>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd>Specifica i flag che devono essere settati nel TCP header quando 
si usa un <tt>protocollo tcp</tt>. I flag sono definiti come 
<tt>flags <i>check</i>/<i>mask</i></tt>. Per esempio:<tt>flags S/SA</tt> - 
  questo istruisce PF a cercare solo pacchetti con flag S e A 
(SYN e ACK) e a considerare una corrispondenza solo quando il flag 
SYN è "on". 
In OpenBSD 4.1 e successivi, i flag di default <tt>S/SA</tt> sono applicati 
a tutte le regole di filtraggio.

<dt><tt><i>state</i></tt>
<dd>Specifica se informazioni di stato sono conservate per pacchetti 
che hanno corrispondenza con questa regola.
<ul>
<li><tt>keep state</tt> - funziona con TCP, UDP, e ICMP.
In OpenBSD 4.1 e successivi, questa opzione è di default per tutte le regole
di filtraggio.
<li><tt>modulate state</tt> - funziona solo con TCP. PF genera un 
numero di sequenza iniziale (ISNs) non facilmente prevedibile per 
pacchetti che hanno una corrispondenza con questa regola. 
<li><tt>synproxy state</tt> - connessioni proxy TCP in ingresso per 
proteggere il server da flood TCP SYN contraffatti. Questa opzione 
include la funzionalità <tt>keep state</tt> e <tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Default Deny</h2>
Quando si configura un firewall è raccomandato un approcio 
"default deny". Cioè negare il transito a <i>tutto</i> e consentire 
selettivamente che determinati pacchetti passino attraverso il 
firewall. Questo approcio è raccomandato perchè è cautelativo e 
consente di scrivere più facilmente le regole di configurazione.

<p>
Per creare un firewall con una policy default deny le prime due 
regole dovrebbero essere:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Queste bloccano tutto il traffico su tutte le interfaccie in ogni 
direzione da ovunque a ovunque.

<a name="pass"></a>
<h2>Traffico passante</h2>
Ora il traffico deve essere fatto passare esplicitamente attraverso 
il firewall altrimenti verrà gettato dalla policy deny di default. 
Qui entrano in gioco i criteri di confronto come porta 
sorgente/destinazione, indirizzo sorgente/destinazione e protocollo. 
Le regole che consentono al traffico di passare attraverso il firewall 
dovrebbero comunque essere scritte per essere le più restrittive 
possibili. Questo affinchè sia consentito il passaggio al solo 
traffico desiderato.

<p>
Qualche esempio:
<blockquote>
<tt>
# Passaggio del traffico in ingresso alla dc0 dalla rete locale 192.168.0.0/24,<br>
# alla macchina OpenBSD con indirizzo IP 192.168.0.1. Inoltre consentire il traffico<br>
# di ritorno in uscita sulla dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Consentire il passaggio del traffico TCP in ingresso all'interfaccia fxp0 al<br>
# web server in esecuzione sulla macchina OpenBSD. Il nome dell'interfaccia, fxp0,<br>
# è usata come indirizzo di destinazione, così i pacchetti soddisferanno solo questa<br>
# regola per essere destinati alla macchina OpenBSD pass in on fxp0 proto tcp from any<br>
# to fxp0 port www<br>
</tt>
</blockquote>

<a name="quick"></a>
<h2>La keyword <tt>quick</tt></h2>
Come desritto precedentemente, ogni pacchetto è valutato dalla prima 
all'ultima regola di configurazione. Di default, il pacchetto viene 
segnato nel passaggio, questo può essere cambiato a ogni regola, 
potrebbe essere cambiato diverse volte prima della fine delle regole di 
filtraggio.<b>L'ultima regola che ha una corrispondenza "vince".</b> 
C'è un'eccezione a tutto questo. L'opzione <tt>quick</tt> su una regola 
di filtraggio ha l'effetto di cancellare ogni ulteriore regola e di 
intraprendere la specifica azione. Diamo un'occhiata ad un paio di 
esempi:

<p>
Sbagliato: 
<blockquote>
<tt>
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
In questo caso la regola di <TT>blocco</TT> viene considerata ma non 
avrà mai alcun effetto perchè è seguita da una linea che consente il 
passaggio di tutto il traffico.

<p>
Meglio:
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Queste regole vengono valutate un pò differentemente. Se la regola di 
<tt>blocco</tt> ha una corrispondenza, a causa dell'opzione 
<tt>quick</tt>, il pacchetto sarà bloccato e le regole successive 
ignorate. 

<a name="state"></a>
<h2>Keeping State</h2>
Una proprietà importante di Packet Filter è il "keeping state" o 
"stateful inspection". Stateful inspection è la capacità di PF di 
tracciare lo stato o il progresso di una connessione di rete. 
Conservando in una tabella di stato le informazioni relative a ogni 
connessione, PF è in grado, velocemente, di determinare se un pacchetto 
che attraversa il firewall appartiene a una connessione già esistente. 
Se vi appartiene il pacchetto attraversa il firewall senza essere 
verificato da tutte le regole di configurazione.

<p>
Keeping state ha molti vantaggi tra i quali regole di configurazione 
più semplici e migliori performance di packet filtering. PF è in grado 
di effettuare un confronto con pacchetti che si muovono in 
<i>entrambe</i> le direzioni rispetto ai dati conservati nella tabella 
di stato, questo significa che le regole di filtaggio per i pacchetti 
in risposta su una connessione tracciata non devono essere scritte. 
E dato che i pacchetti che appartengono a una stateful connection non 
devono passare attraverso la valutazione delle regole di 
configurazione, il tempo impiegato da PF per processare questi 
pacchetti è notevolmente inferiore.

<p>
Quando una regola permette di creare uno stato, il primo pacchetto 
che soddisfa la regola crea uno "stato" tra client e server. Ora, non 
solo i pacchetti che vanno dal client al server soddisfano l'opzione 
keep state e attraversano il firewall senza ulteriori controlli ma così 
fanno anche i pacchetti di risposta tra server e client.

<p>
A partire da OpenBSD 4.1, tutte le regole di filtraggio creano automaticamente 
uno stato nella tabella quando vi è una corrispondenza con una reagola.
Nelle precedenti versioni occorreva specificare l'opzione <tt>keep state</tt>.

<p>
Esempio che utilizza OpenBSD 4.1 e successive versioni:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any
</tt>
</blockquote>

<p>
Esempio che utilizza OpenBSD 4.0 e versioni precedenti:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
Questo consente a tutto il traffico TCP in uscita dall'interfaccia 
<tt>fxp0</tt> e al corrispondente traffico di risposta di oltrepassare 
le regole del firewall. L'uso del keep state migliora in modo 
significativo le performance del firewall e i confronti con la tabella 
di stato sono incredibilmente più veloci rispetto al passaggio 
attraverso tutte le regole del firewall. 

<p>
L'opzione <tt>modulate state</tt> funziona come il <tt>keep state</tt> 
ma si applica solo ai pacchetti TCP. Con l'opzione 
<tt>modulate state</tt> il numero di sequenza iniziale 
(Initial Sequence Number - ISN) delle connessioni in uscita è random. 
Questo è utile per proteggere le connessioni iniziali con 
alcuni sistemi operativi che hanno un prevedibile ISN. A partire da 
OpenBSD 3.5, l'opzione <tt>modulate state</tt> può essere usata in 
regole che utilizzano altri protocolli oltre il TCP.

<p>
Keep state sul traffico in uscita TCP, UDP, ICMP e modulate su 
TCP ISN: 
<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Un altro vantaggio del keeping state è che il corrispondente traffico 
ICMP oltrepassa il firewall. Per esempio se in una connessione 
TCP tracciata arriva un messaggio ICMP source-quench riferito a questa 
connessione, verrà verificata la corrispondenza con la tabella di stato 
e il messaggio ICMP oltrepasserà le regole del firewall.

<p>
Il controllo dei dati della tabella di stato è ottenuta globalmente 
dalle opzioni runtime 
<a href="options.html#state-policy"><tt>state-policy</tt></a> e sulla 
base di ogni regola dalle opzioni keyword <tt>if-bound</tt>, 
<tt>group-bound</tt>, e <tt>floating</tt> state. Queste keyword hanno 
lo stesso significato anche se usate con l'opzione 
<tt>state-policy</tt>. Esempio:

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Questa regola imporrebbe che affinchè i pacchetti abbiano una 
corrispondenza con la tabella di stato devono transitare attraverso 
l'interfaccia <tt>fxp0</tt>.

<p>
Da notare che le regole <a href="nat.html"><tt>nat</tt></a>, 
<a href="nat.html#binat"><tt>binat</tt></a>, e
<a href="rdr.html"><tt>rdr</tt></a> implicitamente creano stati che 
restano tali fin quando la connessione attraversa le regole di 
configurazione.

<a name="udpstate"></a>
<h2>Keeping State per l'UDP</h2>
Si sentirà dire che "Non si può creare uno stato con l'UDP perchè l'UDP 
è un protocollo stateless!" cioè senza stato. E' vero che una sessione 
di comunicazione UDP non ha nessun stato (un esplicito inizio e una 
esplicita fine della comunicazione), ma PF è in grado di crearne una 
per ogni session UDP. Nel caso di protocolli con pacchetti senza 
"inizio" e "fine", PF semplicemente tiene traccia del tempo trascorso 
dall'ultima corrispondenza con un pacchetto. Se si è raggiunto un 
tempo limite, lo stato viene cancellato. Il valore di questo 
intervallo di tempo può essere settato  
<a href="options.html">options</a> nella sezione del file <tt>pf.conf</tt>.

<a name="stateopts"></a>
<h2>Opzioni di Stateful Tracking</h2>

Quando una regola crea un nuovo stato nella tabella di stato possono essere 
specificate alcune opzioni che controllano come deve essere creato lo stato. 
Sono disponibili le seguenti opzioni: 

<dl>
<dt><tt>max <i>number</i></tt>
<dd>Limita il numero massimo di stati creati dalla regola a 
<i>number</i>. Se il numero massimo viene raggiunto, il pacchetto che 
creerebbe lo stato viene gettato finchè non decresce il numero di 
stati esistenti. 

<dt><tt>no state</tt>
<dd>Blocca la creazione automatica di uno stato.

<dt><tt>source-track</tt>
<dd>Questa opzione abilita il tracciamento del numero di stati creati 
per indirizzo IP sorgente. 
Questa opzione ha due formati:
	<ul>
	<li><tt>source-track rule</tt> - Il numero massimo di stati creati 
	da questa regola è limitato dalle opzioni <tt>max-src-nodes</tt> e 
	<tt>max-src-states</tt>. Solo gli stati creati da questa particolare 
	regola contano per i limiti della regola. 
	<li><tt>source-track global</tt> - Il numero di stati creati da 
	tutte le regole che usano questa opzione è limitato. Ogni regola può 
	specificare differenti opzioni <tt>max-src-nodes</tt> e 
	<tt>max-src-states</tt>, comunque gli stati creati da ogni regola 
	contano per i limiti di ogni singola regola.
	</ul>
Il numero totale di indirizzi IP sorgente tracciati globalmente può essere 
controllata con 
<a href="options.html#limit"><tt>src-nodes</tt> runtime option</a>.

<dt><tt>max-src-nodes <i>number</i></tt>
<dd>Quando l'opzione <tt>source-track</tt> è usata, 
<tt>max-src-nodes</tt> limiterà il numero di indirizzi IP sorgente che 
simultaneamente possono creare stati. Questa opzione può essere usata 
 solo con la regola <tt>source-track</tt>.  

<dt><tt>max-src-states <i>number</i></tt>
<dd>Quando l'opzione <tt>source-track</tt> è usata, 
<tt>max-src-states</tt> limiterà il numero di stati simultanei che 
possono essere creati per indirizzo IP sorgente. Lo scopo di questo 
limite (per esempio, stati creati solo da questa regola o stati creati 
da tutte le regole che usano <tt>source-track</tt>) è in funzione 
dell'opzione <tt>source-track</tt> specificata.
</dl>

<p>
Le opzioni sono specificate all'interno delle parentesi e immediatamente dopo
una delle keyword di stato (<tt>keep state</tt>, <tt>modulate state</tt>, o
<tt>synproxy state</tt>).
Opzioni multiple sono separate da virgole. In OpenBSD 4.1 e versioni successive
l'opzione <tt>keep state</tt> diviene implicita in tutte le regole.
Comunque, quando si specificano le opzioni una delle keyword di stato deve 
essere specificata prima delle opzioni.

<p>
Un esempio di regola:

<blockquote>
<tt>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max 200, source-track rule, max-src-nodes 100,
max-src-states 3)
</tt>
</blockquote>

<p>

La regola precedente si comporta così:

<ul>
<li>Limita il numero assoluto massimo di stati che questa regola può 
creare a 200 
<li>Abilita il source tracking; limita la creazione di stati solo 
sulla base degli stati creati da questa regola 
<li>Limita a 100 il numero massimo di nodi che simultaneamente 
possono creare stati 
<li>Limita a 3 il numero massimo di stati creati simultaneamente per 
indirizzo IP sorgente 
</ul>

<p>
Un set separato di restrizioni può essere usato su connessioni 
TCP che hanno completato l'handshake a 3 vie.

<dl>
<dt><tt>max-src-conn <i>number</i></tt>
<dd>Limita il numero massimo di connessioni simultanee TCP che hanno
completato l'handshake a tre vie che un singolo host può effettuare.
<dt><tt>max-src-conn-rate <i>number</i> / <i>interval</i></tt>
<dd>Limita il numero di nuove connessioni ad un certo valore per 
intervallo di tempo. 
</dl>

<p>
Entrambe queste opzioni automaticamente invocano 
l'opzione <tt>source-track</tt> e sono incompatibili con il 
<tt>source-track global</tt>. 

<p>
Dato che questi limiti sono utilizzati solo su connessioni TCP che 
hanno completato l'handshake 3-way, possono essere intraprese azioni 
più tenaci per tutti gli indirizzi IP con comportamenti scorretti.

<dl>
<dt><tt>overload &lt;<i>table</i>&gt;</tt>
<dd>Mette un indirizzo IP scorretto nella tabella 
<dt><tt>flush [global]</tt>
<dd>Elimina ogni altro stato che ha una corrispondenza con questa 
regola ed è creato da questo IP sorgente. Quando viene specificato 
<tt>global</tt>, elimina tutti gli stati corrispondenti a questo 
indirizzo IP sorgente senza tener conto di quale regola ha creato lo 
stato.
</dl>

<p>
Un esempio:

<blockquote>
<tt>
table &lt;abusive_hosts&gt; persist<br>
block in quick from &lt;abusive_hosts&gt;<br>
<br>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www flags S/SA keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max-src-conn 100, max-src-conn-rate 15/5,
overload &lt;abusive_hosts&gt; flush)
</tt>
</blockquote>

<p>
This does the following:

<ul>
<li>Limita il numero massimo di connessioni per sorgente a 100
<li>Il limite è di 15 connessioni ogni 5 secondi 
<li>Inserisce gli indirizzi IP degli host che oltrepassano questi 
limiti nella tabella 
<tt>&lt;abusive_hosts&gt;</tt>
<li>Per ogni indirizzo IP con comportamento scorretto ripulisce ogni 
stato creato da questa regola. 
</ul>

<a name="tcpflags"></a>
<h2>TCP Flags</h2>
La verifica di pacchetti TCP basato sui flag è il più delle volte 
usato per filtrare pacchetti TCP che tentano di effettuare una nuova  
connessione. I flag TCP e il loro significato sono riportati di 
seguito:
<ul>
<li><b>F</b> : FIN  - Finish; fine della sessione
<li><b>S</b> : SYN  - Synchronize; indica la richiesta di aprire una sessione
<li><b>R</b> : RST  - Reset; chiude una connessione
<li><b>P</b> : PUSH - Push; il pacchetto viene inviato immediatamente
<li><b>A</b> : ACK  - ricevuto
<li><b>U</b> : URG  - urgente
<li><b>E</b> : ECE  - notifica di echo di esplicita congestione
<li><b>W</b> : CWR  - finestra di congestione ridotta
</ul>

<p>
Per fare in modo che PF controlli i flag TCP in una regola, deve essere 
usata la keyword <tt>flags</tt> con la seguente sintassi: 
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i><br>
flags any
</tt>
</blockquote>

<p>
La <tt><i>mask</i></tt> dice a PF che ispezioni solo quei flag specifici 
mentre <tt><i>check</i></tt> specifica quale di quei flag devono 
essere "on" nell'header affinchè si abbia una corrispondenza.
L'utilizzo della keyword <tt>any</tt> permette di settare nell'header 
ogni combinazione di flag.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
</tt>
</blockquote>

<p>
La regola precedente consente il passaggio di traffico TCP con il flag 
SYN settato analizzando i flag SYN e ACK. Un pacchetto con flag SYN e 
ECE settati soddisferebbe la regola precedente mentre un pacchetto con 
SYN e ACK o solo ACK no.

<p>
In OpenBSD 4.1 e versioni successive, i flag di default applicati alle regole
TCP sono <tt>flags S/SA</tt>.
Insieme al <tt>keep state</tt> di default in OpenBSD 4.1 e versioni successive
queste due regole sono equivalenti:

<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state<br>
pass out on fxp0 proto tcp all
</tt>
</blockquote>

<p>
Ogni regola avrà corrispondenza con il flag SYN settato e il flag ACK non
settato ed ognuna creerà uno stato.
I flag di default possono essere sostituiti usando l'opzione <tt>flags</tt>
come visto precedentemente.

<p>
In OpenBSD 4.0 e versioni precedenti non vi erano flag di default applicati
a nessuna regola. Ogni regola doveva specificare quale flag controllare
e specificare l'opzione <tt>keep state</tt>.

<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>

<p>
Si dovrebbe fare attenzione all'uso dei flag, capire quello che si sta 
facendo e il perchè, fare attenzione ai consigli dati dalle persone 
perchè la maggior parte sono sbagliati. Alcune persone suggeriscono di 
creare uno stato solo nel caso in cui il solo flag SYN è settato. 
Una regola di questo tipo appare così: 
<pre>
     . . . flags S/FSRPAUEW  <i>bad idea!!</i>
</pre>

<p>
La teoria è di creare stati solo all'inizio di una sessione TCP e la 
sessione dovrebbe iniziare solo con il flag SYN. Il problema è che 
alcuni siti stanno iniziando a usare il flag ECN, e con il flag ECN 
settato ogni tentavivo di connettersi a un host con una regola di 
firewall come quella precedente sarebbe vano. Una regola migliore 
sarebbe di non specificare alcun flag e lasciare a PF l'utilizzo dei
flag di default. Se si dovesse decidere di utilizzare i flag, questa 
combinazione dovrebbe essere la più appropriata:
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
Pur essendo pratico e sicuro non è necessario controllare i flag SYN e 
RST se il traffico è anche sottoposto allo 
<a href="scrub.html">scrub</a>. Il processo di scrubbing porterà PF a 
rifiutare ogni pacchetto in arrivo con combinazioni illegali di flag 
TCP (come SYN e RST) e a normalizzare potenziali combinazioni ambigue
(come SYN and FIN).

<a name="synproxy"></a>
<h2>TCP SYN Proxy</h2>
<p>
Di solito quando un client inizia una connessione TCP a un server, PF 
farà passare i pacchetti dell'
<a href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml"
>handshake</a> così come sono tra i due host. PF è comunque in grado di 
effettuare il proxy dell'handshake. Con il proxy dell'handshake, PF 
completa l'handshake con il client, inizia un handshake con il server, 
e quindi passa i pacchetti tra i due. Il beneficio di questo processo è 
che nessun pacchetto è inviato al server prima che il client completi 
l'handshake. Questo elimina la minaccia al server di flood TCP SYN da 
client scorretti che non desiderano completare l'handshake.

<p>
Il TCP SYN proxy viene abilitato usando la keyword 
<tt>synproxy state</tt> nelle regole di filtraggio. Esempio:
<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
Qui la connessione al server web sarà soggetta al TCP proxy di PF.

<p>
Per il modo con cui il <tt>synproxy state</tt> funziona, include anche 
le funzionalità del <tt>keep state</tt> e <tt>modulate state</tt>. 


<p>
Il SYN proxy non funzionerà se PF è in esecuzione su un 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a>.

<a name="antispoof"></a>
<h2>Bloccare pacchetti contraffatti</h2>
La contraffazione dell'indirizzo si ha quando un utente con cattive 
intenzioni falsifica l'indirizzo IP dei pacchetti che invia per 
nascondere il suo vero indirizzo o per farsi passare per qualcun altro 
sulla rete. Una volta che l'utente ha contraffatto il suo indirizzo può 
eseguire un attacco a una rete senza rivelare l'indirizzo sorgente 
da dove parte l'attacco o tentare di guadagnare l'accesso ai servizi 
di rete che sono ristretti a un certo numero di indirizzi IP.

<p>
PF offre alcune protezioni contro la contraffazione dell'indirizzo IP 
attraverso la keyword <tt>antispoof</tt>: 
<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Specifica i tipi di pacchetti che dovrebbero essere sottoposti a 
log con 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.2"
>pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Se il pacchetto ha una corrispondenza con questa regola, questa 
sarà considerata la regola vincente e non verranno effettuate ulteriori 
valutazioni con le regole successive.

<dt><tt><i>interface</i></tt>
<dd>L'interfaccia di rete sulla quale attivare la protezione di 
spoofing. Questa può essere anche una
<a href="macros.html#lists">lista</a> di interfaccie. 

<dt><tt><i>af</i></tt>
<dd>La famiglia di indirizzi per i quali attivare la protezione di 
spoofing, sia <tt>inet</tt> per IPv4 oppure <tt>inet6</tt> per IPv6. 
</dl>

<p>
Esempio:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Quando vengono caricate le regole di configurazione, ogni 
corrispondenza con la keyword <tt>antispoof</tt> viene espansa in due 
regole di filtraggio. Assumendo che l'interfaccia <tt>fxp0</tt> abbia 
indirizzo IP 10.0.0.1 e una subnet mask di 255.255.255.0 (cioè /24), la 
regola <tt>antispoof</tt> si espenderebbe in: 

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Queste regole fanno due cose:
<ul>
<li>Bloccano tutto il traffico proveniente dalla subnet 10.0.0.0/24 
che <i>non</i> passa per la <tt>fxp0</t>. Dato che la rete 10.0.0.0/24 
è sull'interfaccia <tt>fxp0</tt>, i pacchetti con un indirizzo sorgente 
in quella network non dovrebbero mai essere visti su altre interfaccie.
<li>Bloccano tutto il traffico proveniente da 10.0.0.1, l'indirizzo 
IP sulla <tt>fxp0</tt>. L'host non dovrebbe mai mandare pacchetti a 
se stesso attraverso un'interfaccia esterna, così ogni pacchetto con 
un indirizzo sorgente appartenente alla macchina può essere considerato 
contraffatto.
</ul>

<p>
<b>NOTA</b>: Le regole di filtraggio che l'<tt>antispoof</tt> espande 
bloccheranno anche i pacchetti inviati sull'interfaccia di loopback 
agli indirizzi locali. E' buona regola non filtrare mai l'interfaccia 
di loopback e ciò diventa necessario nelle regole anti contraffazione:
<blockquote>
<tt>
set skip on lo0<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
L'uso di <tt>antispoof</tt> dovrebbe essere ristretto alle interfaccie 
alle quali è assegnato un indirizzo IP. Usare <TT>antispoof</TT> su 
un'interfaccia senza un indirizzo IP comporterà avere delle regole del 
tipo:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Con queste regole c'è il rischio di bloccare <i>tutto</i> il traffico 
in arrivo su <i>tutte</i> le interfaccie.

<a name="urpf"></a>
<h2>Unicast Reverse Path Forwarding</h2>

<p>
A partire da <a href="../../40.html">OpenBSD 4.0</a>, PF offre l'Unicast
Reverse PAth Forwarding (uRPF).
Quando un pacchetto viene controllato da uRPF, l'indirizzo sorgente viene
agganciato alla tabella di routing.
Se l'interfaccia esterna presente nella tabella di routing è la stessa
interfaccia utilizzata come indirizzo sorgente dal pacchetto, il controllo
uRPF ha esito positivo. Se non c'è corrispondenza tra gli indirizzi è 
possibile che l'indirizzo sorgente si contraffatto. 


<p>
Il controllo uRPF
sul pacchetto può essere ottenuto usando la keyword <tt>urpf-failed</tt> 
nelle regole di filtraggio:

<blockquote>
<tt>
block in quick from urpf-failed label uRPF
</tt>
</blockquote>

<p>
Da notare che il controllo uRPF ha senso in un sistema simmetrico
di routing.

<p>
uRPF fornisce le stesse funzionalità delle regole
<a href="#antispoof">antispoof</a>.


<a name="osfp"></a>
<h2>Riconoscimento passivo di sistema operativo</h2>

<p>
Il riconoscimento passivo del sistema operativo 
(Passive OS Fingerprinting - OSFP) è un metodo utilizzato per 
riconoscere il sistema operativo di un host remoto in base a 
determinate caratteristiche dei pacchetti TCP SYN dell'host. Queste 
informazioni possono essere usate come criterio di confronto nelle 
regole di filtraggio. 

<p>
PF determina il sistema operativo remoto comparando le caratteristiche 
TCP SYN del pacchetto con i dati del file 
<a href="options.html#fingerprints">fingerprints file</a>, che per default è 
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.2"
><tt>/etc/pf.os</tt></a>. 
Una volta che PF è abilitato, la lista corrente di fingerprint può 
essere vista con il seguente comando:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Con una regola di filtraggio, un fingerprint può essere specificato a 
livello di classe OS, versione o patch. Ognuno di questi dati è 
visibile nell'output del comando precedente <tt>pfctl</tt>. 
Per specificare un fingerprint in una regola si usa la keyword 
<tt>os</tt>: 

<blockquote>
<tt>
pass &nbsp;in on $ext_if from any os OpenBSD keep state<br>
block in on $ext_if from any os "Windows 2000"<br>
block in on $ext_if from any os "Linux 2.4 ts"<br>
block in on $ext_if from any os unknown
</tt>
</blockquote>

<p>
Tutti i pacchetti con fingerprint OS non noto appartengono alla classe 
speciale di sistema operativo <tt>unknown</tt>. 
<p>
<font color="#ff0000">PRENDERE NOTA</font> di ciò che segue: 
<ul>
  <li>I fingerprint di un sistema operativo possono essere a volte 
  sbagliati a causa di pacchetti contraffatti che si ottengono 
  analizzando come vengono creati dal sistema operativo.
  <li>Certe revisioni o patch di un sistema operativo possono cambiare 
  il comportamento dello stack e ostacolare il confronto con ciò che 
  c'è nel file fingerprints o addirittura riconoscere un OS sbagliato.
  <li>OSFP funziona solo per pacchetti TCP SYN, non funziona su altri 
  protocolli o su connessioni già attive.
</ul>

<a name="ipopts"></a>
<h2>Opzioni IP</h2>
Di default PF blocca pacchetti con opzioni IP settate. Questo può 
rendere difficoltoso il funzionamento di utility con 
"OS fingerprinting" come nmap. Se si dovesse avere un'applicazione che 
richiede il passaggio di questi pacchetti, come nel caso di pacchetti 
multicast o IGMP, si può utilizzare la direttiva <tt>allow-opts</tt>: 
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Esempio di regole di configurazione</h2>
Di seguito è riportato un esempio di regole di confogurazione di 
filtraggio. L'host che esegue PF si comporta da firewall tra una 
piccola LAN e Internet. Sono mostrate solo le regole di filtraggio;
<a href="queueing.html">queueing</a>, 
<a href="nat.html"><tt>nat</tt></a>, 
<a href="rdr.html"><tt>rdr</tt></a>, 
ecc., sono lasciate fuori dall'esempio.
<br>
<br>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# tabella contenente tutti gli indirizzi IP assegnati al firewall
table &lt;firewall&gt; const { self }

# non filtrare sull'interfaccia di loopback
set skip on lo0

# funzione di scrub per i pacchetti in arrivo
scrub in all

# setup a default deny policy
block all

# configura una policy deny di default
block in quick from urpf-failed

# consente le connessioni ssh dal computer affidabile 192.168.0.15 
# della network locale;
# usa "block return" così che un TCP RST è inviato a chiudere 
# connessioni bloccate; usa "quick" per evitare che questa regola sia 
# esclusa da eventuali regole "pass" successive 
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh

# consente il traffico nella network locale
# queste regole creano stati per la presenza dell'opzione "keep state"
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net

# passaggio di tcp, udp, e icmp verso Internet sull'interfaccia esterna 
# keep state per l'udp e icmp; modulate state su tcp.
pass out on $ext_if proto { tcp udp icmp } all modulate state

# consente le connessioni ssh sull'interfaccia esterna se i pacchetti 
# NON sono destinati al firewall (sono destinati ad host sulla rete 
# locale); log del pacchetto iniziale per un eventuale riconoscimento 
# di tentativi di connessioni; uso di tcp syn proxy per ottenere il 
# proxy della connessione. Il flag di default "S/SA" sarà applicato
# automaticamente.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
   port ssh synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Precedente: Tabelle</a>]
[<a href="index.html">Indice</a>]
[<a href="nat.html">Successivo: Network Address Translation</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: filter.html,v 1.47 ]<br>
$Translation: filter.html,v 1.2 2008/05/12 11:22:19 jscrat Exp $<br>
-->
$OpenBSD: filter.html,v 1.2 2008/05/27 10:00:23 tobias Exp $
</small> 
</body>
</html>

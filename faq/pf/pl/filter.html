<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Filtrowanie pakietów</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003-2007 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../pl/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>

<p>
[<a href="tables.html">Wstecz: Tabele</a>]
[<a href="index.html">Spis tre¶ci</a>]
[<a href="nat.html">Dalej: Translacje adresów (NAT)</a>]

<h1><font color="#e00000">PF: Filtrowanie pakietów</font></h1>

<hr>

<h3>Spis tre¶ci</h3>
<ul>
<li><a href="#intro">Wstêp</a>
<li><a href="#syntax">Sk³adnia regu³</a>
<li><a href="#defdeny">Domy¶lne blokowanie</a>
<li><a href="#pass">Przepuszczanie ruchu</a>
<li><a href="#quick">S³owo kluczowe <tt>quick</tt></a>
<li><a href="#state">¦ledzenie stanów</a>
<li><a href="#udpstate">¦ledzenie stanów dla UDP</a>
<li><a href="#stateopts">Opcje dla ¶ledzenia stanów</a>
<li><a href="#tcpflags">Flagi TCP</a>
<li><a href="#synproxy">TCP SYN Proxy</a>
<li><a href="#antispoof">Blokowanie sfa³szowanych pakietów</a>
<li><a href="#urpf">Unicast Reverse Path Forwarding</a>
<li><a href="#osfp">Pasywne rozpoznawanie systemów operacyjnych</a>
<li><a href="#ipopts">Opcje IP</a>
<li><a href="#example">Przyk³ad zestawu regu³ filtruj±cych</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Wstêp</h2>
Filtrowanie pakietów to selektywne przepuszczanie lub blokowanie pakietów
przechodz±cych przez interfejs sieciowy. Kryteria, którymi kieruje siê 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+4.6"
>pf(4)</a> podczas sprawdzania pakietów, s± oparte o Warstwê 3
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a> i 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4"
>IPv6</a>) oraz Warstwê 4 nag³ówków
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4"
>ICMP</a>, i
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4"
>ICMPv6</a>). Najczêstszym kryterium jest ¼ród³owy i docelowy adres,
¼ród³owy i docelowy port, oraz protokó³.

<p>
Regu³y filtruj±ce okre¶laj± kryteria wed³ug których podejmowana jest
konkretna akcja wobec pakietu: przepu¶æ (ang. pass) lub blokuj
(ang. block). Regu³y filtruj±ce s± porównywane sekwencyjnie, od
pierwszej do ostatniej. Z wyj±tkiem sytuacji, gdy pakiet pasuje
do regu³y ze s³owem kluczowym <tt>quick</tt>, pakiety s± porównywane
z <i>wszystkimi</i> regu³ami filtruj±cymi zanim ostateczna akcja
zostanie podjêta. Ostatnia pasuj±ca regu³a jest "zwyciêzc±" i decyduje
o podjêtej akcji. Je¶li na pocz±tku zestawu regu³ znajduje siê bezwarunkowe
<tt>pass all</tt>, wówczas wszystkie pakiety, które nie pasowa³y do
¿adnej z regu³, bêd± przepuszczane zgodnie z akcj± <tt>pass</tt>.

<a name="syntax"></a>
<h2>Sk³adnia regu³</h2>
Ogólna, <i>bardzo uproszczona</i> sk³adnia regu³ filtruj±cych
wygl±da nastêpuj±co:	
<blockquote>
<tt>
<i>action</i> [<i>direction</i>] [log] [quick] [on <i>interface</i>]
[<i>af</i>] [proto <i>protocol</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>src_addr</i> [port <i>src_port</i>]] [to
<i>dst_addr</i> [port <i>dst_port</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>action</i></tt>
<dd>Akcja, która ma byæ podejmowana wobec pasuj±cych pakietów, albo
<tt>pass</tt> albo <tt>block</tt>. Akcja <tt>pass</tt> przepuszcza
pakiety z powrotem do j±dra systemu do dalszego przetwarzania,
podczas gdy akcja <tt>block</tt> podejmuje dzia³anie zgodne z
ustawieniem opcji domy¶lnej polityki blokowania 
<a href="options.html#block-policy"><tt>block-policy</tt></a>. 
Domy¶lna akcja mo¿e byæ jawnie zmieniona poprzez podanie s³ów
kluczowych <tt>block drop</tt> lub <tt>block return</tt>.

<dt><tt><i>direction</i></tt>
<dd>Kierunek, w którym dany pakiet zmierza na interfejsie sieciowym, albo
<tt>in</tt> (po³. wchodzi) albo <tt>out</tt> (po³. wychodzi).

<dt><tt>log</tt>
<dd>Okre¶la, ¿e dany pakiet powinien byæ zapisany w logach przez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.6"
>pflogd(8)</a>. Je¿eli regu³a tworzy stan wówczas
jedynie pakiet który rozpoczyna po³±czenie stanowe
jest odnotowywany w logach.
Aby bezwzglêdnie zapisywaæ w logach wszystkie pakiety,
nale¿y zastosowaæ opcjê <tt>log (all)</tt>.

<dt><tt>quick</tt>
<dd>Je¶li pakiet pasuje do regu³y ze s³owem kluczowym <tt>quick</tt>,
wówczas regu³a ta jest uznawana za ostatni± pasuj±c± i podejmowana jest
odpowiednia akcja <tt><i>action</i></tt>.

<dt><tt><i>interface</i></tt>
<dd>Nazwa interfejsu sieciowego, lub grupa takich urz±dzeñ, przez który
przechodzi pakiet.
Interfejsy mog± byæ dodane do bezwzglêdnych grup przy pomocy polecenia
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>.
Kilka grup jest automatycznie tworzona przez kernel:
<ul>
<li>Grupa <tt>egress</tt>, zawieraj±ca interfejs(-y) obs³uguj±ce
bramê(-my) domy¶lne.
<li>Grypa rodzima interfejsu dla interfejsów "klonowanych".
Przyk³adowo: <tt>ppp</tt> lub <tt>carp</tt>.
</ul>

Powoduje, ¿e regu³a bêdzie pasowaæ do dowolnego pakietu przechodz±cego
przez odpowiednio, interfejs <tt>ppp</tt> lub <tt>carp</tt>.

<dt><tt><i>af</i></tt>
<dd>Rodzina adresów: <tt>inet</tt> dla IPv4 lub <tt>inet6</tt>
dla IPv6. PF jest zwykle w stanie zidentyfikowaæ ten parametr na podstawie
adresu(ów) ¼ród³owych/przeznaczenia.

<dt><tt><i>protocol</i></tt>
<dd>Protokó³ Warstwy 4 pakietu:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Poprawna nazwa protoko³u z 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5"
><tt>/etc/protocols</tt></a>
<li>Numer protoko³u z przedzia³u od 0 do 255
<li>Zbiór protoko³ów zapisany w postaci <a href="macros.html#lists">listy</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 
<dd>Adres ¼ród³owy/docelowy w nag³ówku IP. Adres mo¿e byæ podany jako:
<ul>
<li>Pojedynczy adres IPv4 lub IPv6.
<li>Blok sieci <a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>.
<li>W pe³ni okre¶lona domena (FQDN), która bêdzie rozwijana przez DNS w czasie
³adowania zestawu regu³. Wszystkie zwrócone adresy IP bêd± wstawione do regu³y.
<li>Nazwa interfejsu sieciowego lub grupa.
Wszystkie adresy IP przypisane do urz±dzenia bêd± wprowadzone podczas 
³adowania zestawu regu³.
<li>Nazwa interfejsu sieciowego wraz z <tt><i>/netmask±</i></tt>
(np <tt>/24</tt>). Ka¿dy adres IP danego interfejsu jest ³±czony
z ka¿d± mask± sieciow± aby utworzyæ odpowiedni blok sieci CIDR,
który bêdzie wprowadzony podczas ³adowania zestawu regu³.
<li>Nazwa interfejsu sieciowego lub grupy w nawiasach <tt>( )</tt>. 
Mówi to PF, aby od¶wie¿aæ regu³ê, je¶li adres(-y) IP tego interfejsu 
ulegnie zmianie.
Jest to bardzo przydatne gdy zewnêtrzne urz±dzenie otrzymuje swój
adres IP przez DHCP lub dial-up, poniewa¿ zestaw regu³
nie musi byæ prze³adowywany za ka¿dym razem, gdy zmienia siê IP.
<li>Nazwa interfejsu sieciowego z dopisanym na koñcu jednym z poni¿szych
wyra¿eñ:
  <ul>
  <li><tt>:network</tt> - odpowiada blokowi sieci CIDR (np
  192.168.0.0/24)
  <li><tt>:broadcast</tt> - odpowiada adresowi rozg³oszeniowemu podsieci
  (np 192.168.0.255)
  <li><tt>:peer</tt> - odpowiada adresowi IP wêz³a na drugim koñcu po³±czenia
  point-to-point
  </ul>

  <dl>
  <dd>Dodatkowo, wyra¿enie <tt>:0</tt> mo¿e zostaæ dodane na koñcu
  zarówno nazwy interfejsu jak i któregokolwiek z wymienionych s³ów
  kluczowych aby nie by³y brane pod uwagê dodatkowe, wskazuj±ce adresy IP
  (ang. aliased IP addresses) podczas przetwarzania regu³.
  Oznaczenia te mog± tak¿e byæ u¿yte wewn±trz wyra¿eñ w nawiasach.
  Przyk³ad: <tt>fxp0:network:0</tt>
  </dl>
<li><a href="tables.html">Tabela</a>.
<li>S³owo kluczowe <tt>urpf-failed</tt> mo¿e byæ u¿ywane dla adresu
¼ród³owego aby wskazaæ, ¿e powinien przej¶æ <a href="#urpf">kontrolê uRPF</a>.
<li>Którykolwiek z powy¿szych, lecz zanegowany przy pomocy modyfikatora
<tt>!</tt> ("not").
<li>Zestaw adresów w postaci <a href="macros.html#lists">listy</a>.
<li>S³owo kluczowe <tt>any</tt> oznaczaj±ce wszystkie adresy.
<li>S³owo kluczowe <tt>all</tt> stanowi±ce skrót <tt>from any to
any</tt>.
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>Port ¼ród³owy/docelowy w Warstwie 4 nag³ówka pakietu. Porty mog±
byæ podawane jako:
<ul>
<li>Liczba z zakresu od 1 do 65535
<li>Poprawna nazwa us³ugi, zdefiniowana w
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5"
><tt>/etc/services</tt></a>
<li>Zestaw portów w postaci <a href="macros.html#lists">listy</a>
<li>Przedzia³:
	<ul>
	<li><tt>!=</tt> (ró¿ny)
	<li><tt>&lt;</tt> (mniejszy ni¿)
	<li><tt>&gt;</tt> (wiêkszy ni¿)
	<li><tt>&lt;=</tt> (mniejszy lub równy)
	<li><tt>&gt;=</tt> (wiêkszy lub równy)
	<li><tt>&gt;&lt;</tt> (przedzia³)
	<li><tt>&lt;&gt;</tt> (poza przedzia³em)
	<dl>

	<dd>Ostatnie dwa s± operatorami binarnymi (wymagaj± dwóch argumentów) oraz
	nie mog± mieæ parametrów w postaci przedzia³ów.
	</dl>
	<li><tt>:</tt> (obejmuj±cy zasiêg)
	<dl>
	<dd>Operator obejmuj±cy zasiêg jest operatorem binarnym, nie obejmuje
	on jednak koñców przedzia³ów stanowi±cych jego argumenty.
	</dl>
	</ul>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd>Okre¶la flagi, które musz± byæ ustawione w nag³ówku TCP gdy u¿ywamy
<tt>proto tcp</tt>. S± one podawane w postaci: 
<tt>flags <i>check</i>/<i>mask</i></tt>. Na przyk³ad: <tt>flags
S/SA</tt> - PF bierze pod uwagê jedynie flagi S i A (SYN i ACK),
a regu³a jest dopasowana je¶li tylko flaga SYN jest ustawiona.
W OpenBSD 4.1 i pó¼niejszych, flagi <tt>S/SA</tt> s± domy¶lnie do³±czane
do wszystkich regu³ TCP.

<dt><tt><i>state</i></tt>
<dd>Okre¶la, czy informacje o stanie po³±czenia s± przechowywane, gdy
pakiety s± dopasowywane do tej regu³y.
<ul>
<li><tt>keep state</tt> - dzia³a z TCP, UDP oraz ICMP.
W OpenBSD 4.1 i pó¼niejszych, opcja ta jest domy¶lna dla wszystkich regu³.
<li><tt>modulate state</tt> - dzia³a jedynie z TCP. PF wygeneruje
trudny do przewidzenia Inicjuj±cy Numer Sekwencyjny (ang. Initial Sequence
Number - ISN) dla pakietów pasuj±cych do tej regu³y.
<li><tt>synproxy state</tt> - po¶redniczy w odbieraniu nadchodz±cych
po³±czeñ TCP aby pomóc zabezpieczyæ serwery przed atakami "TCP SYN flood". 
Opcja ta zawiera tak¿e funkcjonalno¶ci <tt>keep state</tt> i
<tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Domy¶lne blokowanie</h2>
Zaleca siê przyjmowaæ domy¶ln± politykê blokowania <i>wszystkiego</i> ("default deny"), 
a jedynie selektywne przepuszczanie konkretnego ruchu. Takie podej¶cie
zalecane jest nie tylko ze wzglêdów bezpieczeñstwa, ale sprawia, ¿e
pisanie zestawu regu³ jest znacznie prostsze.

<p>
Aby wprowadziæ domy¶ln± politykê blokowania pierwsze dwie regu³y
powinny wygl±daæ tak:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Spowoduje to blokowanie ca³ego ruchu na wszystkich interfejsach w
obu kierunkach.

<a name="pass"></a>
<h2>Przepuszczanie ruchu</h2>
Ruch musi byæ precyzyjnie przepuszczany przez firewall albo bêdzie
zatrzymany przez domy¶ln± politykê blokowania. W tym miejscu do akcji
wchodz± kryteria takie jak port ¼ród³owy/docelowy, adres ¼ród³owy/docelowy
oraz protokó³. Je¶li jaki¶ ruch ma byæ przepuszczany przez firewall,
to regu³y powinny byæ napisane tak restrykcyjnie jak to tylko
mo¿liwe. Ma to zapewniæ przepuszczanie po¿±danego i tylko po¿±danego ruchu.

<p>
Kilka przyk³adów:
<blockquote>
<tt>
# Przepu¶æ ruch na dc0 z sieci lokalnej, 192.168.0.0/24,<br>
# zmierzaj±cy do 192.168.0.1. Przepu¶æ tak¿e ca³y powracaj±cy<br>
# do tej sieci ruch na dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Przepu¶æ ruch TCP z zewn±trz na fxp0 zmierzaj±cy do serwera www.<br>
# Nazwa interfejsu, fxp0, jest u¿yta jako adres docelowy, wiêc<br>
# pakiety bêd± pasowaæ do tej regu³y jedynie je¶li s± przeznaczone<br>
# dla tej maszyny OpenBSD.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>S³owo kluczowe <tt>quick</tt></h2>
Jak ju¿ zosta³o to wcze¶niej napisane, ka¿dy pakiet jest porównywany
z ca³ym zestawem regu³ od góry do do³u. Domy¶lnie, pakiet
po porównaniu jest przekazywany do kolejnej regu³y, i dlatego
mo¿e byæ wielokrotnie zmieniany jego status, zanim osi±gnie
koniec zestawu regu³. <b>"Ostatnia pasuj±ca regu³a wygrywa".</b>
Jest od tego wyj±tek: opcja <tt>quick</tt> w regule filtruj±cej
skutkuje przerwaniem dalszego porównania i powoduje
podjêcie akcji z obecnej regu³y. Oto kilka przyk³adów:

<p>
¬le:
<blockquote>
<tt>
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
W tym przypadku, linia <tt>block</tt> mo¿e byæ porównywana, ale nigdy
nie bêdzie mia³a ¿adnego efektu, poniewa¿ po niej znajduje siê linia,
która wszystko przepuszcza.

<p>
Lepiej:
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Te regu³y s± porównywane nieco inaczej. Je¶li linia <tt>block</tt>
pasuje, dziêki opcji <tt>quick</tt>, pakiet bêdzie zablokowany,
a reszta regu³ tego zestawu bêdzie zignorowana.

<a name="state"></a>
<h2>¦ledzenie stanów</h2>
Jedn± z wa¿nych mo¿liwo¶ci Packet Filter jest ¶ledzenie stanów
(ang. keeping state) lub kontrolowanie stanów (ang. stateful
inspection). Kontrolowanie stanów odnosi siê do zdolno¶ci PF do
¶ledzenia stanu, lub przebiegu, po³±czenia sieciowego. Poprzez
przechowywanie informacji o ka¿dym po³±czeniu w tabeli stanów,
PF jest w stanie szybko okre¶liæ, czy pakiet przechodz±cy przez
firewall nale¿y do ju¿ nawi±zanego po³±czenia. Je¶li tak jest,
pakiet jest przepuszczany bez przechodzenia zestawu regu³.

<p>
¦ledzenie stanów ma wiele zalet, w³±czaj±c uproszczenie zestawu
regu³ i lepsz± wydajno¶æ filtrowania pakietów. PF jest w stanie
dopasowywaæ pakiety poruszaj±ce siê w <i>obu</i> kierunkach danego
po³±czenia, co oznacza, ¿e regu³y przepuszczaj±ce powracaj±cy ruch
nie s± potrzebne. A poniewa¿ pakiety pasuj±ce do po³±czenia stanowego
nie przechodz± zestawu regu³, czas zu¿ywany na przetwarzanie tych
pakietów mo¿e byæ bardzo znacz±co zmniejszony.

<p>
Gdy regu³a tworzy stan, pierwszy pakiet
pasuj±cy do niej tworzy "po³±czenie stanowe" pomiêdzy nadawc± i
odbiorc±. Wówczas, nie tylko pakiety pochodz±ce od nadawcy,
zmierzaj±ce do odbiorcy, ale i pakiety odbiorcy, skierowane do
nadawcy pasuj± do regu³y i nie s± sprawdzane przez zestaw regu³
filtruj±cych.

<p>
Pocz±wszy od OpenBSD 4.1, wszystkie regu³y automatycznie tworz±
stany w tabeli stanów gdy pakiet pasuje do danej regu³y.
We wcze¶niejszych wersjach OpenBSD regu³a filtra musia³a zawieraæ
opcjê <tt>keep state</tt>. 

<p>
Przyk³adowo, korzystaj±c z OpenBSD 4.1 i pó¼niejszych:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any
</tt>
</blockquote>

<p>
Dla OpenBSD 4.0 i wcze¶niejszych natomiast:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
Regu³y te zezwalaj± na wychodzenie ruchu TCP na interfejsie <tt>fxp0</tt>
i przepuszczaj± ruch powrotny pakietów stanowi±cych odpowied¼.
¦ledzenie stanów poza swoj± funkcjonalno¶ci±, zapewnia tak¿e
znacz±cy wzrost wydajno¶ci firewalla, poniewa¿ wyszukania
stanów s± du¿o szybsze ni¿ porównywanie pakietu z zestawem regu³
filtruj±cych.

<p>
Opcja <tt>modulate state</tt> dzia³a podobnie do <tt>keep state</tt>
z t± ró¿nic±, ¿e odnosi siê jedynie do pakietów TCP. Przy u¿yciu 
<tt>modulate state</tt>, Inicjuj±cy Numer Sekwencyjny (ISN)
wychodz±cego po³±czenia jest losowy. Jest to przydatne do ochrony
po³±czeñ nawi±zanych przez ró¿ne systemy operacyjne, które nie najlepiej
radz± sobie z generowaniem numeru ISN.
Pocz±wszy od OpenBSD 3.5, opcja <tt>modulate state</tt> mo¿e byæ
u¿ywana w regu³ach, które odnosz± siê tak¿e do innych ni¿ TCP protoko³ów.

<p>
¦led¼ stan wychodz±cych pakietów TCP, UDP i ICMP oraz generuj ISN dla TCP:
<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Inn± zalet± ¶ledzenia stanów jest to, i¿ odpowiedni ruch ICMP bêdzie
przepuszczany przez firewall.
Na przyk³ad, je¶li po³±czenie TCP przechodzi przez firewall, jest ono
¶ledzone stanowo i w momencie gdy nadejdzie komunikat ICMP
"gasz±cy ¼ród³o" (ang. source-quench) odwo³uj±cy siê do tego po³±czenia,
bêdzie on dopasowany do odpowiedniego wpisu stanowego i przepuszczony
przez firewall.

<p>
Zakres (ang. scope) wpisów w tabeli stanów jest globalnie kontrolowany
poprzez opcje czasu wykonywania
<a href="options.html#state-policy"><tt>state-policy</tt></a>,
niemniej mo¿na go okre¶liæ dla poszczególnych regu³ indywidualnie
poprzez s³owa kluczowe regu³ ¶ledzenia stanów: <tt>if-bound</tt>,
<tt>group-bound</tt> i <tt>floating</tt>.
S³owa kluczowe u¿yte dla pojedynczej regu³y maj± to samo znaczenie co
w przypadku globalnej polityki stanów <tt>state-policy</tt>.
Przyk³ad:

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Regu³a ta narzuca wymóg, aby pakiety które pasuj± do tej regu³y
by³y przekazywane przez interfejs <tt>fxp0</tt>.

<p>
Proszê zwróciæ uwagê, ¿e regu³y <a href="nat.html"><tt>nat</tt></a>, 
<a href="nat.html#binat"><tt>binat</tt></a>, i
<a href="rdr.html"><tt>rdr</tt></a> bezwarunkowo tworz± stan dla
pasuj±cych po³±czeñ tak d³ugo, jak dane po³±czenie jest
przekierowywane przez dan± regu³ê. 

<a name="udpstate"></a>
<h2>¦ledzenie stanów dla UDP</h2>
Ka¿dy od czasu do czasu s³yszy opinie, ¿e "nie mo¿na utworzyæ stanu
z UDP, poniewa¿ UDP jest bezstanowym protoko³em!". Mimo i¿ jest
prawd±, ¿e sesje komunikacyjne UDP nie maj± ¿adnej formy stanu
(formalnego rozpoczêcia i zakoñczenia komunikacji), nie ma to
¿adnego wp³ywu na zdolno¶æ PF do tworzenia stanowych sesji UDP.
W tym przypadku protoko³ów bez pakietów "inicjuj±cych" i "koñcz±cych"
po³±czenie, PF po prostu ¶ledzi ile czasu up³ynê³o odk±d pasuj±cy
pakiet zosta³ przepuszczony. Je¶li czas przekroczy ustalon± warto¶æ,
wpis stanu jest usuwany. Czas "przeterminowania" mo¿e byæ dostrojony
w sekcji <a href="options.html">opcje</a> pliku <tt>pf.conf</tt>.

<a name="stateopts"></a>
<h2>Opcje dla ¶ledzenia stanów</h2>
Regu³y tworz±ce wpisy w tabeli stanów mog± posiadaæ ró¿ne opcje
kontroluj±ce zachowanie stanu.

<dl>
<dt><tt>max <i>number</i></tt>
<dd>Ogranicza liczbê stanów jakie dana regu³a mo¿e utworzyæ do maksymalnej
warto¶ci ustalonej przez <i>number</i>.
Je¿eli to maksimum zosta³o osi±gniête, pakiety które normalnie tworzy³y 
by stan, nie bêd± pasowa³y do tej regu³y a¿ do czasu gdy liczba istniej±cych
stanów spadnie poni¿ej tego limitu.

<dt><tt>no state</tt>
<dd>zapobiega przed utworzeniem wpisu stanu.

<dt><tt>source-track</tt>
<dd>Opcja ta w³±cza ¶ledzenie liczby utworzonych stanów dla ka¿dego
¼ród³owego adresu IP.
Opcja ta posiada dwa formaty:
    <ul>
    <li><tt>source-track rule</tt> - Maksymalna liczba stanów utworzonych
    przez t± regu³ê jest ograniczona przez opcje <tt>max-src-nodes</tt> 
    oraz <tt>max-src-states</tt>. Tylko wpisy stanów utworzone przez t±
    regu³ê obliczaj± zbli¿anie siê do limitu.
    <li><tt>source-track global</tt> - Liczba stanów utworzonych przez 
    wszystkie regu³y które u¿ywaj± tej opcji jest ograniczona. Ka¿da regu³a
    mo¿e posiadaæ ró¿n± warto¶æ opcji <tt>max-src-nodes</tt> i 
    <tt>max-src-states</tt>, jednak¿e wpisy stanów utworzone przez ka¿d±
    uczestnicz±c± regu³ê odlicza w kierunku indywidualnych limitów dla
    ka¿dej regu³y.
    </ul>
Ca³kowita liczba ¼ród³owych adresów IP ¶ledzonych globalnie, mo¿e byæ 
kontrolowana poprzez
<a href="options.html#limit">opcjê startow± <tt>src-nodes</tt></a>.

<dt><tt>max-src-nodes <i>number</i></tt>
<dd>Kiedy korzystamy z opcji <tt>source-track</tt>, parametr <tt>max-src-nodes</tt>
bêdzie ogranicza³ liczbê ¼ród³owych adresów IP, które mog± jednocze¶nie 
generowaæ stan.
Opcja ta mo¿e byæ u¿yta tylko w po³±czeniu z <tt>source-track rule</tt>.

<dt><tt>max-src-states <i>number</i></tt>
<dd>Kiedy wykorzystywana jest opcja <tt>source-track</tt>, <tt>max-src-states</tt>
bêdzie ogranicza³o liczbê jednoczesnych wpisów w tabeli stanów które mog± byæ
utworzone przez pojedyñczy ¼ród³owy adres IP.
Zakres tego limitu (tj. stany utworzone tylko przez t± regu³ê lub stany 
utworzone przez wszystkie regu³y które korzystaj± z <tt>source-track</tt>)
jest zale¿ny od u¿ycia opcji <tt>source-track</tt>.
</dl>

<p>
Opcje podawane s± w nawiasach, zaraz po u¿yciu jednego ze s³ów kluczowych
(<tt>keep state</tt>, <tt>modulate state</tt>, or <tt>synproxy state</tt>).
Opcje oddzielone s± przecinkami.
W OpenBSD 4.1 i pó¼niejszych, opcja <tt>keep state</tt>, jest wstawiana
domy¶lnie do wszystkich regu³ filtra.
Pomimo tego, u¿ywaj±c opcji dla filtrowania stanowego, konieczne jest
u¿ycie jednego ze s³ów kluczowych przed okre¶lonymi opcjami.

<p>
Przyk³ad:
<blockquote>
<tt> 
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max 200, source-track rule, max-src-nodes 100,
max-src-states 3)
</tt>
</blockquote>

<p>
Powy¿szy przyk³ad powoduje:

<ul>
<li>Ograniczenie absolutnej maksymalnej liczby stanów jakie ta regu³a
mo¿e utworzyæ do 200
<li>W³±cza ¶ledzenie ¼ród³a; ogranicza tworzenie stanów opartych tylko
na stanach utworzonych przez t± regu³ê
<li>Ogranicza maksymaln± liczbê wêz³ów które mog± jednocze¶nie tworzyæ
stan do 100
<li>Ogranicza maksymaln± liczbê jednoczesnych stanów dla ¼ród³owego IP do 3
</ul>

<p>
Dodatkowe ograniczenia mog± byæ ustawione dla ¶ledzenia po³±czeñ TCP 
dla których zakoñczy³a siê negocjacja protoko³u.

<dl>
<dt><tt>max-src-conn <i>number</i></tt>
<dd>Ogranicza maksymalna liczbê jednoczesnych po³±czeñ TCP, które 
zakoñczy³y negocjacjê po³±czenia, dla pojedyñczego hosta.
<dt><tt>max-src-conn-rate <i>number</i> / <i>interval</i></tt>
<dd>Ogranicza tempo powstawania nowych po³±czeñ do konkretnej warto¶ci
w jednostce czasu (interval).
</dl>

<p>
Ka¿da z tych opcji automatycznie przywo³uje opcjê <tt>source-track rule</tt>,
oraz jest niekompatybilna z <tt>source-track global</tt>.

<p>
Poniewa¿ opcje te dotycz± tylko po³±czeñ TCP które zakoñczy³y negocjacjê,
bardziej agresywne zachowania mog± byæ u¿yte dla przestêpczego adresu IP.

<dl>
<dt><tt>overload &lt;<i>tablica</i>&gt;</tt>
<dd>Umie¶ci adres IP przestêpczego hosta w tablicy.
<dt><tt>flush [global]</tt>
<dd>Zabije wszystkie stany pasuj±ce do tej regu³y i utworzone przez ten
adres IP.
Kiedy podane jest <tt>global</tt>, zostan± zabite wszystkie stany pasuj±ce
do tego ¼ród³owego adresu IP, niezale¿nie od tego jaka regu³a utworzy³a stan.
</dl> 

<p>
Przyk³ad:

<blockquote>
<tt>
table &lt;abusive_hosts&gt; persist<br>
block in quick from &lt;abusive_hosts&gt;<br>
<br>
pass in on $ext_if proto tcp to $web_server \<br>
&nbsp;&nbsp;&nbsp;&nbsp;port www flags S/SA keep state \<br>
&nbsp;&nbsp;&nbsp;&nbsp;(max-src-conn 100, max-src-conn-rate 15/5,
overload &lt;abusive_hosts&gt; flush)
</tt>
</blockquote>

<p>
Powy¿sze regu³y wykonuj±:

<ul>
<li>Ograniczenie maksymalnej liczby po³±czeñ dla pojedynczego ¼ród³a do 100.
<li>Ograniczenie tempa po³±czeñ do 15 w ci±gu ka¿dych 5 sekund.
<li>Umieszczenie ka¿dego adresu IP który prze³amuje powy¿szy limit do
tablicy <tt>&lt;abusive_hosts&gt;</tt>.
<li>Dla ka¿dego grzesznego adresu IP, czy¶ci wszystkie stany utworzone
przez t± regu³ê.
</ul>

<a name="tcpflags"></a>
<h2>Flagi TCP</h2>
Dopasowanie pakietów TCP na podstawie flag jest najczê¶ciej
wykorzystywane przy filtrowaniu pakietów, które otwieraj±
nowe po³±czenie. Flagi TCP i ich nazwy s± podane poni¿ej:

<ul>
<li><b>F</b> : FIN  - Finish; zakoñczenie sesji
<li><b>S</b> : SYN  - Synchronize; sygnalizuje pro¶bê o rozpoczêcie sesji
<li><b>R</b> : RST  - Reset; porzuæ po³±czenie
<li><b>P</b> : PUSH - Push; pakiet jest wysy³any bezzw³ocznie
<li><b>A</b> : ACK  - Acknowledgement; potwierdzenie 
<li><b>U</b> : URG  - Urgent; ponaglenie
<li><b>E</b> : ECE  - Explicit Congestion Notification Echo
<li><b>W</b> : CWR  - Congestion Window Reduced
</ul>

<p>
Aby PF sprawdza³ flagi TCP podczas przetwarzania regu³ filtruj±cych
wykorzystywane jest s³owo kluczowe <tt>flags</tt>. Jego sk³adnia jest
nastêpuj±ca:
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i><br>
flags any
</tt>
</blockquote>

<p>
Czê¶æ <tt><i>mask</i></tt> mówi PF aby sprawdzaæ jedynie podane flagi, a
czê¶æ <tt><i>check</i></tt> okre¶la która flaga(i) powinny byæ "ustawione"
w nag³ówku, aby dopasowanie mia³o miejsce.
U¿ycie klucza <tt>any</tt> zezwala na ustawienie dowolnej kombinacji flag
w nag³ówku. 

<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
</tt>
</blockquote>

<p>
Powy¿sza regu³a przepuszcza ruch TCP z ustawion± jedynie flag± SYN,
bior±c pod uwagê tylko flagi SYN i ACK. Pakiet z flagami SYN i ECE
bêdzie pasowa³ do powy¿szej regu³y, jednak pakiet z SYN i ACK lub
tylko ACK ju¿ nie.

<p>
W OpenBSD 4.1 i pó¼niejszych, domy¶lne flagi stosowane od regu³ TCP
to <tt>flags S/SA</tt>.
W po³±czeniu z domy¶lnym dla OpenBSD 4.1 zachowaniem <tt>keep state</tt>
w regu³ach filtra, poni¿sze dwie linie s± równowa¿ne:

<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state<br>
pass out on fxp0 proto tcp all
</tt>
</blockquote>

<p>
Ka¿da regu³a do której pasuje pakiet TCP z ustawiona flag± SYN
i wygaszona flag± ACK utworzy odpowiedni stan.
Domy¶lne zachowanie mo¿e byæ zmienione poprzez u¿ycie opcji <tt>flags</tt>,
jak to zosta³o pokazane wcze¶niej.

<p>
W OpenBSD 4.0 i wcze¶niejszych flagi domy¶lne nie by³y stosowane w
regu³ach filtra.
Ka¿da regu³a musia³a mieæ okre¶lone pasuj±ce flagi oraz bezpo¶rednio
u¿yt± opcjê <tt>keep state</tt>.

<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>

<p>
Przy korzystaniu z flag trzeba byæ bardzo ostro¿nym - nale¿y rozumieæ
co siê robi i dlaczego, no i nale¿y uwa¿aæ na rady innych,
poniewa¿ czêsto s± one b³êdne. Niektórzy np. sugeruj± tworzenie stanu
"jedynie gdy flaga SYN jest ustawiona, i ¿adna inna". Taka regu³
wygl±da³a by tak:
<pre>
     . . . flags S/FSRPAUEW  <i>to z³y pomys³!!</i>
</pre>

<p>
W teorii, tworzy siê po³±czenie stanowe na pocz±tku sesji TCP, a sesja
powinna rozpocz±æ siê od flagi SYN, i ¿adnej innej. Problem polega
na tym, ¿e niektórzy u¿ytkownicy rozpoczynaj± po³±czenia wraz z flag±
ECN, i bêd± odrzuceni przez tak± regu³ê. Du¿o lepsz± praktyk± jest
nie okre¶lanie ¿adnych flag i pozwolenie PF-owi by zastosowa³
domy¶lne flagi do twoich regu³.
Je¶li naprawde chcesz sam okre¶liæ swoje flagi poni¿sza kombinacja
powinna byæ bezpieczna:

<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
Jest to praktyczne i bezpieczne. Je¶li ruch podlega normalizacji
<!--XXX-->
"scrub", wówczas mo¿na nie sprawdzaæ tak¿e
flag FIN i RST. Normalizacja powoduje, ¿e PF porzuca nadchodz±ce
pakiety z nieprawid³ow± kombinacja flag (tak± jak SYN i FIN lub
SYN i RST) a tak¿e normalizuje potencjalnie niejasne kombinacje
(takie jak SYN i FIN).


<a name="synproxy"></a>
<h2>TCP SYN Proxy</h2>
<p>
Domy¶lnie gdy klient nawi±zuje po³±czenie TCP z serwerem PF przepuszcza
pakiety zwi±zane z 
<a href="http://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml">
"potrójnym uzgodnieniem" (ang. handshake)</a> pomiêdzy dwoma uczestnicz±cymi
koñcami gdy tylko nadejd±. 
PF ma jednak zdolno¶æ do po¶redniczenia (ang. to proxy) w "potrójnym
uzgodnieniu". 
Dziêki temu, to PF dokona poprawnego "potrójnego uzgodnienia" z klientem,
nastêpnie zainicjuje "potrójne uzgodnienie" z serwerem i dopiero wtedy
zacznie przekazywaæ pakiety pomiêdzy oboma wêz³ami. 
Najwa¿niejsz± korzy¶ci± tego procesu jest to, i¿ ¿aden pakiet nie
zostanie wys³any do serwera zanim klient nie dokona poprawnego
"potrójnego uzgodnienia".
Eliminuje to zagro¿enie ataków typu "TCP SYN flood" na serwer
danej us³ugi.

<p>
"TCP SYN proxy" jest uruchamiane przy pomocy s³ów kluczowych
<tt>synproxy state</tt> w regu³ach filtruj±cych.
Na przyk³ad:

<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
Tu, po³±czenia do serwera WWW bêd± nawi±zywanie za po¶rednictwem
"TCP SYN proxy" przez PF.

<p>
Ze wzglêdu na swoje dzia³anie, <tt>synproxy state</tt> zawiera
funkcjonalno¶ci <tt>keep state</tt> i <tt>modulate state</tt>.

<p>
"SYN proxy" nie bêdzie dzia³aæ je¶li PF jest uruchomiony na mo¶cie (ang. 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge(4)</a>).

<a name="antispoof"></a>
<h2>Blokowanie sfa³szowanych pakietów</h2>
Fa³szowaniem (ang. spoof) okre¶la siê zmianê adresu ¼ród³owego pakietu maj±ce
na celu albo ukrycie prawdziwego pochodzenia datagramu, albo podszycie siê
pod inny segment sieci. Gdy u¿ytkownik pomy¶lnie podszyje siê pod inny adres,
mo¿e rozpocz±æ sieciowy atak bez ujawniania jego prawdziwego ¼ród³a lub
spróbowaæ uzyskaæ kontrolê nad us³ugami, które s± dostêpne dla w±skiej grupy
konkretnych adresów IP. 

<p>
PF oferuje pewn± ochronê przed podszywaniem siê pod inne adresy
poprzez s³owo kluczowe <tt>antispoof</tt>:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Okre¶la, ¿e pasuj±ce pakiety powinny byæ logowane przez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+4.6"
>pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Je¶li pakiet pasuje do tej regu³y, wówczas jest jest ona uznawana za
regu³ê "zwyciêsk±" i nie nastêpuje dalsze porównywanie regu³ z zestawu.

<dt><tt><i>interface</i></tt>
<dd>Nazwa interfejsu sieciowego na którym ma byæ aktywowana ochrona przed
spoofing-iem. Mo¿e to byæ tak¿e <a href="macros.html#lists">lista</a>
interfejsów sieciowych.

<dt><tt><i>af</i></tt>
<dd>Rodzina adresów dla której ma byæ aktywowana ochrona przed
spoofing-iem. <tt>inet</tt> dla IPv4 lub <tt>inet6</tt> dla IPv6.
</dl>

<p>
Przyk³ad:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Gdy zestaw regu³ jest ³adowany, ka¿de wyst±pienie <tt>antispoof</tt>
jest rozszerzane do dwóch regu³ filtruj±cych. Zak³adaj±c, ¿e interfejs
<tt>fxp0</tt> ma adres IP 10.0.0.1 i maskê podsieci 255.255.255.0 (np, /24),
powy¿sza regu³a <tt>antispoof</tt> by³aby przekszta³cona w:
<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Regu³y te realizuj± dwa zadania:
<ul>
<li>Blokuj± ca³y ruch przychodz±cy z sieci 10.0.0.0/24, który
<i>nie</i> przechodzi przez <tt>fxp0</tt>. Poniewa¿ sieæ 10.0.0.0/24 jest na
interfejsie <tt>fxp0</tt>, pakiety z adresem ¼ród³owym z tego bloku
sieci nie powinny nigdy nadchodziæ z ¿adnego innego interfejsu
sieciowego.
<li>Blokuj± ca³y ruch przychodz±cy z 10.0.0.1, adresu IP interfejsu
<tt>fxp0</tt>. Host nigdy nie powinien wysy³aæ pakietów do samego
siebie przez zewnêtrzny interfejs, dlatego nadchodz±ce pakiety
z adresem ¼ród³owym nale¿±cym do tej maszyny mog± byæ uznane za
podejrzane.
</ul>

<p>
<b>UWAGA</b>: Regu³y filtruj±ce, w które <tt>antispoof</tt> siê
przekszta³ca bêd± blokowaæ tak¿e pakiety wysy³ane przez interfejs
zwrotny (ang. loopback) na lokalny adres. 
W ka¿dym razie najlepiej opuszczaæ filtrowanie pakietów na interfejsie 
zwrotnym, a staje siê to konieczne w przypadku korzystania z regu³
antispoof:
<blockquote>
<tt>
set skip on lo0<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Korzystanie z <tt>antispoof</tt> powinno byæ ograniczone do interfejsów,
które maj± przypisany adres IP. U¿ycie <tt>antispoof</tt> na interfejsie
bez adresu IP spowoduje powstanie nastêpuj±cych regu³ filtruj±cych:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Przy takich regu³ach istnieje ryzyko blokowania <i>ca³ego</i> nadchodz±cego
ruchu na <i>wszystkich</i> interfejsach.

<a name="urpf"></a>
<h2>Unicast Reverse Path Forwarding</h2>

<p>
Od wersji <a href="../../../40.html">OpenBSD 4.0</a>, PF zawiera
obs³ugê Unicast Reverse Path Forwarding (uRPF).
W sytuacji gdy pakiet przechodzi przez sprawdzanie uRPF, ¼ród³owy adres
IP pakietu jest sprawdzany w tablicy routingu.
Gdy znaleziony w tablicy routingu wpis dotycz±cy interfejsu wyj¶ciowego jest
taki sam jak interfejsu z którego pakiet w³a¶nie nadszed³, wówczas sprawdzenie
uRPF powoduje jego przepuszczenie.
Gdy interfejsy nie pasuj±, istnieje mo¿liwo¶æ ¿e pakiet posiada podmieniony
adres ¼ród³owy. 

<p>
Sprawdzenie uRPF moze byæ wykonywane poprzez u¿ycie flagi
<tt>urpf-failed</tt> w zestawie regu³ filtra:

<blockquote>
<tt>
block in quick from urpf-failed label uRPF
</tt>
</blockquote>

<p>
Zwróæ uwagê, ¿e sprawdzanie uRPF ma sens tylko w ¶rodowiskach
gdzie routing jest symetryczny.

<p>
uRPF dostarcza tak± sam± funkcjonalno¶æ jak regu³y
<a href="#antispoof">antispoof</a>.

<a name="osfp"></a>
<h2>Pasywne rozpoznawanie systemów operacyjnych</h2>

<p>
Pasywne rozpoznawanie systemów operacyjnych (ang. Passive OS Fingerprinting,
OSFP) to sposób pasywnego rozpoznawania systemu operacyjnego zdalnego
wêz³a na podstawie pewnych charakterystycznych cech jego pakietów TCP SYN.
Informacje te mog± byæ wykorzystywane jako kryteria w regu³ach filtruj±cych.

<p>
PF rozpoznaje system operacyjny zdalnego wêz³a dziêki porównywaniu
jego charakterystyk pakietów TCP SYN z 
<a href="options.html#fingerprints"> plikiem zawieraj±cym "odciski palców"</a>
(ang. fingerprints file) ró¿nych systemów operacyjnych, którym domy¶lnie
jest <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+4.6"
><tt>/etc/pf.os</tt></a>. 
Je¶li PF jest w³±czony, aktualna lista "odcisków" mo¿e byæ wy¶wietlona
poni¿sz± komend±:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
W regule filtruj±cej, rozpoznawanie "odcisków" mo¿e byæ okre¶lane
poprzez rodzinê systemów operacyjnych, wersje lub ga³±¼/poziom
poprawek.
Ka¿da z tych sk³adowych jest wylistowana na wyj¶ciu dopiero co
wy¿ej wspomnianej komendy <tt>pfctl</tt>. Aby okre¶liæ "odcisk"
systemu w regule filtruj±cej, u¿ywamy s³owa kluczowego
<tt>os</tt>:

<blockquote>
<tt>
pass &nbsp;in on $ext_if from any os OpenBSD keep state<br>
block in on $ext_if from any os "Windows 2000"<br>
block in on $ext_if from any os "Linux 2.4 ts"<br>
block in on $ext_if from any os unknown
</tt>
</blockquote>

<p>
Specjalna klasa systemów <tt>unknown</tt> pozwala dopasowaæ
pakiety, dla których "odciski" nie zosta³y rozpoznane.

<p>
<font color="#ff0000">WARTO PAMIÊTAÆ</font> nastêpuj±ce fakty:
<ul>
  <li>"Odciski" systemów operacyjnych s± niekiedy b³êdne z powodu
  podszywania siê i/lub preparowania pakietów, w taki sposób, aby wygl±da³y
  na pochodz±ce z konkretnego systemu operacyjnego.
  <li>Pewne wydania lub poprawki systemowe mog± zmieniæ charakterystyki
  "odcisków" i spowodowaæ nierozpoznanie systemu lub wrêcz jego b³êdne
  rozpoznanie.
  <li>OSFP dzia³a jedynie na podstawie pakietów TCP SYN, dlatego nie bêdzie
  dzia³aæ poprawnie na innych protoko³ach czy te¿ ju¿ nawi±zanych po³±czeniach.
</ul>

<a name="ipopts"></a>
<h2>Opcje IP</h2>
Domy¶lnie PF blokuje wszystkie pakiety IP z ustawionymi opcjami.
Mo¿e to utrudniæ rozpoznanie systemu operacyjnego przez takie
narzêdzia jak nmap. Je¶li zachodzi konieczno¶æ uruchomienia aplikacji, która
wymaga przepuszczania tych pakietów, jak np. wysy³anych do grupy odbiorców
(ang. multicast) lub IGMP, mo¿na skorzystaæ z dyrektywy <tt>allow-opts</tt>:
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Przyk³ad zestawu regu³ filtruj±cych</h2>
Poni¿ej znajduje siê przyk³ad zestawu regu³ filtruj±cych.
Maszyna z PF pe³ni rolê firewalla oddzielaj±cego ma³± sieæ
wewnêtrzn± od Internetu. Poni¿ej przedstawiona jest tylko
konfiguracja odpowiadaj±ca za filtrowanie, regu³ki
<a href="queueing.html">kolejkowanie</a>,
<a href="nat.html"><tt>nat</tt></a>,
<a href="rdr.html"><tt>rdr</tt></a>
itp zosta³y pominiête.
<br>
<br>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# table containing all IP addresses assigned to the firewall
table &lt;firewall&gt; const { self }

# nie filtruj na interfejsie zwrotnym (loopback)
set skip on lo0

# normalizacja przychodz±cych pakietów
match in all scrub (no-df)

# ustawienie polityki domy¶lnego blokowania
block all

# aktywuj ochronê przed spoofing-iem na wszystkich interfejsach.
block in quick from urpf-failed

# zezwalaj na po³±czenia ssh z sieci lokalnej jedynie z zaufanego
# hosta - 192.168.0.15. korzystaj z "block return", aby TCP RST
# od razu by³o wysy³ane w odpowiedzi na blokowane po³±czenia
# korzystaj z "quick", aby regu³a nie by³a nadpisana przez
# znajduj±ce siê poni¿ej regu³y "pass"
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh

# przepuszczaj ca³y ruch z i do lokalnej sieci.
# regu³y te utworz± wpisy w tabeli stanów zgodnie z domy¶lnym
# do³±czeniem opcji "keep state"
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net

# wypuszczaj tcp, udp i icmp na interfejsie zewnêtrznym (Internet). 
# po³±czenia tcp bêd± modulowane, po³±czenia udp/icmp bêd±
# ¶ledzone poprzez stany
pass out on $ext_if proto { tcp udp icmp } all modulate state

# zezwalaj na po³±czenia ssh na interfejsie zewnêtrznym pod warunkiem,
# ¿e NIE s± one skierowane do firewall-a (np, nie s± skierowane
# do maszyny z sieci lokalnej). twórz logi dla pakietów inicjuj±cych
# po³±czenia, aby mo¿na by³o potem stwierdziæ, kto próbowa³ siê
# po³±czyæ. u¿ywamy "tcp syn proxy" dla nadchodz±cych po³±czeñ.
# flagi domy¶lne "S/SA" bêd± automatycznie do³±czane do regu³ 
# PF-a.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
   port ssh synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Wstecz: Tabele</a>]
[<a href="index.html">Spis tre¶ci</a>]
[<a href="nat.html">Dalej: Translacje adresów (NAT)</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[wstecz]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: filter.html,v 1.52 ]<br>
$Translation: filter.html,v 1.29 2009/11/08 19:35:52 tkniaz Exp $<br>
-->
$OpenBSD: filter.html,v 1.27 2009/11/08 22:09:17 tobias Exp $
</small>
</body>
</html> 

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Kolejkowanie i priorytetowanie</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>
<!--
Copyright (c) 2003-2005 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../pl/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="anchors.html">Wstecz: Zakotwiczenia</a>]
[<a href="index.html">Spis tre¶ci</a>]
[<a href="pools.html">Dalej: Pule adresów i kierowanie ruchem</a>]

<p>
<h1><font color="#e00000">PF: Kolejkowanie i priorytetowanie</font></h1>


<hr>

<h3>Spis tre¶ci</h3>
<ul>
<li><a href="#queueing">Kolejkowanie</a>
<li><a href="#sched">Algorytmy szeregowania</a>
	<ul>
	<li><a href="#cbq">Class Based Queueing</a>
	<li><a href="#priq">Kolejkowanie priorytetowe</a>
	<li><a href="#red">Mechanizm wczesnego wykrywania RED</a>
	<li><a href="#ecn">Jawne powiadomienie o przeci±¿eniu (ECN)</a>
	</ul>
<li><a href="#altq">Konfiguracja kolejkowania</a>
<li><a href="#assign">Przypisywanie ruchu do kolejki</a>
<li><a href="#example1">Przyk³ad 1: Ma³a sieæ domowa</a>
<li><a href="#example2">Przyk³ad 2: Sieæ w firmie</a>
</ul>

<hr>

<a name="queueing"></a>
<h2>Kolejkowanie</h2>
<p>
Terminem "kolejkowanie" okre¶la siê przechowywanie pewnej rzeczy w oczekiwaniu
na dalsz± jej obróbkê. W sieciach komputerowych, ka¿de dane, zanim zostan±
wys³ane umieszczane s± w kolejce, w której oczekuj± na przetworzenie. System
operacyjny decyduje za¶, które pakiety i z jakiej kolejki zostan± w danym
momencie wys³ane. Kolejno¶æ w jakiej system operacyjny wybiera pakiety do
przetworzenia mo¿e wp³ywaæ na wydajno¶æ sieci. Na przyk³ad, u¿ytkownik
uruchomi³ dwa programy wykorzystuj±ce sieæ: SSH oraz FTP. Teoretycznie
pakiety SSH powinny byæ obs³u¿one przed pakietami FTP poniewa¿ protokó³ SSH
jest uzale¿niony czasowo; w trakcie wpisywania czego¶ w kliencie SSH wymaga
siê natychmiastowej odpowiedzi, a opó¼nienie transferu danych z FTP na kilka
sekund nie powoduje w³a¶ciwie ¿adnych problemów. A co siê stanie, gdy router
kieruj±cy ruchem sieciowym przetwarza du¿e ilo¶ci pakietów FTP przed
obs³u¿eniem po³±czeñ SSH? Pakiety nale¿±ce do sesji SSH zostan± umieszczone
w kolejce (w przypadku nadmiernego wyd³u¿enia kolejki, najprawdopodobniej
bêd± porzucone), a po³±czenie SSH bêdzie mia³o tendencjê do du¿ych opó¼nieñ
(ang. lag) lub wrêcz bardzo spowolni± siê odpowiedzi strony zdalnej.
Modyfikuj±c jednak bie¿±c± strategiê kolejkowania dostêpne pasmo sieci bêdzie
sprawiedliwie podzielone pomiêdzy aplikacje, u¿ytkowników i komputery. 

<p>
Proszê zwróciæ uwagê, ¿e kolejkowanie jest tylko u¿yteczne w przypadku
pakietów <i>wychodz±cych</i>. W momencie, gdy pakiet osi±gnie kartê sieciow±,
w³a¶ciwie ju¿ jest za pó¼no na to, by go skolejkowaæ - bowiem w³a¶nie
wykorzysta³ czê¶æ pasma w celu dostania siê do karty sieciowej,
która go odebra³a. Jedynym rozwi±zaniem jest w³±czenie kolejkowania na
routerze b±d¼ maszynie, która pe³ni funkcjê routera i odebra³a pakiet.
Kolejkowanie nale¿y w³±czyæ na wewnêtrznym interface, tzn. tam gdzie pakiety
opuszczaj± router. 

<a name="sched"></a>
<h2>Algorytmy szeregowania</h2>
Algorytm szeregowania (ang. scheduler) jest tym, co decyduje któr± kolejkê
przetwarzaæ i w jakiej kolejno¶ci. Domy¶lnie OpenBSD u¿ywa algorytmu
szeregowania FIFO (pierwszy wszed³, pierwszy wyjdzie). Kolejki FIFO 
dzia³aj± podobnie jak kolejka w supermarkecie lub w banku - pakiet
znajduj±cy siê na czele kolejki bêdzie przetworzony jako pierwszy.
Kiedy nadchodz± nowe pakiety, dodawane s± na koniec kolejki. Je¶li kolejka
zape³ni siê, nowo przyby³e pakiety s± odrzucane. Taka metoda zwana jest
"odrzucaniem ogona".

<p>
W OpenBSD dostêpne s± dwa algorytmy szeregowania:
<ul>
<li>Kolejkowanie oparte o klasy (CBQ) - Class Based Queueing
<li>Kolejkowanie oparte o priorytety (PRIQ) - Priority Queueing
</ul>

<a name="cbq"></a>
<h3>Class Based Queueing</h3>
Class Based Queueing (CBQ) jest algorytmem, który dzieli pasmo 
po³±czenia sieciowego na wiele kolejek lub klas. Do ka¿dej 
kolejki przypisywane s± pakiety zale¿nie od adresu ¼ród³owego lub 
docelowego, numeru portu, protoko³u, itp. Kolejka mo¿e byæ skonfigurowana w
sposób umo¿liwiaj±cy po¿yczenie pasma od swojej kolejki nadrzêdnej, gdy
jej dostêpna przepustowo¶æ nie jest ca³kowicie wykorzystywana. Kolejki mog±
posiadaæ przypisany priorytet w taki sposób, ¿e te zawieraj±ce dane wymagaj±ce
du¿ej interaktywno¶ci, np. SSH, bêd± obs³ugiwane przed tymi, które zawieraj± 
dane nie wymagaj±ce interakcji np. FTP. 

<p>
Kolejki CBQ tworzone s± hierarchicznie. Na szczycie struktury znajduje siê 
kolejka-korzeñ (ang. root), która definiuje maksymaln± dostêpn± przepustowo¶æ 
³±cza. Kolejki podrzêdne tworzone s± pod kolejk± g³ówn±. Do ka¿dej
z podrzêdnych kolejek przypisana jest czê¶æ pasma kolejki g³ównej.
Na przyk³ad, kolejki mog± byæ zdefiniowane jak poni¿ej:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>Queue A (1Mbps)
	<dd>Queue B (500Kbps)
	<dd>Queue C (500Kbps)
	</dl>
</dl>
<p>
W tym przypadku, ca³e dostêpne pasmo ustawione jest na warto¶æ 2 megabity na
sekundê (Mbps). Pasmo to jest nastêpnie dzielone na trzy kolejki podrzêdne. 

<p>
Struktura mo¿e dalej byæ rozszerzana poprzez definiowanie nowych kolejek 
z kolejek pierwszego poziomu. Aby podzieliæ pasmo pomiêdzy ró¿nych u¿ytkowników
oraz sklasyfikowaæ ich ruch w taki sposób, aby niektóre protoko³y nie obci±¿a³y 
pasma innych, struktura kolejek mo¿e byæ zdefiniowana tak:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>UserA (1Mbps)
		<dl>
		<dd>ssh (50Kbps)
		<dd>bulk (950Kbps)
		</dl>
	<dd>UserB (1Mbps)
		<dl>
		<dd>audio (250Kbps)
		<dd>bulk (750Kbps)
			<dl>
			<dd>http (100Kbps)
			<dd>other (650Kbps)
			</dl>
		</dl>
	</dl>
</dl>

<p>
Nale¿y zauwa¿yæ, i¿ na ka¿dym poziomie suma przepustowo¶ci przypisanych 
do poszczególnych kolejek nie przekracza przepustowo¶ci kolejki bêd±cej 
dla nich kolejk± nadrzêdn±.  

<p>
Kolejka mo¿e byæ skonfigurowana w taki sposób, aby po¿yczaæ (ang.
borrow) pasmo od swojego rodzica, je¶li jest dostêpna u niego
nadwy¿ka, która powstaje gdy inne kolejki pochodne nie wykorzystuj±
pasma. Rozwa¿my nastêpuj±c± konfiguracje:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>UserA (1Mbps)
		<dl>
		<dd>ssh (100Kbps)
		<dd>ftp (900Kbps, borrow)
		</dl>
	<dd>UserB (1Mbps)
	</dl>
</dl>

<p>
Je¶li ruch w kolejce <tt>ftp</tt> przekracza 900Kbps, a ruch w kolejce 
<tt>UserA</tt> jest mniejszy ni¿ 1Mbps (poniewa¿ kolejka <tt>ssh</tt> wykorzystuje mniej
ni¿ 100Kbps pasma), wówczas kolejka <tt>ftp</tt> po¿yczy nadmiar pasma od
<tt>UserA</tt>. W ten sposób kolejka <tt>ftp</tt> jest w stanie korzystaæ z wiêkszego
pasma, ni¿ przydzielone jej, w sytuacji gdy jest prze³adowana.
Je¶li wzro¶nie zapotrzebowanie na pasmo w kolejce <tt>ssh</tt>, wówczas
udostêpniane pasmo zostanie oddane.

<p>
CBQ przypisuje ka¿dej kolejce poziom priorytetu. Kolejki o wiêkszym
priorytecie s± czê¶ciej wybierane podczas przeci±¿enia sieci ni¿ kolejki
o ni¿szym priorytecie, pod warunkiem, ¿e kolejki maj± tego samego
rodzica (innymi s³owy, tak d³ugo jak kolejki znajduj± siê w tej samej ga³êzi
hierarchii). Kolejki o tym samym priorytecie s± przetwarzane w sposób
rotacyjny (ang. round-robin). Na przyk³ad:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>UserA (1Mbps, priority 1)
		<dl>
		<dd>ssh (100Kbps, priority 5)
		<dd>ftp (900Kbps, priority 3)
		</dl>
	<dd>UserB (1Mbps, priority 1)
	</dl>
</dl>

<p>
CBQ bêdzie przetwarzaæ kolejki <tt>UserA</tt> i <tt>UserB</tt> w sposób rotacyjny -
¿adna z kolejek nie bêdzie mia³a pierwszeñstwa przed inn±. W czasie
gdy kolejka <tt>UserA</tt> bêdzie przetwarzana, CBQ bêdzie tak¿e obs³ugiwaæ
jej kolejki pochodne. W tym przypadku kolejka <tt>ssh</tt> ma wiêkszy
priorytet i bêdzie mia³a pierwszeñstwo przed kolejk± <tt>ftp</tt>, gdy
sieæ bêdzie przeci±¿ona. Zauwa¿, ¿e priorytety kolejek <tt>ssh</tt> i <tt>ftp</tt> 
nie s± porównywane w stosunku do kolejek <tt>UserA</tt> i <tt>UserB</tt>, poniewa¿
nie znajduj± siê one w tej samej ga³êzi hierarchii.

<p>
Osoby zainteresowane szczegó³owymi informacjami na temat teorii stoj±cej
za kolejkowaniem CBQ, mog± odwiedziæ stronê z
<a href="http://www.icir.org/floyd/cbq.html">materia³ami referencyjnymi
na temat CBQ</a>.

<a name="priq"></a>
<h3>Kolejkowanie priorytetowe</h3>
Kolejkowanie priorytetowe PRIQ (ang. priority queueing) pozwala nadaæ
priorytet kolejkom na interfejsie sieciowym.
Kolejka o wiêkszym priorytecie jest <i>zawsze</i> przetwarzana
przed kolejk± o mniejszym priorytecie.
Je¿eli dwie lub wiêcej kolejek maj± przydzielony ten sam priorytet, wówczas
kolejki te s± obs³ugiwane zgodnie mechanizmem round-robin.

<p>
Struktura kolejek PRIQ jest zawsze p³aska - nie mo¿na definiowaæ
kolejek w kolejkach. Kolejka-korzeñ jest definiowana aby okre¶liæ
ca³kowit± dostêpn± przepustowo¶æ, po czym definiowane s± podkolejki
korzenia. Rozwa¿my nastêpuj±cy przyk³ad:
<dl>
<dd>Root Queue (2Mbps)
	<dl>
	<dd>Queue A (priority 1)
	<dd>Queue B (priority 2)
	<dd>Queue C (priority 3)
	</dl>
</dl>

<p>
Zadeklarowano, ¿e kolejka-korzeñ ma dostêpn± przepustowo¶æ 2Mbps
oraz ¿e posiada trzy kolejki podrzêdne. Kolejka o najwy¿szym priorytecie
(posiadaj±ca najwiêkszy numer priorytetu) jest obs³ugiwana jako pierwsza.
Gdy wszystkie pakiety s± przetworzone, lub gdy kolejka jest
pusta, wówczas PRIQ przechodzi do przetwarzania nastêpnej kolejki
o kolejnym najwy¿szym priorytecie. W obrêbie kolejki pakiety
s± przetwarzane na zasadzie First In First Out (FIFO).

<p>
Istotne jest, aby bardzo uwa¿nie planowaæ swoje kolejki korzystaj±ce
z PRIQ poniewa¿ algorytm ten <i>zawsze</i> przetwarza kolejkê o
wy¿szym priorytecie przed kolejk± o ni¿szym priorytecie. Jest
mo¿liwe, ¿e kolejka o wysokim priorytecie spowoduje, ¿e pakiety
kolejki o ni¿szym priorytecie bêd± opó¼nione lub nawet porzucone
(ang. drop) w sytuacji, gdy kolejka o wy¿szym priorytecie otrzymuje
ci±g³y strumieñ pakietów.

<a name="red"></a>
<h3>Mechanizm wczesnego wykrywania RED</h3>
Mechanizm wczesnego wykrywania RED (ang. Random Early Detection)
jest algorytmem pozwalaj±cym unikn±æ przeci±¿enia ³±cza. Jest to
realizowane poprzez zagwarantowanie, ¿e dana kolejka nie zostanie
zape³niona. Algorytm osi±ga to poprzez nieustanne obliczanie ¶redniej
d³ugo¶ci (wielko¶ci) kolejki i porównywanie jej z dwoma progami:
minimalnym i maksymalnym. Je¶li ¶rednia wielko¶æ kolejki jest poni¿ej
minimalnego progu wówczas ¿aden przybywaj±cy pakiet nie bêdzie
porzucony. Je¶li ¶rednia wielko¶æ kolejki jest powy¿ej maksymalnego
progu, wtedy <i>wszystkie</i> nowo przyby³e pakiety s± porzucane.
Je¶li ¶rednia jest pomiêdzy warto¶ciami progów wówczas pakiety s±
porzucane bazuj±c na obliczeniach prawdopodobieñstwa dokonywanych
na podstawie ¶redniej wielko¶ci kolejki. Innymi s³owy, czym bardziej
wielko¶æ kolejki zbli¿a siê do warto¶ci maksymalnego progu,
tym wiêcej pakietów jest porzucanych.
Gdy pakiety s± porzucane, RED wybiera losowo po³±czenia, których
pakiety maj± byæ porzucane. Po³±czenia wykorzystuj±ce wiêksze pasmo
s± bardziej nara¿one na porzucanie ich pakietów.

<p>
RED jest u¿yteczny, poniewa¿ pozwala unikn±æ scenariusza zwanego
"globaln± synchronizacj±", a tak¿e jest w stanie obs³u¿yæ "wybuchy"
ruchu. Termin "globalna synchronizacja" odnosi siê do utraty
³±cznej przepustowo¶ci z powodu porzucania pakietów wielu po³±czeñ
w tym samym czasie. Na przyk³ad, je¶li przeci±¿enie pojawi siê na
routerze obs³uguj±cym ruch dla 10 po³±czeñ FTP i pakiety z wszystkich
(lub prawie) tych po³±czeñ s± porzucane (jak to ma miejsce w przypadku
kolejkowania FIFO) wówczas ogólne wykorzystanie ³±cza drastycznie
spadnie. Nie jest to idealna sytuacja, poniewa¿ powoduje to
zmniejszenie prêdko¶ci wszystkich po³±czeñ FTP i oznacza, ¿e
maksymalny potencja³ sieci nie jest wykorzystany optymalnie.
Algorytm RED pozwala tego unikn±æ poprzez losowy wybór po³±czeñ,
których pakiety maj± byæ porzucane, zamiast wybieraæ je wszystkie.
Po³±czenia wykorzystuj±ce du¿± przepustowo¶æ s± bardziej nara¿one
na prawdopodobieñstwo porzucenia ich pakietów. W ten sposób mocno
obci±¿aj±ce sieæ po³±czenia bêd± t³umione, przeci±¿enia unikane,
a utrata maksymalnego wykorzystania przepustowo¶ci nie bêdzie mieæ
miejsca. Dodatkowo, RED jest w stanie poradziæ sobie z "wybuchami"
ruchu, poniewa¿ zaczyna porzucaæ pakiety <i>zanim</i> dana kolejka
zostaje zape³niona. Gdy "wybuch" ruchu ma miejsce, jest wystarczaj±co
du¿o wolnego miejsca w kolejce, aby poradziæ sobie z nowymi pakietami.

<p>
RED powinien byæ stosowany jedynie, gdy protokó³ transportuj±cy jest
zdolny do odpowiadania na wska¼niki przepe³nienia z sieci.
W wiêkszo¶ci przypadków oznacza to, i¿ RED powinien byæ u¿ywany
przy kolejkowaniu ruchu TCP, a nie UDP czy ICMP.

<p>
Bardziej szczegó³owe informacje o teorii stoj±cej za kolejkowaniem RED,
s± dostêpne na stronie z
<a href="http://www.icir.org/floyd/red.html">materia³ami referencyjnymi
na temat RED</a>.

<a name="ecn"></a>
<h3>Jawne powiadomienie o przeci±¿eniu (ECN)</h3>
Jawne powiadomienie o przeci±¿eniu (ang. Explicit Congestion
Notification - ECN) dzia³a w po³±czeniu z RED, aby powiadomiæ
dwa hosty komunikuj±ce siê za po¶rednictwem sieci o jakimkolwiek
przeci±¿eniu na trasie po³±czenia. Jest to osi±gane poprzez
umo¿liwienie RED ustawiania flagi w nag³ówku pakietu zamiast jego
porzucania. Zak³adaj±c, ¿e wysy³aj±cy host obs³uguje ECN, mo¿e on
odczytaæ flagê i zd³awiæ odpowiednio ilo¶æ wysy³anych pakietów.

<p>
Wiêcej informacji o ECN mo¿na znale¼æ w 
<a href="http://www.rfc-editor.org/rfc/rfc3168.txt">RFC 3168</a>.

<a name="altq"></a>
<h2>Konfiguracja kolejkowania</h2>
Od wydania OpenBSD 3.0 implementacja kolejkowania 
<a href="http://www.csl.sony.co.jp/person/kjc/kjc/software.html#ALTQ"
>Alternate Queueing (ALTQ)</a> jest czê¶ci± podstawowego systemu.
Pocz±wszy od OpenBSD 3.3 ALTQ jest zintegrowane z PF. Implementacja
ALTQ na OpenBSD wspiera algorytmy szeregowania Class Based Queueing
(CBQ) i Priority Queueing (PRIQ). Poza tym obs³uguje Random
Early Detection (RED) i Explicit Congestion Notification (ECN).

<p>
Poniewa¿ ALTQ sta³o siê czê¶ci± PF, dlatego PF musi byæ aktywne,
aby kolejkowanie dzia³a³o. Instrukcja, jak w³±czyæ PF jest dostêpna
w sekcji <a href="config.html#activate">Aktywacja</a>.

<p>
Kolejkowanie jest konfigurowane w pliku <tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+4.6"
>pf.conf</a></tt>. Istniej± dwa typy dyrektyw, które s³u¿±
do konfigurowania kolejkowania:
<ul>
<li><tt>altq on</tt> - w³±cza kolejkowanie na interfejsie, definiuje
który algorytm szeregowanie ma byæ zastosowany i tworzy kolejkê-korzeñ
<li><tt>queue</tt> - definiuje w³asno¶ci kolejek pochodnych
</ul>

<p>
Sk³adnia dyrektywy <tt>altq on</tt> wygl±da nastêpuj±co:
<blockquote>
<tt>
altq on <i>interface scheduler</i> bandwidth <i>bw</i> qlimit 
<i>qlim</i> \<br>
&nbsp;&nbsp;&nbsp;tbrsize <i>size</i> queue { <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>interface</i></tt> - interfejs na którym ma byæ aktywowane
kolejkowanie.
<li><tt><i>scheduler</i></tt> - jaki algorytm szeregowania ma byæ
zastosowany. Mo¿liwymi warto¶ciami s± <tt>cbq</tt> lub <tt>priq</tt>.
Tylko jeden algorytm szeregowania mo¿e byæ aktywowany na pojedynczym
interfejsie w tym samym czasie.
<li><tt><i>bw</i></tt> - ca³kowita dostêpna przepustowo¶æ dla algorytmu
szeregowania. Mo¿e byæ ona podana w formie warto¶ci absolutnej z
wykorzystaniem przyrostków <tt>b</tt>, <tt>Kb</tt>, <tt>Mb</tt> i <tt>Gb</tt> 
oznaczaj±cych odpowiednio bity, kilobity, megabity i gigabity na sekundê, 
lub jako warto¶æ procentowa przepustowo¶ci interfejsu <tt><i>interface</i></tt>.
<li><tt><i>qlim</i></tt> - maksymalna liczba pakietów przechowywanych w
kolejce. Jest to parametr opcjonalny. Domy¶lnie ma warto¶æ 50.
<li><tt><i>size</i></tt> - wielko¶æ regulatora "wiadra z ¿etonami" (ang.
token bucket) w bajtach. Je¶li nie zdefiniowana, wielko¶æ jest ustalana
na podstawie przepustowo¶ci interfejsu <tt><i>interface</i></tt>.
<li><tt><i>queue_list</i></tt> - lista kolejek pochodnych tworzonych
poni¿ej kolejki-korzenia.
</ul>

<p>
Na przyk³ad:
<blockquote>
<tt>
altq on fxp0 cbq bandwidth 2Mb queue { std, ssh, ftp }
</tt>
</blockquote>
Linia ta uaktywnia CBQ na interfejsie <tt>fxp0</tt>. Ca³kowita dostêpna
przepustowo¶æ jest okre¶lona na 2Mbps. Zadeklarowane s± trzy
kolejki-dzieci: <tt>std</tt>, <tt>ssh</tt> i <tt>ftp</tt>.

<p>
Sk³adnia dyrektywy <tt>queue</tt> jest nastêpuj±ca:
<blockquote>
<tt>
queue <i>name</i> [on <i>interface</i>] bandwidth <i>bw</i> [priority 
<i>pri</i>] [qlimit <i>qlim</i>] \<br>
&nbsp;&nbsp;&nbsp;<i>scheduler</i> ( <i>sched_options</i> )
{ <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>name</i></tt> - nazwa kolejki. Musi pasowaæ do jednej z
zadeklarowanych wcze¶niej w <tt>altq on</tt> dyrektyw <tt><i>queue_list</i></tt>. 
W przypadku <tt>cbq</tt>, mo¿e ona tak¿e pasowaæ do nazwy kolejki
w poprzedzaj±cej <tt>queue</tt> dyrektywie <tt><i>queue_list</i></tt>.
Nazwy kolejek nie mog± byæ d³u¿sze ni¿ 15 znaków.
<li><tt><i>interface</i></tt> - interfejs sieciowy, do którego odnosi siê
kolejka. Parametr ten jest opcjonalny, bez niego kolejka odnosi siê do
wszystkich interfejsów.
<li><tt><i>bw</i></tt> - ca³kowita przepustowo¶æ dostêpna dla danej
kolejki. Mo¿e byæ podana w postaci warto¶æ absolutnych
przy pomocy przyrostków <tt>b</tt>, <tt>Kb</tt>, <tt>Mb</tt> i <tt>Gb</tt>, 
aby okre¶liæ odpowiednio ilo¶æ bitów, kilobitów, megabitów i gigabitów 
na sekundê, lub jako warto¶æ procentowa przepustowo¶ci kolejki-korzenia.
Parametr ten w³a¶ciwy jedynie dla algorytmu szeregowania <tt>cbq</tt>.
Je¿eli nie jest okre¶lony, domy¶lnie jest 100% przepustowo¶ci rodzica.
<li><tt><i>pri</i></tt> - priorytet kolejki. Dla <tt>cbq</tt> zakres
priorytetów wynosi od 0 do 7, a dla <tt>priq</tt> od 0 do 15.
Priorytet 0 jest najni¿szy. Domy¶lnym priorytetem jest 1.
<li><tt><i>qlim</i></tt> - maksymalna ilo¶æ pakietów w kolejce. Domy¶lnie 50. 
<li><tt><i>scheduler</i></tt> - wykorzystywany algorytm szeregowania,
<tt>cbq</tt> lub <tt>priq</tt>. Musi byæ taki sam jak w kolejce korzeniu.
<li><tt><i>sched_options</i></tt> - dalsze opcje mog± byæ przekazane do
algorytmu szeregowania, aby wp³ywaæ na jego zachowanie:
<ul>
<li><tt>default</tt> - okre¶la domy¶ln± kolejkê, do której przypisywane
bêd± wszystkie niepasuj±ce do innych kolejek pakiety. Wymagana
jest dok³adnie jedna domy¶lna kolejka.
<li><tt>red</tt> - uaktywnia Random Early Detection (RED) w danej
kolejce.
<li><tt>rio</tt> - uaktywnia RED z IN/OUT. W takim trybie pracy, RED
bêdzie utrzymywaæ wiele u¶rednionych d³ugo¶ci kolejek i wiele warto¶ci
progów, jeden dla ka¿dego poziomu IP Quality of Service.
<li><tt>ecn</tt> - uaktywnia Explicit Congestion Notification (ECN) w
danej kolejce. <tt>ecn</tt> implikuje <tt>red</tt>.
<li><tt>borrow</tt> - kolejka mo¿e po¿yczaæ przepustowo¶æ od
kolejki-rodzica. Mo¿e byæ stosowane jedynie w przypadku algorytmu
szeregowania <tt>cbq</tt>.
</ul>
<li><tt><i>queue_list</i></tt> - lista kolejek-dzieci, które maj± byæ utworzone
dla tej kolejki. <tt><i>queue_list</i></tt> mo¿e byæ stosowane jedynie w
przypadku algorytmu szeregowania <tt>cbq</tt>.
</ul>

<p>
Kontynuuj±c wcze¶niejszy przyk³ad:
<blockquote>
<tt>
queue std bandwidth 50% cbq(default)<br>
queue ssh bandwidth 25% { ssh_login, ssh_bulk }<br>
&nbsp;&nbsp;queue ssh_login bandwidth 25% priority 4 cbq(ecn)<br>
&nbsp;&nbsp;queue ssh_bulk  bandwidth 75% cbq(ecn)<br>
queue ftp bandwidth 500Kb priority 3 cbq(borrow red)<br>
</tt>
</blockquote>

<p>
Powy¿ej zdefiniowane s± wcze¶niej zadeklarowane kolejki-dzieci.
Kolejka <tt>std</tt> ma przydzielone 50% przepustowo¶ci kolejki korzenia
(czyli 1Mbps) i jest zaznaczona jako kolejka domy¶lna. Kolejce <tt>ssh</tt>
przypisano 25% przepustowo¶ci kolejki korzenia (500kb) oraz zawiera dwie
kolejki-dzieci <tt>ssh_login</tt> i <tt>ssh_bulk</tt>. <tt>Ssh_login</tt>
ma wiêkszy priorytet ni¿ <tt>ssh_bulk</tt>, a obie maj± uaktywnione ECN.
Kolejka <tt>ftp</tt> ma przypisan± przepustowo¶æ 500Kbps i nadany priorytet 3.
Mo¿e ona tak¿e po¿yczaæ pasmo, je¶li s± ku temu warunki,
oraz ma uaktywnione RED.

<p>
<b>Zauwa¿my:</b> Ka¿da definicja potomnej kolejki posiada okre¶lon± przepustowo¶æ.
Bez okre¶lania przepustowo¶ci, PF przydzieli kolejce 100% przepustowo¶ci 
kolejki rodzica.
W takiej sytuacji spowoduje to b³±d podczas ³adowania regu³, poniewa¿ je¿eli 
istnieje kolejka ze 100% przepustowo¶ci, ¿adna inna kolejka nie mo¿e
byæ zdefiniowana na tym poziomie, nie istnieje bowiem wolna przepustowo¶æ
do przydzielenia. 

<a name="assign"></a>
<h3>Przypisywanie ruchu do kolejki</h3>
<p>
Aby przypisaæ ruch do kolejki, s³owo kluczowe <tt>queue</tt> jest
wykorzystywane w po³±czeniu z <a href="filter.html">regu³ami
filtruj±cymi</a> PF. Na przyk³ad, rozwa¿my zestaw regu³ zawieraj±cy
tak± liniê:
<blockquote>
<tt>pass out on fxp0 from any to any port 22</tt>
</blockquote>

<p>
Pakiety pasuj±ce do tej regu³y mog± byæ przypisane do konkretnej
kolejki przy pomocy s³owa kluczowego <tt>queue</tt>:
<blockquote>
<tt>pass out on fxp0 from any to any port 22 queue ssh</tt>
</blockquote>

<p>
Gdy u¿ywane jest s³owo kluczowe <tt>queue</tt> wraz z dyrektywami
<tt>block</tt>, jakiekolwiek wygenerowane pakiety TCP RST lub ICMP
unreachable s± przypisywane do podanej kolejki.

<p>
Wa¿ne jest, ¿e przypisywanie do kolejki mo¿e mieæ miejsce na
innym interfejsie ni¿ zadeklarowano w dyrektywie <tt>altq on</tt>:
<blockquote>
<tt> 
altq on fxp0 cbq bandwidth 2Mb queue { std, ftp }<br>
queue std bandwidth 500Kb cbq(default)<br>
queue ftp bandwidth 1.5Mb<br>
<br>
pass in on dc0 from any to any port 21 queue ftp<br>
</tt>
</blockquote>

<p>
Kolejkowanie jest uaktywnione na <tt>fxp0</tt>, lecz przypisywanie pakietów
ma miejsce na <tt>dc0</tt>. Gdy pakiety pasuj±ce do regu³y <tt>pass</tt>
wychodz± z interfejsu <tt>fxp0</tt>, bêd± przypisane do kolejki
<tt>ftp</tt>. Ten typ kolejkowania mo¿e byæ bardzo u¿yteczny na ruterach.

<p>
Zwykle jest podawana tylko jedna nazwa kolejki po s³owie kluczowym
<tt>queue</tt>, ale je¶li druga nazwa jest obecna, wówczas kolejka
ta bêdzie wykorzystywana dla pakietów z 
<a href="http://www.rfc-editor.org/rfc/rfc791.txt">Type of Service
(ToS)</a> o ma³ym opó¼nieniu (ang. low-delay) i dla pakietów TCP ACK
nie zawieraj±cych danych (ang. data payload). Dobrym przyk³adem wykorzystania
tej funkcjonalno¶ci jest ruch SSH. Sesje logowania SSH bêd± mieæ ustawione
ToS na ma³e opó¼nienie, podczas gdy sesje SCP i SFTP nie. PF mo¿e
wykorzystaæ t± informacje do zakolejkowania pakietów nale¿±cych do
interaktywnej sesji do innej kolejki ni¿ nieinteraktywne po³±czenia.
Mo¿e to byæ u¿yteczne do nadawania priorytetu pakietom sesji interaktywnych
przed pakietami transferu plików.
<blockquote>
<tt>pass out on fxp0 from any to any port 22 queue(ssh_bulk, ssh_login)</tt>
</blockquote>

<p>
Regu³a ta umieszcza pakiety nale¿±ce do interaktywnych po³±czeñ SSH
w kolejce <tt>ssh_login</tt>, a pakiety nale¿±ce do po³±czeñ SCP i SFTP w
kolejce <tt>ssh_bulk</tt>. Pakiety nale¿±ce do po³±czeñ interaktywnych SSH bêd±
teraz przetwarzane przed pakietami po³±czeñ SCP i SFTP poniewa¿ kolejka
<tt>ssh_login</tt> ma wiêkszy priorytet.

<p>
Przydzielanie pakietów TCP ACK do kolejki o wy¿szym priorytecie jest
przydatne w przypadku asymetrycznych po³±czeñ, to znaczy po³±czeñ,
które maj± inn± przepustowo¶æ wysy³ania i pobierania jak np linie ADSL.
W przypadku linii ADSL, je¶li kana³ wysy³aj±cy jest ca³kowicie zape³niony,
a rozpoczynane jest pobieranie, wówczas pobieranie bêdzie utrudnione,
poniewa¿ niezbêdne pakiety TCP ACK, które powinny byæ wys³ane bêd±
próbowaæ przebiæ siê na przeci±¿onym kanale wysy³aj±cym.
Testy wykaza³y, i¿ aby uzyskaæ najlepsze rezultaty, przepustowo¶æ
kolejki pobierania powinna mieæ warto¶æ mniejsz±, ni¿ wynosi maksymalna
przepustowo¶æ. Dla przyk³adu, je¶li linia ADSL ma maksymaln± prêdko¶æ
wysy³ania równ± 640Kbps, ustawienie przepustowo¶ci <tt>bandwidth</tt>
kolejki korzenia na warto¶æ tak± jak 600Kb powinno zaowocowaæ lepsz±
wydajno¶ci±. Najlepsz± warto¶æ <tt>bandwidth</tt> mo¿na wyznaczyæ
metod± prób i b³êdów.

<p>
Gdy u¿ywane jest s³owo kluczowe <tt>queue</tt> wraz z regu³ami <tt>keep
state</tt> jak na przyk³ad:
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port 22 flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state queue ssh
</tt>
</blockquote>

<p>
PF odnotuje kolejkê we wpisie w tabeli stanów, wiêc pakiety
podró¿uj±ce z powrotem z <tt>fxp0</tt>, które pasuj± do po³±czenia
stanowego bêd± przydzielane do kolejki <tt>ssh</tt>.
Zwróæ uwagê, ¿e pomimo i¿ s³owo kluczowe <tt>queue</tt>
jest u¿yte z regu³± filtruj±c± przychodz±cy ruch, celem jest
okre¶lenie kolejki dla wynik³ego wychodz±cego ruchu,
a powy¿sza regu³a nie kolejkuje przychodz±cych pakietów.

<a name="example1"></a>
<h2>Przyk³ad 1: Ma³a sieæ domowa</h2>
<pre>
  
    [ Alice ]    [ Charlie ]
        |             |                              ADSL
     ---+-----+-------+------ dc0 [ OpenBSD ] fxp0 -------- ( Internet )
              |
           [ Bob ]

</pre>

<p>
W tym przyk³adzie, OpenBSD wykorzystywane jest jako bramka Internetowa
dla ma³ej sieci domowej z trzema stacjami roboczymi. Bramka realizuje
filtrowanie pakietów i NAT. Po³±czenie internetowe stanowi linia ADSL
pobieraj±ca dane z prêdko¶ci± 2Mbps i wysy³aj±ca z prêdko¶ci± 640Kbps.

<p>
Polityka kolejkowania dla tej sieci:
<ul>
<li>Zarezerwowaæ 80Kbps pasma pobierania danych dla Boba, aby móg³ graæ
w swoje gry online bez utrudnieñ spowodowanych pobieraniem danych przez
Alicje lub Charliego. Oczywi¶cie Bob bêdzie mia³ mo¿liwo¶æ korzysta z
wiêkszego pasma ni¿ 80Kbps, je¶li obci±¿enie linii na to pozwala.
<li>Interaktywne sesje SSH i komunikatory maj± wiêkszy priorytet ni¿
zwyk³y ruch.
<li>Zapytania i odpowiedzi DNS maj± drugi w kolejno¶ci priorytet.
<li>Wychodz±ce pakiety TCP ACK maj± wiêkszy priorytet ni¿ jakikolwiek
inny ruch na kanale zwrotnym.
</ul>

<p>
Poni¿ej znajduje siê zestaw regu³, który spe³nia te za³o¿enia.
Warto zwróciæ uwagê, ¿e dyrektywy <tt>pf.conf</tt>, które odnosz± siê
bezpo¶rednio do powy¿szych za³o¿eñ s± obecne, podczas gdy dyrektywy
<a href="nat.html"><tt>nat</tt></a>, <a href="rdr.html"><tt>rdr</tt></a>,
<a href="options.html">opcje</a>, itd nie s± pokazane.

<p>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# uaktywnienie kolejkowania na zewnêtrznym interfejsie, aby kontrolowaæ
# ruch id±cy do Internetu. wykorzystanie algorytmu szeregowania priq
# do kontrolowania jedynie priorytetów. ustawienie przepustowo¶æ
# kana³u zwrotnego na 610Kbps dla uzyskaæ lepsz± wydajno¶æ w kolejce TCP ACK.

altq on fxp0 priq bandwidth 610Kb queue { std_out, ssh_im_out, dns_out, \
	tcp_ack_out }

# definiowanie parametrów dla kolejek-dzieci.
# std_out      - standardowa kolejka. ka¿da regu³a filtruj±ca poni¿ej,
#                która nie jest wyra¼nie powi±zana z konkretn± kolejk±
#                bêdzie domy¶lnie przypisywa³a do tej kolejki.
# ssh_im_out   - interaktywne sesje SSH i ró¿ne komunikatory.
# dns_out      - zapytania DNS.
# tcp_ack_out  - pakiety TCP ACK nie zawieraj±ce danych.

queue std_out     priq(default)
queue ssh_im_out  priority 4 priq(red)
queue dns_out     priority 5
queue tcp_ack_out priority 6

# uaktywnienie kolejkowania na wewnêtrznym interfejsie, aby kontrolowaæ
# ruch nadchodz±cy z Internetu. wykorzystanie algorytmu szeregowania cbq
# do kontrolowania przepustowo¶ci. maksymalna przepustowo¶æ to 2Mbps.

altq on dc0 cbq bandwidth 2Mb queue { std_in, ssh_im_in, dns_in, bob_in }

# zdefiniuj parametry dla kolejek-dzieci.
# std_in      - standardowa kolejka. ka¿da regu³a filtruj±ca poni¿ej,
#               która nie jest wyra¼nie powi±zana z konkretn± kolejk±
#               bêdzie domy¶lnie przypisywa³a do tej kolejki.
# ssh_im_in   - interaktywne sesje SSH i ró¿ne komunikatory.
# dns_in      - odpowiedzi DNS.
# bob_in      - pasmo zarezerwowane dla stacji roboczej Boba. zezwalamy
#               mu na po¿yczanie wolnego pasma.

queue std_in    bandwidth 1.6Mb cbq(default)
queue ssh_im_in bandwidth 200Kb priority 4
queue dns_in    bandwidth 120Kb priority 5
queue bob_in    bandwidth 80Kb cbq(borrow)


# ... w sekcji regu³ filtruj±cych pf.conf ...

alice         = "192.168.0.2"
bob           = "192.168.0.3"
charlie       = "192.168.0.4"
local_net     = "192.168.0.0/24"
ssh_ports     = "{ 22 2022 }"
im_ports      = "{ 1863 5190 5222 }"

# regu³y filtruj±ce dla przychodz±cego ruchu na fxp0
block in on fxp0 all

# regu³y filtruj±ce dla wychodz±cego ruchu na fxp0
block out on fxp0 all
pass  out on fxp0 inet proto tcp from (fxp0) to any flags S/SA \
	keep state queue(std_out, tcp_ack_out)
pass  out on fxp0 inet proto { udp icmp } from (fxp0) to any keep state
pass  out on fxp0 inet proto { tcp udp } from (fxp0) to any port domain \
	keep state queue dns_out
pass  out on fxp0 inet proto tcp from (fxp0) to any port $ssh_ports \
	flags S/SA keep state queue(std_out, ssh_im_out)
pass  out on fxp0 inet proto tcp from (fxp0) to any port $im_ports \
	flags S/SA keep state queue(ssh_im_out, tcp_ack_out)

# regu³y filtruj±ce dla przychodz±cego ruchu na dc0
block in on dc0 all
pass  in on dc0 from $local_net

# regu³y filtruj±ce dla wychodz±cego ruchu na dc0
block out on dc0 all
pass  out on dc0 from any to $local_net
pass  out on dc0 proto { tcp udp } from any port domain to $local_net \
	queue dns_in
pass  out on dc0 proto tcp from any port $ssh_ports to $local_net \
	queue(std_in, ssh_im_in)
pass  out on dc0 proto tcp from any port $im_ports to $local_net \
	queue ssh_im_in
pass  out on dc0 from any to $bob queue bob_in
</pre>
</td></tr>
</table>

<a name="example2"></a>
<h2>Przyk³ad 2: Sieæ w firmie</h2>
<pre>

  ( IT Dept )  [ Boss's PC ]
       |          |                                   T1
     --+----+-----+---------- dc0 [ OpenBSD ] fxp0 -------- ( Internet )
            |                         fxp1
         [ COMP1 ]    [ WWW ]         /
                         |           / 
                       --+----------' 

</pre>

<p>
W tym przyk³adzie, maszyna OpenBSD odgrywa rolê firewalla dla sieci
firmy. Firma posiada serwer WWW w "czê¶ci zdemilitaryzowanej" DMZ
swojej sieci, gdzie klienci umieszczaj± swoje strony web poprzez
FTP. Dzia³ IT ma w³asn± podsieæ pod³±czon± do g³ównej sieci,
a szef posiada osobisty komputer na biurku, który wykorzystuje do
sprawdzania poczty elektronicznej i surfowania po sieci. Po³±czenie
z Internetem zapewnia linia T1 o przepustowo¶ci 1.5Mbps w obu
kierunkach. Wszystkie pozosta³e segmenty sieci wykorzystuj± 
Fast Ethernet (100Mbps).

<p>
Administrator sieci zdecydowa³ o nastêpuj±cej polityce kolejkowania:
<ul>
    <li>Ograniczyæ ca³y ruch pomiêdzy serwerem WWW, a Internetem do 500Kbps w
    obu kierunkach.
    <ul>
    <li>Przydzieliæ 250Kbps na ruch HTTP.
    <li>Przydzieliæ 250Kbps na "pozosta³y" ruch (tzn. ruch nie-HTTP) 
    <li>Zezwoliæ ka¿dej z kolejek na na po¿yczkê do pe³nych 500Kbps.
    <li>Nadaæ ruchowi HTTP pomiêdzy serwerem WWW a Internetem wy¿szy
    priorytet ni¿ pozosta³y ruch pomiêdzy serwerem WWW a Internetem
    (tak jak np. pobieranie FTP)
    </ul>
    <li>Ruch pomiêdzy serwerem WWW a sieci± wewnêtrzn± mo¿e korzystaæ w pe³ni
    z 100Mbps jakie oferuje sieæ.
    <li>Zarezerwowaæ 500Kbps dla sieci IT Dept, tak aby mogli pobieraæ
    najnowsze aktualizacje oprogramowania w odpowiednim momencie. Powinni
    tak¿e mieæ mo¿liwo¶æ wykorzystaæ wiêcej ni¿ 500Kbps je¿eli dodatkowe
    pasmo jest dostêpne.
    <li>Nadanie ruchowi sieciowemu pomiêdzy komputerem szefa (Boss's PC)
    a sieci± Internet wiêkszego priorytetu ni¿ innemu ruchowi
    z/do sieci Internet.
    </ul>
<p>
Poni¿ej znajduje siê zestaw regu³, który spe³nia te za³o¿enia.
Warto zwróciæ uwagê, ¿e dyrektywy <tt>pf.conf</tt>, które odnosz± siê
bezpo¶rednio do powy¿szych za³o¿eñ s± obecne, podczas gdy dyrektywy
<a href="nat.html"><tt>nat</tt></a>, <a href="rdr.html"><tt>rdr</tt></a>,
<a href="options.html">opcje</a>, itd nie s± pokazane.

<p>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# uaktywnienie kolejkowania na wewnêtrznym interfejsie, aby kontrolowaæ
# ruch nadchodz±cy z Internetu. wykorzystanie algorytmu szeregowania cbq
# tak, aby przepustowo¶æ ka¿dej kolejki mog³a byæ ³atwo regulowana.
# maksymalna przepustowo¶æ wychodz±cego ruchu to 1.5Mbps.

altq on fxp0 cbq bandwidth 1.5Mb queue { std_ext, www_ext, boss_ext }

# zdefiniowanie parametrów dla kolejek-dzieci.
# std_ext        - standardowa kolejka. tak¿e domy¶lna kolejka dla
#                  wychodz±cego ruchu na fxp0.
# www_ext        - kolejka zbiorcza dla kolejek serwera WWW. limit
#                  500Kbps.
#   www_ext_http - ruch http z serwera WWW; wy¿szy priorytet.
#   www_ext_misc - ca³y ruch nie-http z serwera WWW.
# boss_ext       - ruch z komputera szefa.

queue std_ext        bandwidth 500Kb cbq(default borrow)
queue www_ext        bandwidth 500Kb { www_ext_http, www_ext_misc }
  queue www_ext_http bandwidth 50% priority 3 cbq(red borrow)
  queue www_ext_misc bandwidth 50% priority 1 cbq(borrow)
queue boss_ext       bandwidth 500Kb priority 3 cbq(borrow) 

# uaktywnienie kolejkowania na wewnêtrznym interfejsie, tak aby kontrolowaæ
# ruch nadchodz±cy z Internetu lub DMZ. wykorzystanie algorytmu
# szeregowania cbq, do regulowania przepustowo¶æ dla ka¿dej kolejki.
# przepustowo¶æ na tym urz±dzeniu jest ustawiona na maksimum.
# ruch nadchodz±cy z DMZ jest w stanie korzystaæ z ca³ego dostêpnego
# pasma, podczas gdy ruch nadchodz±cy z Internetu bêdzie ograniczony
# do 1.0Mbps (poniewa¿ 0.5Mbps (500Kbps) jest zaalokowane dla fxp1).

altq on dc0 cbq bandwidth 100% queue { net_int, www_int }

# zdefiniowanie parametrów dla kolejek-dzieci.
# net_int    - zbiorcza kolejka dla ruchu z Internetu. przepustowo¶æ
#              wynosi 1.0Mbps.
#   std_int  - standardowa kolejka. tak¿e domy¶lna kolejka dla
#              wychodz±cego ruchu na dc0.
#   it_int   - ruch do sieci dzia³u IT, zarezerwowano dla nich 500Kbps.
#   boss_int - ruch do komputera szefa; przypisano wy¿szy priorytet.
# www_int    - ruch z serwera WWW w strefie DMZ; z pe³n± szybko¶ci±.

queue net_int    bandwidth 1.0Mb { std_int, it_int, boss_int }
  queue std_int  bandwidth 250Kb cbq(default borrow)
  queue it_int   bandwidth 500Kb cbq(borrow)
  queue boss_int bandwidth 250Kb priority 3 cbq(borrow)
queue www_int    bandwidth 99Mb cbq(red borrow)

# uaktywninie kolejkowania na interfejsie DMZ, aby kontrolowaæ ruch
# skierowany do serwera WWW. cbq jest zastosowane dla tego
# interfejsu poniewa¿ szczegó³owa kontrola pasma jest niezbêdna.
# przepustowo¶æ na tym urz±dzeniu jest ustawiona na maksimum.
# ruch z sieci wewnêtrznej bêdzie móg³ korzystaæ z ca³ej
# przepustowo¶ci, podczas gdy ruch z Internetu bêdzie ograniczony
# do 500Kbps.

altq on fxp1 cbq bandwidth 100% queue { internal_dmz, net_dmz }

# zdefiniowanie parametrów dla kolejek-dzieci.
# internal_dmz   - ruch z sieci wewnêtrznej.
# net_dmz        - zbiorcza kolejka dla ruchu z Internetu.
#   net_dmz_http - ruch http; wy¿szy priorytet.
#   net_dmz_misc - ca³y ruch nie-http. jest to tak¿e domy¶lna kolejka.

queue internal_dmz   bandwidth 99Mb cbq(borrow)
queue net_dmz        bandwidth 500Kb { net_dmz_http, net_dmz_misc }
  queue net_dmz_http bandwidth 50% priority 3 cbq(red borrow)
  queue net_dmz_misc bandwidth 50% priority 1 cbq(default borrow)


queue internal_dmz      # nie s± potrzebne ¿adne dodatkowe ustawienia
queue net_dmz        bandwidth 500Kb { net_dmz_http, net_dmz_misc }
  queue net_dmz_http priority 3 cbq(red)
  queue net_dmz_misc priority 1 cbq(default)


# ... w sekcji regu³ filtruj±cych pf.conf ...

main_net  = "192.168.0.0/24"
it_net    = "192.168.1.0/24"
int_nets  = "{ 192.168.0.0/24, 192.168.1.0/24 }"
dmz_net   = "10.0.0.0/24"

boss      = "192.168.0.200"
wwwserv   = "10.0.0.100"

# domy¶lne blokowanie
block on { fxp0, fxp1, dc0 } all

# regu³y filtruj±ce dla przychodz±cego ruchu na fxp0
pass in on fxp0 proto tcp from any to $wwwserv port { 21, \
	&gt; 49151 } flags S/SA keep state queue www_ext_misc
pass in on fxp0 proto tcp from any to $wwwserv port 80 \
	flags S/SA keep state queue www_ext_http

# regu³y filtruj±ce dla wychodz±cego ruchu na fxp0
pass out on fxp0 from $int_nets to any keep state
pass out on fxp0 from $boss to any keep state queue boss_ext

# regu³y filtruj±ce dla przychodz±cego ruchu na dc0
pass in on dc0 from $int_nets to any keep state
pass in on dc0 from $it_net to any queue it_int
pass in on dc0 from $boss to any queue boss_int
pass in on dc0 proto tcp from $int_nets to $wwwserv port { 21, 80, \
	&gt; 49151 } flags S/SA keep state queue www_int

# regu³y filtruj±ce dla wychodz±cego ruchu na dc0
pass out on dc0 from dc0 to $int_nets

# regu³y filtruj±ce dla przychodz±cego ruchu na fxp1
pass in on fxp1 proto { tcp, udp } from $wwwserv to any port 53 \
	keep state

# regu³y filtruj±ce dla wychodz±cego ruchu na fxp1
pass out on fxp1 proto tcp from any to $wwwserv port { 21, \
	&gt; 49151 } flags S/SA keep state queue net_dmz_misc
pass out on fxp1 proto tcp from any to $wwwserv port 80 \
	flags S/SA keep state queue net_dmz_http
pass out on fxp1 proto tcp from $int_nets to $wwwserv port { 80, \
	21, &gt; 49151 } flags S/SA keep state queue internal_dmz
</pre>
</td></tr>
</table>

<p>
[<a href="anchors.html">Wstecz: Zakotwiczenia</a>]
[<a href="index.html">Spis tre¶ci</a>]
[<a href="pools.html">Dalej: Pule adresów i kierowanie ruchem</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[wstecz]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: queueing.html,v 1.38 ]<br>
$Translation: queueing.html,v 1.21 2009/11/08 19:35:52 tkniaz Exp $<br>
-->
$OpenBSD: queueing.html,v 1.20 2009/11/08 22:09:17 tobias Exp $
</small>
</body>
</html>

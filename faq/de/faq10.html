<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>10 - Systemverwaltung</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2007 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq9.html">[Zum Kapitel 9 - Zu OpenBSD migrieren]</a>
<a href= "faq11.html">[Zum Kapitel 11 - Das X Window System]</a>
</font>

<h1><font color="#e00000">10 - Systemverwaltung</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#wheel"         >10.1 - Wenn ich mich per su zu root machen
  will, wird mir gesagt, dass ich in der falschen Gruppe sei.</a>
<li><a href="#DupFS"         >10.2 - Wie kann ich ein Dateisystem
  duplizieren?</a>
<li><a href="#rc"            >10.3 - Wie starte ich Daemons mit dem
  System? (Überblick über rc(8))</a>
<li><a href="#RelayingDenied">10.4 - Wieso erhalten Benutzer ein
  »relaying access denied« wenn sie versuchen, von woanders her Mails
  über mein OpenBSD-System zu verschicken?</a>
<li><a href="#POP"           >10.5 - Ich habe POP installiert, erhalte
  aber Fehler, wenn ich versuche, meine Mails per POP abzuholen. Was
  kann ich tun?</a>
<li><a href="#SendmailDNS"   >10.6 - Warum ignoriert Sendmail die
  /etc/hosts-Datei?</a>
<li><a href="#HTTPS"         >10.7 - Einen sicheren HTTP-Server mit
  Hilfe von SSL(8) aufsetzen</a>
<li><a href="#vipw"          >10.8 - Ich habe zwar mit vi(1) Änderungen
  an /etc/passwd gemacht, die Änderungen haben aber keinen Effekt.
  Warum?</a>
<li><a href="#AddDelUser"    >10.9 - Wie fügt man einen Benutzer hinzu?
  Oder wie löscht man einen?</a>
<li><a href="#FTPOnly"       >10.10 - Wie erzeugt man ein Benutzerkonto,
  das nur für FTP genutzt werden kann?</a>
<li><a href="#Quotas"        >10.11 - Wie man Benutzer-Diskquotas
  einrichtet</a>
<li><a href="#Kerberos"      >10.12 - Wie man KerberosV-Client/Server
  einrichtet</a>
<li><a href="#AnonFTP"       >10.13 - Wie man einen Anonymous-FTP-Server
  einrichtet</a>
<li><a href="#ftpchroot"     >10.14 - In ftpd(8) Benutzer in ihre
  Heimatverzeichnisse einsperren.</a>
<li><a href="#Patches"       >10.15 - Patches in OpenBSD einfügen.</a>
<li><a href="#httpdchroot"   >10.16 - Wie geht das mit dem
  chroot(2)-Apache?</a>
<li><a href="#rootshell"     >10.17 - Kann ich die Rootshell ändern?</a>
<li><a href="#ksh"           >10.18 - Was kann ich noch mit ksh
  machen?</a>
</ul>

<hr>

<p>
<a name= "wheel"></a>
<h2>10.1 - Wenn ich mich per su zu root machen will, wird mir gesagt,
dass ich in der falschen Gruppe sei.</h2>

<p>
Vorhandene Benutzer müssen per Hand zur Gruppe <kbd>wheel</kbd>
hinzugefügt werden.
Dies wird aus Sicherheitsgründen so gemacht und du solltest darauf
achten, wem du diesen Zugriff erlaubst. Unter OpenBSD ist es
Benutzern, die sich in der Gruppe <kbd>wheel</kbd> befinden, erlaubt,
das Userland-Programm <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1"
>su(1)</a> zu benutzen, um root zu werden. Benutzer, die nicht in
<kbd>wheel</kbd> sind, können nicht su(1) nutzen.
Hier ist ein Beispiel für einen <kbd>/etc/group</kbd>-Eintrag, in dem
der Benutzer <b>ericj</b> in die Gruppe <kbd>wheel</kbd>
platziert wird.

<p>
Wenn du einen neuen Benutzer mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8"
>adduser(8)</a>,
hinzufügst, kannst du ihn in die Gruppe wheel platzieren, indem du bei
der Frage "<tt>Invite <i>user</i> into other groups:</tt>" mit wheel
antwortest. Damit wird er in /etc/group eingefügt, die in etwa so
aussehen wird:

<blockquote><pre>
wheel:*:0:root,ericj
</pre></blockquote>

<p>
Wenn du nach einer Möglichkeit suchst, Benutzern eingeschränkten
Zugriff auf die Superuser-Privilegien zu geben, ohne sie in die
Gruppe <kbd>wheel</kbd> zu platzieren, verwende <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8"
>sudo(8)</a>.

<p>
<a name= "DupFS"></a>
<h2>10.2 - Wie kann ich ein Dateisystem duplizieren?</h2>

<p>
Um ein Dateisystem zu duplizieren, verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>.
Um zum Beispiel alles unter dem Verzeichnis <kbd>SRC</kbd> in das
Verzeichnis <kbd>DST</kbd> zu duplizieren, führe Folgendes aus:

<blockquote><pre>
# <b>cd /SRC; dump 0f - . | (cd /DST; restore -rf - )</b>
</pre></blockquote>

<p>
Das Programm dump wurde so entworfen, dass es dir reichliche
Backupmöglichkeiten gibt und es könnte viel zu viel sein, wenn du
einfach nur einen Teil (oder das gesamte) Dateisystem duplizieren möchtest.
Das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>
kann für diese Aufgabe schneller sein. Das Format sieht sehr ähnlich
aus:

<blockquote><pre>
# <b>cd /SRC; tar cf -  . | (cd /DST; tar xpf - )</b>
</pre></blockquote>

<p>
<a name= "rc"></a>
<h2>10.3 - Wie starte ich Daemons mit dem System? (Überblick über
rc(8))</h2>

<p>
OpenBSD verwendet eine
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">rc(8)</a>-orientierte
Startphase. Diese verwendet einige Schlüsseldateien.

<ul>
  <li>/etc/rc - Hauptskript. Sollte nicht verändert werden.
  <li>/etc/rc.conf - Konfigurationsdatei, die von <i>/etc/rc</i> genutzt
  wird, um zu ermitteln, welche Daemons mit dem System gestartet werden
  sollen.
  <li>/etc/rc.conf.local - Konfigurationsdatei, die du verwenden kannst,
  um Einstellungen in /etc/rc.conf zu überschreiben, sodass du
  /etc/rc.conf selbst nicht verändern musst, was insbesondere beim
  Upgrade des Systems angenehm ist.
  <li>/etc/netstart - Skript, das beim Initialisieren des Netzwerks
  genutzt wird. Sollte nicht verändert werden.
  <li>/etc/rc.local - Skript, das für die lokale Administration genutzt
  wird. Dies ist die Datei, in der neue Daemons oder hostspezifische
  Informationen gelagert werden sollten.
  <li>/etc/rc.securelevel - Skript, das benötigte Kommandos ausführt,
  bevor das Sicherheitslevel sich verändert. Siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a>.
  <li>/etc/rc.shutdown - Skript, das beim Herunterfahren ausgeführt
  wird. Schreibe alles in diese Datei hinein, das vor dem Herunterfahren
  gemacht werden soll. Siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.shutdown&amp;sektion=8">rc.shutdown(8)</a>.
</ul>

<h3>Wie funktioniert rc(8)?</h3>

<p>
Die Hauptdateien, auf die ein Systemadministrator zu achten hat, sind
<i>/etc/rc.conf</i> (oder <i>/etc/rc.conf.local</i>),
<i>/etc/rc.local</i> und <i>/etc/rc.shutdown</i>. Um einen Überblick
darüber zu kriegen, was ausgeführt wird, wenn die rc(8)-Prozedur
läuft, folgt nun eine Aufgabenliste:

<p>
Nachdem der Kernel geladen wurde, wird <i>/etc/rc</i> gestartet:
<ul>
  <li>Dateisysteme werden überprüft.
  <li>Konfigurationsvariablen werden von <i>/etc/rc.conf</i> gelesen
      und danach von <i>/etc/rc.conf.local</i>. Einstellungen in
      rc.conf.local werden die von rc.conf überschreiben.
  <li>Dateisysteme werden gemountet.
  <li>Löscht den Inhalt von <i>/tmp</i> und schützt jegliche
      Editordateien.
  <li>Konfiguriert das Netzwerk per <i>/etc/netstart</i>
  <ul>
    <li>Aktiviert dein Interface.
    <li>Setzt deinen Hostnamen, Domänennamen etc.
  </ul>
  <li>Startet Systemdaemons.
  <li>Führt etliche andere Überprüfungen durch (Quotas, savecore
      etc.)
  <li>Lokale Daemons werden per <i>/etc/rc.local</i> ausgeführt.
</ul>

<h3>Daemons und Dienste starten, die mit OpenBSD ausgeliefert
werden</h3>

<p>
Die meisten Daemons und Dienste, die mit OpenBSD standardmäßig
ausgeliefert werden, können beim Hochfahren ganz einfach durch das
Editieren der <i>/etc/rc.conf</i>-Konfigurationsdatei gestartet werden.
Um zu beginnen, solltest du einen Blick auf die standardmäßige
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/etc/rc.conf?content-type=text/plain">/etc/rc.conf</a>-Datei
werfen. Du wirst Zeilen wie diese sehen:

<blockquote><pre>
ftpd_flags=NO           # for non-inetd use: ftpd_flags="-D"
</pre></blockquote>

<p>
Eine Zeile wie diese zeigt, dass ftpd nicht beim Systemstart aktiviert
werden soll (zumindest nicht über rc(8), lies die
<a href="faq10.html#AnonFTP">Anonymous-FTP-FAQ</a>, um mehr darüber zu
erfahren).
Unter allen Umständen hat jede Zeile einen Kommentar, der dir die
Optionen zeigt, die nur für <b>NORMALE</b> Verwendung von diesem Daemon
oder Dienst benötigt werden. Das bedeutet nicht, dass du diesen Daemon
oder Dienst mit diesen Optionen aufrufen musst.
Lies die entsprechende Manualseite, um zu sehen, wie du diesen Daemon
oder Dienst so starten kannst, wie du möchtest. Hier ist zum Beispiel
die Standardzeile, die zu httpd(8) gehört.

<blockquote><pre>
httpd_flags=NO          # for normal use: "" (or "-DSSL" after reading ssl(8))
</pre></blockquote>

<p>
Hier kannst du offensichtlich erkennen, dass für den normalen Start von
httpd keine Optionen notwendig sind. Daraus folgt, dass eine Zeile wie
»<b> httpd_flags=""</b>« benutzt werden kann. Um aber httpd mit ssl zu
aktiveren (Siehe auch <a href="#HTTPS">SSL-FAQ</a> oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>),
solltest du mit einer derartigen Zeile starten: httpd_flags="-DSSL".

<p>
Eine gute Vorgehensweise ist, niemals <i>/etc/rc.conf</i> selbst zu
bearbeiten. Erstelle stattdessen die Datei <i>/etc/rc.conf.local</i>,
kopiere einfach die Zeilen, die du ändern möchtest, von
<i>/etc/rc.conf</i> und passe sie so an, wie du möchtest. Das macht
zukünftige Upgrades einfacher - alle Änderungen befinden sich in dieser
einen Datei.

<h3>Lokale Daemons starten und konfigurieren</h3>

<p>
Für andere Daemons, die du vielleicht auf deinem System über Ports
oder auf andere Wege installieren willst, solltest du die
<i>/etc/rc.local</i>-Datei verwenden. Ich habe zum Beispiel einen
Daemons installiert, der unter /usr/local/sbin/daemonx liegt. Ich
möchte, dass dieser beim Hochfahren startet. Ich würde einen Eintrag
wie den folgenden in <i>/etc/rc.local</i> schreiben:

<blockquote><pre>
if [ -x /usr/local/sbin/daemonx ]; then
             echo -n ' daemonx';       /usr/local/sbin/daemonx
fi
</pre></blockquote>

<p>
(Wenn der Daemon sich beim Starten nicht automatisch von der Konsole
löst, denke daran, dass du ein »&amp;« an das Ende der Kommandozeile
hängen musst.)

<p>
Von nun an wird dieser Daemon beim Booten gestartet. Du wirst in der
Lage sein, jegliche Fehler beim Hochfahren zu sehen, ein normaler Boot
ohne Fehler würde eine Zeile wie die folgende anzeigen:

<blockquote><pre>
Starting local daemons: daemonx.
</pre></blockquote>

<h3>rc.shutdown</h3>

<p>
<i>/etc/rc.shutdown</i> ist ein Skript, das beim Herunterfahren
ausgeführt wird. Alles, was du zuvor erledigt haben möchtest, bevor das
System herunterfährt, sollte in diese Datei geschrieben werden. Falls du
apm hast, kannst du ebenfalls powerdown=YES setzen. Das wird dir das
Äquivalent zu »shutdown -p« geben.

<p>
<a name= "RelayingDenied"></a>
<h2>10.4 - Wieso erhalten Benutzer ein »relaying denied« wenn sie
versuchen, von woanders her Mails über mein OpenBSD-System zu
verschicken?</h2>
<p>
Versuch das hier:

<blockquote><pre>
# <b>grep relay-domains /etc/mail/sendmail.cf</b>
</pre></blockquote>

<p>
Die Ausgabe könnte wie folgt sein:

<blockquote><pre>
FR-o /etc/mail/relay-domains
</pre></blockquote>

<p>
Wenn diese Datei nicht vorhanden ist, erstelle sie. Du musst die Hosts
mit der folgenden Syntax eintragen, die Mails über dein System senden.

<blockquote><pre>
.domain.com    #Allow relaying for/to any host in domain.com
sub.domain.com #Allow relaying for/to sub.domain.com and any host in that domain
10.2           #Allow relaying from all hosts in the IP net 10.2.*.*
</pre></blockquote>

<p>
Vergiss nicht, ein HangUP-Signal an sendmail zu senden (ein Signal,
das die meisten Daemons veranlasst, ihre Konfigurationsdatei erneut
einzulesen):

<blockquote><pre>
# <b>kill -HUP `head -1 /var/run/sendmail.pid`</b>
</pre></blockquote>

<p>

<h3>Weitere Informationen</h3>

<p>
<ul>
<li><a href="http://www.sendmail.org/~ca/email/relayingdenied.html">http://www.sendmail.org/~ca/email/relayingdenied.html</a>
<li><a href="http://www.sendmail.org/tips/relaying.php">http://www.sendmail.org/tips/relaying.php</a>
<li><a href="http://www.sendmail.org/antispam/">http://www.sendmail.org/antispam/</a>
</ul>

<p>
<a name= "POP"></a>
<h2>10.5 - Ich habe POP installiert, erhalte aber Fehler, wenn ich
versuche, meine Mails per POP abzuholen. Was kann ich tun?</h2>

<p>
Die meisten Konflikte mit POP sind Probleme mit temporären und
Lockdateien. Wenn dein POP-Server eine Fehlernachricht wie diese
sendet:

<blockquote><pre>
-ERR Couldn't open temporary file, do you own it?
</pre></blockquote>

<p>
Versuche, deine Berechtigungen wie folgt einzurichten:

<blockquote><pre>
permission in  /var
drwxrwxr-x   2 bin     mail     512 May 26 20:08 mail


permissions in  /var/mail
-rw-------   1 username   username        0 May 26 20:08 username
</pre></blockquote>

<p>
Eine andere Sache, die überprüft werden sollte, ist, dass der Benutzer
tatsächlich seine eigene /var/mail-Datei besitzt. Selbstverständlich
sollte das der Fall sein (also, dass /var/mail/joe joe gehört) aber wenn
das nicht richtig eingestellt ist, könnte es das Problem sein!

<p>
Selbstverständlich wird eine Schreibberechtigung der Gruppe mail ein
unwahrscheinliches und obskures Sicherheitsproblem hervorrufen. Es ist
sehr wahrscheinlich, dass du niemals Probleme damit haben wirst. Aber
es könnte sein (insbesondere, wenn du eine sehr beschäftigte Site hast,
ISP, ...)! Es gibt einige POP-Server, die du direkt von der
Ports-Kollektion aus installieren kannst. Wenn möglich, verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=popa3d&amp;sektion=8">popa3d</a>,
das in der OpenBSD-Basisinstallation vorhanden ist.
Oder aber, du könntest einfach die falschen Optionen für deinen
POP-Daemon ausgewählt haben (wie Dotlocking). Vielleicht musst du
das Verzeichnis wechseln, in dem er ein Lockin durchführt (obwohl
das Locking dann nur für den POP-Daemon von Bedeutung sein wird).

<p>
<b>Hinweis:</b> Denke daran, dass OpenBSD keine Gruppe namens mail
hat. Du musst diese in deiner <i>/etc/group</i>-Datei erstellen, wenn du
sie brauchst. Ein Eintrag wie:

<blockquote><pre>
mail:*:6:
</pre></blockquote>

<p>
wäre ausreichend.

<a name="SendmailDNS"></a>
<h2>10.6 - Warum ignoriert Sendmail die <tt>/etc/hosts</tt>-Datei?</h2>

<p>
Standardmäßig verwendet Sendmail DNS für die Namensauflösung, nicht die
<tt>/etc/hosts</tt>-Datei. Die Vorgehensweise kann durch das Nutzen der
<tt>/etc/mail/service.switch</tt>-Datei geändert werden.

<p>
Wenn du die hosts-Datei vor den DNS-Servern überprüfen willst, erstelle
eine <tt>/etc/mail/service.switch</tt>-Datei, welche folgende Zeile
beinhaltet:

<blockquote><pre>
hosts       files dns
</pre></blockquote>

<p>
Wenn du NUR die hosts-Datei überprüfen willst, verwende die folgende:

<blockquote><pre>
hosts       files
</pre></blockquote>

<p>
Sende Sendmail ein HUP-Signal:

<blockquote><pre>
# <b>kill -HUP `head -1 /var/run/sendmail.pid`</b>
</pre></blockquote>

<p>
und die Änderungen werden wirksam.


<p>
<a name= "HTTPS"></a>
<h2>10.7 - Einen sicheren HTTP-Server mit Hilfe von SSL(8)
aufsetzen</h2>

<p>
OpenBSD wird mit einem SSL-fähigen httpd und RSA-Bibliotheken
ausgeliefert. Für die Verwendung mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
musst du zuerst ein Zertifikat erstellen. Dieses wird unter
<i>/etc/ssl/</i> mit dem dazugehörigen Schlüssel unter
<i>/etc/ssl/private/</i> abgelegt.
Die Schritte, die hier gezeigt werden, sind Teil der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>-Manualseite.
Greife für weitere Informationen auf diese zurück.
Dieser FAQ-Eintrag zeigt nur, wie man ein RSA-Zertifikat für Webserver
erstellt, nicht ein Zertifikat für einen DSA-Server. Um zu erfahren, wie
man das macht, greife auf die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>-Manualseite
zurück.

<p>
Um zu beginnen, musst du deinen Serverschlüssel und dein -zertifikat
unter Verwendung von OpenSSL erstellen:

<blockquote><pre>
# <b>openssl genrsa -out /etc/ssl/private/server.key 1024</b>
</pre></blockquote>

<p>
Oder, wenn du möchtest, dass dein Schlüssel mit einem Passwort
verschlüsselt wird, das du beim Starten des Servers angeben wirst:

<blockquote><pre>
# <b>openssl genrsa -des3 -out /etc/ssl/private/server.key 1024</b>
</pre></blockquote>

<p>
Der nächste Schritt ist das Generieren eines »Certificate Signing
Request«, welches genutzt wird, um eine »Certifying Authority« (CA)
dazu zu bringen, dein Zertifikat zu signieren. Verwende hierfür dieses
Kommando:

<blockquote><pre>
# <b>openssl req -new -key /etc/ssl/private/server.key -out /etc/ssl/private/server.csr</b>
</pre></blockquote>

<p>
Diese <i>server.csr</i>-Datei kann danach zu einer »Certifying
Authority« übergeben werden, die den Schlüssel signieren wird. Eine
solche CA ist <b>Thawte Certification</b>, welche unter
<a href="http://www.thawte.com/">http://www.thawte.com/</a> erreicht
werden kann.

<p>
Wenn du dir das nicht leisten kannst oder du das Zertifikat einfach nur
selbst signieren möchtest, kannst du das Folgende nutzen.

<blockquote><pre>
# <b>openssl x509 -req -days 365 -in /etc/ssl/private/server.csr \
       -signkey /etc/ssl/private/server.key -out /etc/ssl/server.crt</b>
</pre></blockquote>

<p>
Mit <i>/etc/ssl/server.crt</i> und <i>/etc/ssl/private/server.key</i>
an der richtigen Stelle solltest du in der Lage sein,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
mit der Option <b>-DSSL</b> zu starten (siehe die
<a href="#rc">Sektion über rc(8)</a> in dieser FAQ), was
HTTPS-Transaktionen mit deiner Maschine über den Port 443 ermöglicht.

<p>
<a name= "vipw"></a>
<h2>10.8 - Ich habe zwar mit vi(1) Änderungen an /etc/passwd gemacht,
die Änderungen haben aber keinen Effekt. Warum?</h2>

<p>
Wenn du <i>/etc/passwd</i> direkt editierst, werden deine Änderungen
verloren gehen. OpenBSD generiert <i>/etc/passwd</i> dynamisch mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pwd_mkdb&amp;sektion=8">pwd_mkdb(8)</a>.
Die Hauptpasswortdatei unter OpenBSD ist <i>/etc/master.passwd</i>.
Laut pwd_mkdb(8),

<blockquote><pre>
FILES
     /etc/master.passwd  current password file
     /etc/passwd         a 6th Edition-style password file
     /etc/pwd.db         insecure password database file
     /etc/pwd.db.tmp     temporary file
     /etc/spwd.db        secure password database file
     /etc/spwd.db.tmp    temporary file
</pre></blockquote>

<p>
In einer traditionellen Unix-Passwortdatei, wie /etc/passwd, ist alles
für jeden auf dem System verfügbar, dazu zählt auch das verschlüsselte
Passwort des Benutzers (und ist somit das Hauptziel für Programme wie
zum Beispiel Crack).
4.4BSD führte die Datei master.passwd ein, welche ein erweitertes Format
hat (mit zusätzlichen Optionen, die über die hinausgehen, die in
/etc/passwd aufgelistet sind) und ist nur von root lesbar. Für
schnelleren Zugriff auf die Daten lesen die Bibliotheksaufrufe, die
auf jene Daten zugreifen, normalerweise /etc/pwd.db und /etc/spwd.db.

<p>
OpenBSD wird mit einem Tool ausgeliefert, mit welchen du deine
Passwortdatei editieren solltest. Es wird <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vipw&amp;sektion=8"
>vipw(8)</a> genannt.
Vipw verwendet vi (oder deinen bevorzugten Editor, der mit $EDITOR
definiert wird), um /etc/master.passwd zu bearbeiten. Wenn du mit dem
Editieren fertig bist, wird es /etc/passwd, /etc/pwd.db und /etc/spwd.db
anhand deiner Änderungen aktualisieren. Vipw kümmert sich ebenfalls um
das Locking dieser Dateien, sodass, falls jemand zur gleichen Zeit
versucht, sie zu editieren, ihm der Zugriff verwehrt wird.

<p>
<a name= "AddDelUser"></a>
<h2>10.9 - Was ist der beste Weg, Benutzer hinzuzufügen oder zu
löschen?</h2>

<p>
OpenBSD bietet zwei Kommandos, um Benutzer auf einfache Weise dem
System hinzuzufügen:

<ul>
<li><a href="#adduser">adduser(8)</a>
<li><a href="#user">user(8)</a>
</ul>

Du kannst Benutzer ebenfalls manuell unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vipw&amp;sektion=8">vipw(8)</a>
hinzufügen, aber das ist für die meisten Operationen umständlicher.

<a name="adduser"></a>
<p>
Der einfachste Weg, um einen Benutzer unter OpenBSD hinzuzufügen, ist
die Verwendung des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>-Skripts.
Du kannst adduser(8) durch das Editieren der <i>/etc/adduser.conf</i>
konfigurieren.
adduser(8) erlaubt Konsistenzüberprüfungen für <i>/etc/passwd</i>,
<i>/etc/group</i> und Shelldatenbanken. Es wird die Einträge und
$HOME-Verzeichnisse für dich erstellen. Es kann sogar eine Nachricht
an die Benutzer zur Begrüßung senden. Hier ist ein Beispielbenutzer,
<b>testuser</b>, der zu einem System hinzugefügt wird.
Er/Sie bekommt das $HOME-Verzeichnis <i>/home/testuser</i>, wird ein
Mitglied der Gruppe <b>guest</b> und bekommt die Shell <i>/bin/ksh</i>.

<blockquote><pre>
# <b>adduser</b>
Use option ``-silent'' if you don't want to see all warnings and questions.

Reading /etc/shells
Reading /etc/login.conf
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username []: <b>testuser</b>
Enter full name []: <b>Test FAQ User</b>
Enter shell csh ksh nologin sh [sh]: <b>ksh</b>
Uid [1002]: <b><i>Enter</i></b>
Login group testuser [testuser]: <b>guest</b>
Login group is ``guest''. Invite testuser into other groups: guest no
[no]: <b>no</b>
Login class auth-defaults auth-ftp-defaults daemon default staff
[default]: <b><i>Enter</i></b>
Enter password []: <b><i>Type password, then Enter</i></b>
Enter password again []: <b><i>Type password, then Enter</i></b>

Name:        testuser
Password:    ****
Fullname:    Test FAQ User
Uid:         1002
Gid:         31 (guest)
Groups:      guest
Login Class: default
HOME:        /home/testuser
Shell:       /bin/ksh
OK? (y/n) [y]: <b>y</b>
Added user ``testuser''
Copy files from /etc/skel to /home/testuser
Add another user? (y/n) [y]: <b>n</b>
Goodbye!
</pre></blockquote>

<p>
Um Benutzer zu entfernen, solltest du das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rmuser&amp;sektion=8">rmuser(8)</a>-Werkzeug
nutzen. Dieses wird jegliche Existenz eines Benutzers löschen. Es wird
jegliche
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crontab&amp;sektion=1">crontab(1)</a>-Einträge
entfernen, sein $HOME-Verzeichnis (wenn es dem Benutzer gehört) und
seine Mails. Selbstverständlich wird es ebenfalls seine
<i>/etc/passwd</i>- und <i>/etc/group</i>-Einträge löschen. Als nächstes
folgt ein Beispiel, in dem der Benutzer, der gerade hinzugefügt wurde,
wieder gelöscht wird. Achte darauf, dass du nach dem Namen gefragt wirst
und ob du das Heimatverzeichnis des Benutzers löschen möchtest oder
nicht.

<blockquote><pre>
# <b>rmuser</b>
Enter login name for user to remove: <b>testuser</b>
Matching password entry:

testuser:$2a$07$ZWnBOsbqMJ.ducQBfsTKUe3PL97Ve1AHWJ0A4uLamniLNXLeYrEie:1002
:31::0:0:Test FAQ User:/home/testuser:/bin/ksh

Is this the entry you wish to remove? <b>y</b>
Remove user's home directory (/home/testuser)? <b>y</b>
Updating password file, updating databases, done.
Updating group file: done.
Removing user's home directory (/home/testuser): done.
</pre></blockquote>

<a name="user"></a>
<h3>Benutzer mit user(8) hinzufügen</h3>

<p>
Diese Tools sind nicht so interaktiv wie das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>-Kommando,
wodurch sie einfacher in Skripten genutzt werden können.

<p>
Die gesamte Palette dieser Tools ist:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=group&amp;sektion=8">group(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupadd&amp;sektion=8">groupadd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupdel&amp;sektion=8">groupdel(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupinfo&amp;sektion=8">groupinfo(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupmod&amp;sektion=8">groupmod(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=user&amp;sektion=8">user(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=useradd&amp;sektion=8">useradd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=userdel&amp;sektion=8">userdel(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=userinfo&amp;sektion=8">userinfo(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=usermod&amp;sektion=8">usermod(8)</a>
</ul>

<h4>Benutzer tatsächlich hinzufügen</h4>

<p>
Da user(8) nicht interaktiv ist, ist der einfachste Weg, um auf
effiziente Art und Weise Benutzer hinzuzufügen, das adduser(8)-Kommando.
Das tatsächliche Kommando <i>/usr/sbin/user</i> ist nur eine Oberfläche
für die restlichen <i>/usr/sbin/user*</i>-Kommandos. Daher können die
folgenden Kommandos unter Verwendung von <b>user add</b> oder
<b>useradd</b> hinzugefügt werden; es ist deine Wahl, was du nutzen
willst und ändert nichts an der Tatsache, wie die Kommandos genutzt
werden.

<p>
In diesem Beispiel werden wir den gleichen Benutzer mit den gleichen
Eigenschaften anlegen, wie wir es <a href="#adduser">zuvor</a> gemacht
haben. useradd(8) ist viel einfacher zu nutzen, wenn du die
standardmäßigen Einstellungen vor dem Hinzufügen eines Benutzers weißt.
Diese Einstellungen befinden sich in <i>/etc/usermgmt.conf</i> und
können wie folgt angezeigt werden:

<blockquote><pre>
$ <b>user add -D</b>
group           users
base_dir        /home
skel_dir        /etc/skel
shell           /bin/csh
inactive        0
expire          Null (unset)
range           1000..60000
</pre></blockquote>

<p>
Die oben stehenden Einstellungen sind die, die genommen werden, wenn
du keine anderen über die Kommandozeilenoptionen übergibst. In unserem
Fall zum Beispiel möchten wir, dass der Benutzer zur Gruppe
<b>guest</b> statt zur Gruppe <b>users</b> gehört.
Ein weiteres Problem beim Hinzufügen der Benutzer ist, dass Passwörter
in der Kommandozeile angegeben werden müssen. Dabei handelt es sich um
das verschlüsselte Passwort, sodass du zuerst das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=encrypt&amp;sektion=1">encrypt(1)</a>-Werkzeug
nutzen musst, um das Passwort zu erstellen. Zum Beispiel: OpenBSDs
Passwörter werden standardmäßig unter Verwendung des
Blowfish-Algorithmus mit 6 Runden verschlüsselt. Hier ist eine
Beispielzeile, die zeigt, wie man ein verschlüsseltes Passwort
erstellt, das man dann useradd(8) übergibt.

<blockquote><pre>
$ <b>encrypt -p -b 6</b>
Enter string:
$2a$06$YOdOZM3.4m6MObBXjeZtBOWArqC2.uRJZXUkOghbieIvSWXVJRzlq
</pre></blockquote>

<p>
Nun, da wir unser verschlüsseltes Passwort haben, sind wir bereit,
den Benutzer hinzuzufügen.

<blockquote><pre>
# <b>user add -p '$2a$06$YOdOZM3.4m6MObBXjeZtBOWArqC2.uRJZXUkOghbieIvSWXVJRzlq' -u 1002 \
-s /bin/ksh -c "Test FAQ User" -m -g guest testuser</b>
</pre></blockquote>

<p>
<b>Hinweis:</b> Stelle sicher, dass du '&nbsp;' (einfache
Anführungszeichen) um die Passwortzeichenkette legst, nicht etwa
"&nbsp" (doppelte Anführungszeichen), da die Shell diese
vor dem Übergeben an user(8) auswerten würde. Stelle zusätzlich dazu
sicher, dass du Option <b>-m</b> übergibst, wenn du möchtest, dass das
Heimatverzeichnis vom Benutzer angelegt und die Dateien aus
<i>/etc/skel</i> herüberkopiert werden.

<p>
Um zu sehen, ob der Benutzer korrekt angelegt wurde, können wir viele
verschiedene Werkzeuge nutzen. Unterhalb stehen ein paar Kommandos,
du du benutzen kannst, um schnell zu überprüfen, ob alles richtig
gemacht wurde.

<blockquote><pre>
$ <b>ls -la /home</b>
total 14
drwxr-xr-x   5 root      wheel   512 May 12 14:29 .
drwxr-xr-x  15 root      wheel   512 Apr 25 20:52 ..
drwxr-xr-x  24 ericj     wheel  2560 May 12 13:38 ericj
drwxr-xr-x   2 testuser  guest   512 May 12 14:28 testuser
$ <b>id testuser</b>
uid=1002(testuser) gid=31(guest) groups=31(guest)
$ <b>finger testuser</b>
Login: testuser                         Name: Test FAQ User
Directory: /home/testuser               Shell: /bin/ksh
Last login Sat Apr 22 16:05 (EDT) on ttyC2
No Mail.
No Plan.
</pre></blockquote>

<p>
Zusätzlich zu diesen Kommandos bietet user(8) sein eigenes Werkzeug,
um Benutzercharakteristiken anzuzeigen, welches userinfo(8) genannt
wird.

<blockquote><pre>
$ <b>userinfo testuser</b>
login   testuser
passwd  *
uid     1002
groups  guest
change  Wed Dec 31 19:00:00 1969
class
gecos   Test FAQ User
dir     /home/testuser
shell   /bin/ksh
expire  Wed Dec 31 19:00:00 1969
</pre></blockquote>

<h4>Benutzer löschen</h4>

<p>
Um Benutzer mit Kommandos der user(8)-Hierarchie zu entfernen, wirst
du userdel(8) nutzen müssen. Dies ist ein sehr einfaches, aber dennoch
sehr nützliches, Kommando. Um den Benutzer zu löschen, der im letzten
Beispiel angelegt wurde, verwende einfach:

<blockquote><pre>
# <b>userdel -r testuser</b>
</pre></blockquote>

<p>
Beachte die Option <b>-r</b>, die angegeben werden muss, wenn du
möchtest, dass das Heimatverzeichnis des Benutzers ebenfalls gelöscht
werden soll. Als Alternative dazu kannst du statt <b>-r</b> auch
<b>-p</b> angeben, wodurch der Account des Benutzers gesperrt wird,
aber keine Informationen gelöscht werden.

<p>
<a name= "FTPOnly"></a>
<h2>10.10 - Wie erzeugt man ein Benutzerkonto, das nur für FTP genutzt
werden kann?</h2>

<p>
Es gibt ein paar Wege, das zu bewerkstelligen, aber ein sehr
häufig genutzter Weg ist, <tt>/usr/bin/false</tt> in
<tt>/etc/shells</tt> einzufügen. Wenn du dann die Shell eines
Benutzers auf <tt>/usr/bin/false</tt> setzt, wird dieser Benutzer
nicht in der Lage sein, sich interaktiv anzumelden, kann aber noch
die FTP-Möglichkeiten nutzen. Du möchtest vielleicht ebenfalls den
Zugriff beschränken, indem du <a href="#ftpchroot">Benutzer unter
ftpd in ihre Heimatverzeichnisse einsperrst</a>.


<p>
<a name= "Quotas"></a>
<h2>10.11 - Quotas einrichten</h2>

<p>
Quotas werden genutzt, um den Speicher auf den Platten zu begrenzen, der
den Benutzern zur Verfügung steht. Das kann insbesondere dann sinnvoll
sein, wenn du Ressourcen begrenzen musst. Quotas können für Benutzer
und/oder für Gruppen gesetzt werden.

<p>
Der erste Schritt, um Quotas einzurichten, ist sicherzustellen, dass
»<tt>option QUOTA</tt>« sich in deiner
<a href="faq5.html#Options">Kernelkonfiguration</a> befindet. Diese
Option ist im GENERIC-Kernel. Hiernach musst du die Dateisysteme in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5"><tt>/etc/fstab</tt></a>
markieren, für die Quotas aktiviert sein sollen.
Die Schlüsselwörter <tt>userquota</tt> und <tt>groupquota</tt> sollten
verwendet werden, um jedes einzelne Dateisystem zu markieren, für die
Quotas aktiviert sein sollen. Standardmäßig werden die Dateien
<tt>quota.user</tt> und <tt>quota.group</tt> im Root der Dateisysteme
erstellt, um die Quota-Informationen zu erfassen. Dieser Standard kann
geändert werden, indem der Dateiname mit der Quota-Option in
<tt>/etc/fstab</tt> angegeben wird, wie zum Beispiel
<tt>userquota=/var/quotas/quota.user</tt>.
Hier ist ein Beispiel für eine <tt>/etc/fstab</tt>, die ein Dateisystem
mit aktivierten userquotas hat und die Quotadatei sich an einer
nicht standardmäßigen Stelle befindet:

<blockquote><pre>
/dev/wd0a / ffs rw,userquota=/var/quotas/quota.user 1 1
</pre></blockquote>

<p>
Jetzt ist es Zeit, um die Quotas für die Benutzer einzurichten. Verwende
hierfür das Werkzeug
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=edquota&amp;sektion=8">edquota(8)</a>.
Ein einfacher Aufruf wäre »<tt>edquota&nbsp;&lt;user&gt;</tt>«. edquota(8)
wird vi(1) nutzen, um die Quotas zu ändern, es sei denn, die
Umgebungsvariable EDITOR wurde auf einen anderen Editor gesetzt. Zum
Beispiel:

<blockquote><pre>
# <b>edquota ericj</b>
</pre></blockquote>

<p>
Dies wird dir eine Ausgabe geben, die ähnlich dieser ist:

<blockquote><pre>
Quotas for user ericj:
/: KBytes in use: 62, limits (soft = 0, hard = 0)
        inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

<p>
Um Begrenzungen hinzuzufügen, editiere sie, um Resultate
wie diese hier zu erhalten:

<blockquote><pre>
Quotas for user ericj:
/: KBytes in use: 62, limits (soft = 1000, hard = 1050)
        inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

<p>
Beachte, dass die Quota-Allokierung auf 1-k-Blöcke gesetzt ist.
In diesem Fall wurde das Softlimit auf 1000 k gesetzt und das
Hardlimit auf 1050 k. Ein Softlimit ist eine Begrenzung, bei der der
Benutzer lediglich gewarnt wird, dass er sie überschritten hat und
weiterhin über ihr liegt, bis ihre Schonzeit vorbei ist und ihre
Plattennutzung wieder unter diese Grenze reduziert wird. Schonzeiten
können mit edquota(8) und der Option <b>-t</b> gesetzt werden.
Wenn die Schonzeit vorbei ist, dann wird das Softlimit als Hardlimit
angesehen. Dies führt normalerweise zu Allokierungsfehlern.

<p>
Nun, da die Quotas gesetzt sind, musst du die Quotas aktivieren. Um dies
zu tun, verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quotaon&amp;sektion=8">quotaon(8)</a>.
Zum Beispiel:

<blockquote><pre>
# <b>quotaon -a</b>
</pre></blockquote>

<p>
Dies wird durch <tt>/etc/fstab</tt> gehen und alle Dateisysteme mit
Quota-Optionen aktivieren. Nun, da Quotas eingerichtet sind und laufen,
kannst du sie mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quota&amp;sektion=1">quota(1)</a>.
betrachten. Die Nutzung von einem Kommando wie
»<tt>quota &lt;user&gt;</tt>« gibt dir die Informationen über einen
Benutzer. Wenn es mit keinen Argumenten aufgerufen wird, wird das
quota(1)-Kommando deine Quota-Statistiken ausgeben. Zum Beispiel:

<blockquote><pre>
# <b>quota ericj</b>
</pre></blockquote>

<p>
Wird zu einer Ausgabe führen, die dieser ähnlich ist:

<blockquote><pre>
Disk quotas for user ericj (uid 1001):
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
              /      62    1000    1050              27       0       0
</pre></blockquote>

<p>
Standardmäßig werden Quotas, die in <tt>/etc/fstab</tt> gesetzt sind,
automatisch beim Hochfahren aktiviert. Um sie auszuschalten, verwende:

<blockquote><pre>
# <b>quotaoff -a</b>
</pre></blockquote>

<p>
<a name= "Kerberos"></a>
<h2>10.12 - KerberosV-Clients und -Server einrichten</h2>

<p>
OpenBSD beinhaltet KerberosV als vorinstallierte Komponente des
Standardsystems.

<p>
Für weitere Informationen über KerberosV rufe folgendes Kommando von
deinem OpenBSD-System aus auf:
<blockquote><pre>
# <b>info heimdal</b>
</pre></blockquote>


<p>
<a name= "AnonFTP"></a>
<h2>10.13 - Anonymous-FTP-Dienste einrichten</h2>

<p>
Anonymous FTP erlaubt Benutzern ohne Accounts, auf Dateien auf deinem
Computer über das »File Transfer Protocol« zuzugreifen. Dies hier gibt
einen Überblick über das Einrichten eines Anonymous-FTP-Servers,
dem Aufzeichnen (logging) dieses Servers etc.

<h3>Das FTP-Benutzerkonto hinzufügen</h3>

<p>
Um beginnen zu können, musst du einen <i>ftp</i>-Account auf deinem System
haben. Dieser Account sollte kein nutzbares Passwort haben. Hier werden
wir das Login-Verzeichnis auf /home/ftp setzen, aber du kannst es
wohin du willst legen. Wenn Anonymous FTP genutzt wird, wird der
FTP-Daemon sich selbst in das Heimatverzeichnis des <i>ftp</i>-Users
chrooten. Um mehr hierüber zu erfahren, lies die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>-
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>-Manualseiten.
Hier ist ein Beispiel, wie man den Benutzer <i>ftp</i> hinzufügt. Ich
werde das unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>
machen.
Wir müssen ebenfalls /usr/bin/false in unsere <i>/etc/shells</i>
hinzufügen, dies ist die Shell, die wir dem <i>ftp</i>-User zuteilen.
Dies erlaubt ihnen nicht, sich einzuloggen, selbst wenn wir ihm ein
leeres Passwort geben. Um das zu tun, kannst du einfach Folgendes
ausführen:

<blockquote><pre>
echo /usr/bin/false &gt;&gt; /etc/shells
</pre></blockquote>

Hiernach ist alles vorbereitet, sodass der <i>ftp</i>-Benutzer
hinzugefügt werden kann:

<blockquote><pre>
# <b>adduser</b>
Use option ``-silent'' if you don't want to see all warnings and questions.

Reading /etc/shells
Reading /etc/login.conf
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username []: <b>ftp</b>
Enter full name []: <b>anonymous ftp</b>
Enter shell csh false ksh nologin sh tcsh zsh [sh]: <b>false</b>
Uid [1002]: <b><i>Enter</i></b>
Login group ftp [ftp]: <b><i>Enter</i></b>
Login group is ``ftp''. Invite ftp into other groups: guest no
[no]: <b>no</b>
Login class auth-defaults auth-ftp-defaults daemon default staff
[default]: <b><i>Enter</i></b>
Enter password []: <b><i>Enter</i></b>
Set the password so that user cannot logon? (y/n) [n]: <b>y</b>

Name:        ftp
Password:    ****
Fullname:    anonymous ftp
Uid:         1002
Gid:         1002 (ftp)
Groups:      ftp
Login Class: default
HOME:        /home/ftp
Shell:       /usr/bin/false
OK? (y/n) [y]: <b>y</b>
Added user ``ftp''
Copy files from /etc/skel to /home/ftp
Add another user? (y/n) [y]: <b>n</b>
Goodbye!
</pre></blockquote>

<h3>Verzeichniseinrichtung</h3>

<p>
Neben dem Benutzer wurde hiermit das Verzeichnis <i>/home/ftp</i>
angelegt. Das ist genau das, was wir wollen, aber es müssen einige
Änderungen vorgenommen werden, die wir machen müssen, um es für
Anonymous FTP bereit zu machen. Es sei wieder erwähnt, dass diese
Änderungen in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>-Manualseite
beschrieben werden.

<p>
Du <b>musst nicht</b> ein Verzeichnis namens /home/ftp/usr oder
/home/ftp/bin erstellen.
<ul>
<li><i>/home/ftp</i> - Dieses ist das Hauptverzeichnis. Es sollte root
gehören und die Rechte 555 haben.
<li><i>/home/ftp/etc</i> - Dieses ist vollkommen optional und nicht
empfohlen, da es nur dazu dient, Informationen über Benutzer
herauszugeben, die es auf deinem System gibt. Wenn du möchtest, dass
dein Anonymous-FTP-Verzeichnis so wirkt, als wenn deine Dateien
echten Benutzern gehören, solltest du /etc/pwd.db und /etc/group in
dieses Verzeichnis kopieren. Dieses Verzeichnis sollte die Rechte 511
haben und die beiden Dateien die Rechte 444. Diese werden benötigt, um
Benutzernamen in Abhängigkeit der Nummern zuzuweisen. Es werden keine
Passwörter in pwd.db gespeichert, die sind all in spwd.db, sodass du
die Datei nicht hineinkopieren solltest.
<li><i>/home/ftp/pub</i> - Dieses ist das Standardverzeichnis, in das
Dateien gelegt werden sollten, die du zur Verfügung stellen willst.
Dieses Verzeichnis sollte ebenfalls die Rechte 555 haben.
</ul>

<p>
Beachte, dass alle Verzeichnisse Root gehören sollten. Hier ist eine
Liste, wie die Verzeichnisse nach der Erstellung aussehen sollten.

<blockquote><pre>
# pwd
/home
# ls -laR ftp
total 5
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 .
drwxr-xr-x  7 root  wheel  512 Jul  6 10:58 ..
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 etc
dr-xr-xr-x  2 root  ftp    512 Jul  6 11:33 pub

ftp/etc:
total 43
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 .
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 ..
-r--r--r--  1 root  ftp    316 Jul  6 11:34 group
-r--r--r--  1 root  ftp  40960 Jul  6 11:34 pwd.db

ftp/pub:
total 2
dr-xr-xr-x  2 root  ftp  512 Jul  6 11:33 .
dr-xr-xr-x  5 root  ftp  512 Jul  6 11:33 ..
</pre></blockquote>

<h3>Den Server und das Aufzeichnen starten</h3>

<p>
Du kannst ftpd entweder über
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>
oder von den <a href="#rc">rc</a>-Skripten aus starten.
Diese Beispiele zeigen, wie unser Daemon von inetd.conf aus
aufgerufen wird. Zuerst müssen wir uns mit den Optionen für ftpd
vertraut machen. Der Standardeintrag in <i>/etc/inetd.conf</i> sieht
wie folgt aus:

<blockquote><pre>
<b>ftp             stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -US</b>
</pre></blockquote>

<p>
Hier wird ftpd mit <i>-US</i> augerufen. Hiermit werden alle
anonymen Verbindungen unter <i>/var/log/ftpd</i> aufgezeichnet und
zusammenwirkende Verbindungen unter <i>/var/run/utmp</i>. Somit können
diese Sitzungen per who(1) angesehen werden. Für einige gilt, dass sie
nur einen Anonymous-Server starten wollen und somit ftp für Benutzer
deaktivieren sollten. Rufe hierzu ftpd mit der Option <i>-R</i> auf.
Hier ist eine Zeile, die ftpd so startet, dass nur anonyme Verbindungen
zugelassen werden. Es verwendet ebenfalls <i>-ll</i>, wodurch jede
Verbindung mit syslog aufgezeichnet wird, zusätzlich zu den
FTP-Kommandos get, retrieve etc.

<blockquote><pre>
<b>ftp             stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -llUSA</b>
</pre></blockquote>

<p>
<b>Hinweis:</b> Leute, die FTP-Server mit HOHER Netzauslastung
verwenden, sollten ftpd nicht von inetd.conf aus aufrufen. Die beste
Möglichkeit ist, die Zeile für ftpd aus inetd.conf zu kommentieren und
ftpd von rc.conf.local mit der Option <i>-D</i> aus zu starten. Somit
wird ftpd als Daemon gestartet, was weniger zusätzliche Auslastung
bewirkt als wenn der Start von inetd aus erfolgt.
Hier ist eine Beispielzeile, wenn der Start von rc.conf.local aus
erfolgt.

<blockquote><pre>
ftpd_flags="-DllUSA"           # for non-inetd use: ftpd_flags="-D"
</pre></blockquote>

<p>
Dies funktioniert selbstverständlich nur, wenn du ftpd aus
<i>/etc/inetd.conf</i> rausgenommen und inetd veranlasst hast, die
Konfigurationsdatei neu einzulesen.

<h3>Andere relevante Dateien</h3>

<ul>
<li><i>/etc/ftpwelcome</i> - Diese beinhaltet die Willkommensnachricht
für Personen, wenn sie sich mit deinem FTP-Server verbunden haben.
<li><i>/etc/motd</i> - Diese beinhaltet die Nachricht für Personen,
die sich erfolgreich an deinem FTP-Server angemeldet haben.
<li><i>.message</i> - Diese Datei kann in beliebige Verzeichnisse gelegt
werden. Sie wird angezeigt, sobald ein Benutzer in das Verzeichnis
wechselt.
</ul>


<p>
<a name= "ftpchroot"></a>
<h2>10.14 - In ftpd(8) Benutzer in ihre Heimatverzeichnisse
einsperren.</h2>

<p>
Standardmäßig können Benutzer, wenn sie sich über ftp angemeldet haben,
in jedes Verzeichnis auf deinem Dateisystem wechseln, wenn sie die
benötigten Rechte dafür haben.
In einigen Fällen kann es sein, dass das nicht erwünscht ist.
Es ist möglich, einzuschränken, was Benutzer über die FTP-Sitzung
sehen können, indem man sie in ihr Heimatverzeichnis einsperrt.

<p>
Wenn du nur in Chroot eingeschlossene FTP-Anmeldungen erlauben willst,
verwende die Option <b>-A</b> mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>.

<p>
Wenn du diese Begrenzung gezielter einsetzen willst, macht OpenBSDs
»<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=login.conf&amp;sektion=5">login
capability infrastructure</a>« zusammen mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>
das recht einfach.
<p>

Benutzer, die sich in einer Login-Klasse mit der gesetzten Variable
<tt>ftp-chroot</tt> befinden, werden automatisch in Chroot eingeschlossen.
Zusätzlich kannst du einen Benutzernamen zur Datei <b>/etc/ftpchroot</b>
hinzufügen, damit Chroot auch für diese Benutzer genutzt wird.
Ein Benutzer muss nur in einer dieser Orte aufgelistet werden.


<p>
<a name= "Patches"></a>
<h2>10.15 - Patches in OpenBSD einfügen.</h2>

<p>
Selbst unter OpenBSD treten Fehler auf.
Einige Fehler können zu Stabilitätsproblemen führen (z.&nbsp;B. dass etwas
dazu führen kann, dass etwas nicht mehr wie gewünscht funktioniert).
Andere Fehler könnten zu Sicherheitsproblemen führen (wodurch Andere
deinen Computer auf nicht beabsichtigte Weise ,benutzen' können).
Wenn ein kritischer Fehler gefunden wurde, wird die Korrektur in den
<i>-current</i>-Source-Tree hinzugefügt und Patches für die
<a href="faq5.html#Flavors">unterstützten Releases</a> von OpenBSD
bereitgestellt. Diese Patches werden auf der
<a href="../../de/errata.html">Errata-Webseite</a> aufgelistet,
wo sie unter ,common'-Errata, die für alle
<a href="../../de/plat.html">Plattformen</a> gilt, und in Errata
unterteilt, die nur für eine oder mehr, aber nicht für alle,
Plattformen gelten.

<p>
Bedenke jedoch, dass für Neuerungen für OpenBSD keine Patches erstellt
werden, und somit nur für wichtige Stabilitäts- oder
Sicherheitskorrekturen gemacht werden, die sofort auf den betroffenen
Systemen eingespielt werden sollten (was meist NICHT für alle Systeme
gilt, je nach ihrem Anwendungsgebiet).

<p>
Es existieren drei Wege, wie du dein System mit gepatchtem Code
aktualisieren kannst:

<ul>
<li><b>Dein System auf <a href="current.html"><i>-current</i></a>
upgraden.</b>
Da alle Korrekturen in die Codebasis von <i>-current</i> übernommen
werden, ist das Aktualisieren deines Systems auf den aktuellsten
Snapshot eine gute Möglichkeit, korrigierten Code zu nutzen. Jedoch ist
der Einsatz von <i>-current</i> nicht für jeden geeignet.
<li><b>Dein System auf <a href="../../de/stable.html"><i>-stable</i>
aktualisieren</a>.</b>
Dies wird gemacht, indem du deinen Source-Tree unter Verwendung des
dazu passenden <i>-stable</i>-Branch herunterlädst oder
aktualisierst, und dann den Kernel und die Dateien vom Userland
neukompilierst. Generell ist das die einfachste Möglichkeit, obwohl sie
länger dauern kann (da das gesamte System neukompiliert wird) und ein
vollständiger Source-Checkout eine lange Zeit in Anspruch nehmen kann,
wenn deine Bandbreite begrenzt ist.
<li><b>Patche, kompiliere und installiere individuelle betroffene
Dateien.</b>
Dies werden wir in unserem Beispiel weiter unten machen.
Obwohl diese Methode weniger Bandbreite und normalerweise auch weniger
Zeit in Anspruch nimmt als ein Checkout/Update per cvs(1) und das
dazugehörige Kompilieren des Quelltextes, ist diese Methode manchmal
auch die schwierigste, da es keinen allgemein gültigen Instruktionssatz
gibt, den man befolgen könnte.
Manchmal musst du lediglich eine Applikation patchen, neukompilieren
und installieren, manchmal aber auch ganze Sektionen des Trees, wenn
das Problem sich in einer Bibliotheksdatei befindet.
</ul>

Noch einmal: Das Patchen von individuellen Dateien ist nicht immer
einfach, denke also gründlich darüber nach, ob du nicht dem
<a href="../../de/stable.html"><i>-stable</i></a>- (oder Patch-)Branch
von OpenBSD folgen willst.
Das Kombinieren und Anpassen von Patchlösungen kann durchgeführt werden,
wenn man weiß, wie alles funktioniert, aber neue Benutzer sollten eine
Methode auswählen und bei dieser bleiben.

<h3>Wie unterscheiden sich die Erratapatches von dem, was sich im
CVS-Tree befindet?</h3>

<p>
Alle Patches, die auf der
<a href="../../de/errata.html">Errata-Webseite</a> landen, sind Patches,
die direkt auf den Source-Tree vom angegebenen Release abgestimmt sind.
Patches, die für den aktuellen CVS-Tree sind, beinhalten auch andere
Änderungen, die auf einem Release-System nicht gewollt sind.
Dies ist wichtig: Wenn du einen Snapshot installiert hast, einen
Checkout für den Source-Tree zu der Zeit gemacht hast, als du den
Snapshot heruntergeladen hast, und dann versuchst, einen freigegebenen
Patch zu verwenden, wirst du eventuell feststellen, dass der Patch nicht
anwendbar ist, da der Code sich vermutlich geändert hat.



<h3>Patches anwenden.</h3>

<p>
Patches für das OpenBSD-Betriebssystem werden als Unified Diffs
zur Verfügung gestellt, welche Textdateien sind, die die Unterschiede
zum ursprünglichen Quelltext beinhalten. Sie werden <b>NICHT</b> in
Binärform ausgeliefert. Dies bedeutet, dass du, um dein System
patchen zu können, den Quelltext von der <b>RELEASE</b>-Version
vorliegen haben musst.
Generell gilt, dass du den gesamten Source-Tree haben solltest. Wenn
du ein Release von der offiziellen CD-ROM benutzt, befinden sich die
Source-Trees auf Disc 3, sie können aber auch als Dateien von den
<a href="../../de/ftp.html">FTP-Servern</a> heruntergeladen werden.
Wir nehmen an, dass du ein Checkout für den gesamten Tree gemacht
hast.

<p>
Für unser Beispiel hier betrachten wir den Patch 001 für OpenBSD 3.6,
der sich mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=st&amp;sektion=4">st(4)</a>-Treiber
befasst, der für die Verarbeitung von Bandlaufwerken zuständig ist.
Ohne diesem Patch ist das Wiedereinlesen der Daten von Backups recht
schwierig. Leute, die ein Bandlaufwerk nutzen, <i>benötigen</i> diesen
Patch, wobei diejenigen, die kein Bandlaufwerk nutzen, keine besondere
Notwendigkeit haben, diesen zu installieren.
Lass uns einen Blick auf den Patch werfen:

<blockquote><pre>
# <b>more 001_st.patch</b>
Apply by doing:
        cd /usr/src
        patch -p0 < 001_st.patch

Rebuild your kernel.

Index: sys/scsi/st.c
===================================================================
RCS file: /cvs/src/sys/scsi/st.c,v
retrieving revision 1.41
retrieving revision 1.41.2.1
diff -u -p -r1.41 -r1.41.2.1
--- sys/scsi/st.c       1 Aug 2004 23:01:06 -0000       1.41
+++ sys/scsi/st.c       2 Nov 2004 01:05:50 -0000       1.41.2.1
@@ -1815,7 +1815,7 @@ st_interpret_sense(xs)
        u_int8_t skey = sense->flags & SSD_KEY;
        int32_t info;

-       if (((sense->flags & SDEV_OPEN) == 0) ||
+       if (((sc_link->flags & SDEV_OPEN) == 0) ||
            (serr != 0x70 && serr != 0x71))
                return (EJUSTRETURN); /* let the generic code handle it */
</pre></blockquote>

Wie du sehen kannst, befindet sich am Anfang vom Patch eine kurze
Einweisung, wie er eingefügt werden kann.
Wir nehmen an, dass du ihn in das Verzeichnis <tt>/usr/src</tt> gelegt
hast, wodurch in diesem Fall folgende Schritte gemacht werden müssen:

<blockquote><pre>
# <b>cd /usr/src</b>
# <b>patch -p0 < 001_st.patch</b>
Hmm...  Looks like a unified diff to me...
The text leading up to this was:
--------------------------
|Apply by doing:
|        cd /usr/src
|        patch -p0 < 001_st.patch
|
|Rebuild your kernel.
|
|Index: sys/scsi/st.c
|===================================================================
|RCS file: /cvs/src/sys/scsi/st.c,v
|retrieving revision 1.41
|retrieving revision 1.41.2.1
|diff -u -p -r1.41 -r1.41.2.1
|--- sys/scsi/st.c      1 Aug 2004 23:01:06 -0000       1.41
|+++ sys/scsi/st.c      2 Nov 2004 01:05:50 -0000       1.41.2.1
--------------------------
Patching file sys/scsi/st.c using Plan A...
Hunk #1 succeeded at 1815.              <i>&lt;-- Look for this message!</i>
done
</pre></blockquote>

Achte auf die obrige Nachricht "<tt>Hunk #1 succeeded</tt>".
Diese weist darauf hin, dass der Patch erfolgreich eingefügt wurde.
Viele Patches sind viel komplexer als dieser hier und werden viele
Hunks und mehrere Dateien miteinbeziehen, daher solltest du in einem
solchen Fall sicherstellen, dass alle Hunks für alle Dateien
erfolgreich waren.
Wenn sie es nicht waren, heißt das normalerweise, dass dein Source-Tree
nicht richtig ist, du den Anweisungen nicht gründlich gefolgt bist,
oder aber der Patch verunstaltet wurde.
Patches sind sehr sensibel gegenüber Leerstellen - Copy&Paste von
deinem Browser wird oft Tabulatoren in Leerstellen umwandeln oder auf
andere Art und Weise die Leerstellen der Datei modifizieren, wodurch er
nicht eingefügt werden kann.

<p>
An diesem Punkt angekommen kannst du nun wie gewohnt
<a href="faq5.html#Building">den Kernel erzeugen</a>, installieren und
das System neustarten.

<p>
Nicht alle Patches sind für den Kernel.
In einigen Fällen musst du individuelle Werkzeuge neuerzeugen. In
anderen Fällen musst du alle statisch gelinkten Werkzeuge
neukompilieren, da sich eine Bibliothek änderte.
Folge den Anweisungen am Anfang vom Patch, und wenn du dir unsicher
bist, erstelle das gesamte System neu.

<p>
Patches, die für bestimmte Systeme unbedeutend sind, müssen nicht
mit eingefügt werden - normalerweise.
Wenn du zum Beispiel kein Bandlaufwerk auf deinem System hattest,
würdest du vom oben angegeben Patch nicht profitieren.
Man nimmt jedoch an, dass die Patches ,in der richtigen Reihenfolge'
eingefügt werden - es ist möglich, dass ein späterer Patch von einem
vorherigen abhängig ist. Sei dir dessen bewusst, wenn du dich dafür
entscheidest, bei der Installation von Patches ,wählerisch' zu sein, so
dass du, wenn du dir unsicher bist, alle installieren solltest.


<a name="httpdchroot"></a>
<h2>10.16 - Wie geht das mit dem chroot()-Apache?</h2>

<p>
Unter OpenBSD wird der Apache-Server
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
standardmäßig in einer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a> eingeschlossen.
Obwohl dies ein ungeheurer Sicherheitsvorteil ist, kann das zu Problemen
führen, wenn man nicht darauf vorbereitet ist.

<h3>Was ist ein chroot?</h3>

Eine in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>
eingeschlossene Anwendung wird in ein bestimmtes Verzeichnis eingesperrt
und ist nicht in der Lage, im Rest der Verzeichnisstruktur herumzuwandern,
da es das Verzeichnis als <tt>/</tt> (Root-)Verzeichnis sieht.
Im Fall von httpd(8) startet das Programm, öffnet seine Logdateien,
greift auf seine TCP-Ports zu (obwohl es zu diesem Zeitpunkt noch keine
Daten akzeptiert) und liest seine Konfiguration. Als nächstes sperrt es
sich in <i>/var/www</i> ein und lässt seine Privilegien fallen; erst
dann akzeptiert es Anfragen.
Dies bedeutet, dass alle Dateien, die von Apache zur Verfügung gestellt
und benutzt werden, sich im Verzeichnis <i>/var/www</i> befinden müssen.
In der Standardkonfiguration von OpenBSD kann der Apache-User
<i>www</i> die Dateien im <i>/var/www</i>-Verzeichnis nur lesen.
Dies hilft der Sicherheit ungemein - sollte es ein Sicherheitsproblem
mit Apache geben, wird der Schaden auf ein einziges Verzeichnis
begrenzt sein, dessen Rechte nur das Lesen erlauben und auch keine
Ressourcen hat, die jemand ausnutzen könnte.

<h3>Was bedeutet das für den Administrator?</h3>

<p>
Grob gesagt ist chroot(2)ing Apache etwas, das nicht standardmäßig
unter anderen Betriebssystemen eingesetzt wird.
Viele Applikationen und Systemkonfigurationsdateien werden in einem
chroot(2) ohne Anpassungen nicht funktionieren. Zusätzlich muss erwähnt
werden, dass sich Sicherheit und Komfort als Ziel gegenseitig
ausschließen. OpenBSDs Implementation von Apache gefährdet die
Sicherheit nicht, um Funktionen oder »Bequemlichkeiten« zu ermöglichen.

<ul>
<li><b>Historische Dateisystemlayouts:</b> Server, die von einer
älteren Version von OpenBSD upgegradet wurden, haben eventuell
Dateien im Verzeichnis der Benutzer liegen, welche selbstverständlich
nicht in einer chroot(2)-Umgebung funktionieren werden, da httpd(8)
das Verzeichnis <i>/home</i> nicht erreichen kann. Administratoren
werden vielleicht ebenfalls feststellen, dass die Partition von
/var/www zu klein ist, um alle Webdateien zu halten. Deine Möglichkeiten
sind zum Einen das Neustrukturieren oder das Ausschalten der
chroot(2)-Funktionalität. Du kannst selbstverständlich symbolische
Links von den Heimatverzeichnissen der Benutzer verwenden, die dann auf
Unterverzeichnisse von <i>/var/www</i> verweisen, aber du kannst
NICHT Links unter <i>/var/www</i> nutzen, die auf andere Teile des
Dateisystems verweisen - dies wird durch das chroot(2) verhindert.
Wenn du deinen Benutzern <a
href="faq10.html#ftpchroot">chroot(2)-geschützten FTP-Zugriff</a>
ermöglichen möchtest, musst du daran denken, dass das dann nicht
funktionieren wird, da der FTP-Chroot (wieder einmal)
den Zugriff auf die Ziele der symbolischen Links verhindern wird.
Eine Lösung hierfür ist es, nicht <i>/home</i> als Heimatverzeichnis
für solche Anwender zu benutzen sondern stattdessen etwas wie
<i>/var/www/users</i>. Symbolische Links können innerhalb der
chroot(2)-Umgebung verwendet werden - sie müssen aber relativ und
nicht absolut sein.

<li><b>Logrotation:</b> Normalerweise werden Logs rotiert, indem
die alten Dateien umbenannt werden, httpd(8) ein SIGUSR1-Signal
gesendet wird, das Apache dazu veranlasst, die alten Dateien zu
schließen und neue zu öffnen. Dies ist nicht länger möglich, da
httpd(8) nicht mehr in der Lage ist, neue Logdateien zu öffnen, um
in sie zu schreiben, sobald die Privilegien abgegeben worden sind. Daher
muss httpd(8) beendet und neugestartet werden. Es dauert manchmal
ein paar Sekunden, bis alle Kindprozesse beendet wurden. Diese
müssen beendet werden, bevor httpd(8) neugestartet werden kann. Ein
Möglichkeit, die Logs zu rotieren, ist diese:

<blockquote><pre>
# <b>apachectl stop</b>
    <i>rename your log files</i>
# <b>apachectl start ; sleep 10 ; apachectl start</b>
</pre></blockquote>

Ja, die letzte Zeile versucht, Apache sofort neuzustarten. Sollte dies
fehlschlagen, wird es nach einigen Sekunden wieder versucht. Und ja,
das bedeutet auch, dass dein Webserver jedes Mal, wenn deine Logs
rotiert werden, für kurze Zeit nicht erreichbar sein wird. Es mag zwar
nerven, doch würde der Sinn und Zweck des Chroots verworfen werden,
würde man Apache erlauben, Dateien nach dem Chroot(2)en zu öffnen!
Es gibt weitere Strategien hierfür, einschließlich die Möglichkeit,
über eine
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pipe&amp;sektion=2">pipe(2)</a>
aufzuzeichnen, und einen externen Logrotator auf der anderen Seite
der pipe(2) einzusetzen.

<li><b>Existierende Apache-Module:</b> Fast alle werden geladen,
jedoch können einige nicht richtig in chroot(2) eingesetzt werden und
viele haben Probleme mit
»<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=apachectl&amp;sektion=8">apachectl</a>
restart</tt>«; sie erzeugen einen Fehler, welcher dazu führt, dass
httpd(8) beendet wird.

<li><b>Existierende CGIs:</b> Die meisten werden NICHT ohne weiteres
eingesetzt werden können. Sie benötigen vermutlich Programme oder
Bibliotheken, die sich außerhalb von <i>/var/www</i> befinden. Einige
können durch Kompilieren statisch gelinkt werden (keine Bibliotheken
in anderen Verzeichnissen werden benötigt), die meisten werden behoben
werden können, indem im <i>/var/www</i> die Verzeichnisse mit den
benötigten Dateien der Applikation angelegt werden, wobei dies nicht
so einfach ist, wie es klingt, und daher Wissen über das Programm
benötigt.

<li><b>Mountoptionen für das Dateisystem:</b>
Standardmäßig wird unter OpenBSD deine <i>/var</i>-Partition mit den
Optionen <tt>nosuid</tt> und <tt>nodev</tt> gemountet. Wenn du eine
Applikation im Chroot ausführen möchtest, so musst du diese Optionen
eventuell ändern. Selbstverständlich kann es auch vorkommen, dass du
diese Optionen ändern musst, wenn du kein Chroot betreibst.

<li><b>Namensauflösung:</b>
httpd(8) innerhalb der chroot(2) wird NICHT in der Lage sein, die
Dateien <i>/etc/hosts</i> und <i>/etc/resolv.conf</i> des Systems zu
verwenden. Daher musst du <i>/var/www/etc/hosts</i> und/oder
<i>/var/www/etc/resolv.conf</i> in der chroot(2)-Umgebung anlegen,
wenn du Anwendungen hast, die Namensauflösung benötigen. Beachte, dass
einige Anwendungen eine funktionierende Auflösung von »localhost«
voraussetzen.

</ul>

In einigen Fällen können die Applikation oder die Konfiguration
geändert werden, damit sie im chroot(2) läuft.
In anderen Fällen wirst
du diese Funktionalität einfach unter Verwendung der Option <tt>-u</tt>
mit httpd(8) in der
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf</a></i>
abstellen.

<h3>Beispiel einer Einschließung einer Applikation in chroot(2):
wwwcount</h3>
Als ein Beispiel für die Vorgehensweise, die genutzt werden kann, um
eine Applikation in einer Chroot einzuschließen, werden wir einen Blick
auf wwwcount werfen, einem einfachen Webseitenzähler, der über die
<a href="faq15.html#PkgMgmt">Ports</a> verfügbar ist.
Obwohl dieses ein sehr effektives Programm ist, weiß es nichts über
den in chroot(2) eingeschlossenen Apache und wird in seiner
standardmäßigen Konfiguration nicht in chroot(2) funktionieren.

<p>
Zuerst werden wir das <a
href="http://www.muquit.com/muquit/software/Count/Count.html"
>wwwcount</a>-Package installieren. Wir konfigurieren und testen es und
stellen fest, dass es nicht funktionieren will und dass wir eine
Apache-Nachricht erhalten, die »Internal Server Error« sagt.

Der erste Schritt ist das Beenden und Neustarten von Apache mit der
Option <tt>-u</tt>, um sicherzustellen, dass das Problem im
chroot(2) liegt und nicht in der Systemkonfiguration.

<blockquote><pre>
# <b>apachectl stop</b>
/usr/sbin/apachectl stop: httpd stopped
# <b>httpd -u</b>
</pre></blockquote>

Hiernach sehen wir, dass der Zähler einwandfrei läuft, zumindest nachdem
wir die Dateirechte umgestellt haben, sodass Apache (und die CGIs, die
er ausführt) in die Dateien schreiben können, die gehalten werden.
Somit haben wir ganz sicher ein Problem mit chroot, sodass wir Apache
wieder beenden und neustarten können, dieses Mal wieder mit
standardmäßigem Chroot:

<blockquote><pre>
# <b>apachectl stop</b>
/usr/sbin/apachectl stop: httpd stopped
# <b>httpd</b>
</pre></blockquote>

<p>
Ein guter Anfangspunkt wäre anzunehmen, dass wwwcount einige
Bibliotheken und andere Dateien benötigt, die im chroot nicht vorliegen.
Wir können das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ldd&amp;sektion=1">ldd(1)</a>
benutzen, um alle dynamischen Objektabhängigkeiten festzustellen, die
das CGI hat:

<blockquote><pre>
# <b>cd /var/www/cgi-bin/</b>
# <b>ldd Count.cgi</b>
Count.cgi:
        Start    End      Type Ref Name
        00000000 00000000 exe   1  Count.cgi
        03791000 237ca000 rlib  1  /usr/lib/libc.so.30.3
        03db4000 03db4000 rtld  1  /usr/libexec/ld.so
</pre></blockquote>

Ok, hier ist ein Problem, zwei Dateien sind in der chroot(2)-Umgebung
nicht verfügbar. Wir kopieren sie also hinein:

<blockquote><pre>
# <b>mkdir -p /var/www/usr/lib /var/www/usr/libexec</b>
# <b>cp /usr/lib/libc.so.30.3 /var/www/usr/lib</b>
# <b>cp /usr/libexec/ld.so /var/www/usr/libexec</b>
</pre></blockquote>

und testen den Zähler wieder.

<p>
Nun ja, jetzt läuft das Programm zumindest und gibt uns Fehlermeldungen
direkt: "Unable to open config file for reading".
Fortschritt, aber wir sind noch nicht fertig.
Die Konfigurationsdatei ist normalerweise in
<tt>/var/www/wwwcount/conf</tt>, aber innerhalb der chroot-Umgebung,
wäre das <tt>/wwwcount/conf</tt>.
Unsere Möglichkeiten sind nun entweder das Neukompilieren vom Programm,
sodass es mit den Dateien arbeitet, wo sie jetzt sind, oder aber das
Verschieben der Dateien.
Da wir vom Package aus installiert haben, werden wir die Dateien
verschieben. Um die gleiche Konfig mit sowie ohne chroot(2) verwenden
zu können, benutzen wir einen symbolischen Link:

<blockquote><pre>
# <b>mkdir -p /var/www/var/www</b>
# <b>cd /var/www/var/www</b>
# <b>ln -s ../../wwwcount wwwcount</b>
</pre></blockquote>

Beachte, dass dieser symbolische Link so erstellt wurde, dass er
innerhalb vom chroot läuft. Und wir werden wieder einmal testen ...
und stellen fest, dass es noch ein Problem gibt.
Nun beschwert sich wwwcount darüber, dass es die Stripimage-Dateien,
die zum Anzeigen von Nachrichten genutzt werden, nicht finden kann.
Nach einer kurzen Suche finden wir heraus, dass sich diese unter
<tt>/usr/local/lib/wwwcount</tt> befinden, sodass wir diese ebenfalls
ins chroot kopieren müssen.

<blockquote><pre>
# <b>tar cf - /usr/local/lib/wwwcount | (cd /var/www; tar xpf - )</b>
</pre></blockquote>

wir testen wieder ... und es läuft!

<p>
Beachte, dass wir wirklich nur die Dateien kopiert haben, die absolut
notwendig sind, um das Programm ausführen zu können. Generell gilt,
dass die Mindestanzahl an Dateien in die Chroot-Umgebung kopiert
werden sollte, um das Programm ausführen zu können.

<h3>Sollte ich auf die Chroot-Funktion zurückgreifen?</h3>
Im obigen Beispiel war das Programm zwar recht einfach, doch hatten
wir unterschiedlichste Probleme, bis es lief.

<p>
<i>Nicht jede Anwendung kann oder sollte in einer Chroot(2)-Umgebung
laufen.</i>

<p>
Das Ziel ist ein sicherer Webserver. Chroot(2)ing ist nur ein Teil des
Weges, um dieses Ziel zu erreichen - und nicht das Ziel selbst. Denke
daran, dass die Standardkonfiguration von OpenBSDs Apache in chroot(2)
vorsieht, dass der Benutzer des httpd(8)-Programms keine anderen
Programme ausführen, keine Dateien verändern und auch nicht die
Identität des Benutzers ändern kann. Wenn du diese Einschränkungen
lockerst, so verringerst du die Gesamtsicherheit - mit oder ohne chroot.

<p>
Einige Applikationen sind recht einfach und chroot(2) macht für sie
Sinn. Andere sind recht komplex und sind die Anstrengungen, sie in ein
chroot zu zwingen, nicht wert, oder aber du wirst den kompletten Nutzen
der chroot(2)-Umgebung verloren haben, wenn du genügend Dateien vom
System kopiert hast. Zum Beispiel muss das Programm OpenWebMail auf das
Mailverzeichnis und auf das Heimatverzeichnis des Benutzers zugreifen
können sowie die Möglichkeit haben, Programme mit den Rechten aller
Anwender auszuführen. Ein Versuch, diese Anwendungen in eine
Chroot-Umgebung zu sperren wäre völlig sinnlos, da hiermit alle
Vorzüge einer solchen Umgebung umgangen werden. Selbst Applikationen,
die so einfach wie der zuvor beschrieben Counter sind, müssen auf die
Platte schreiben (um den Zähler zu speichern), sodass <i>einige</i>
Vorteile vom chroot(2) verloren gegangen sind.

<p>
Des Weiteren ist es nutzlos, chroot(2) für Programme umzusetzen, die
Rootrechte benötigen. Root kann generell aus einer Chroot(2)-Umgebung
ausbrechen.

<p>
Vergiss eine Sache nicht: Wenn die Einrichtung einer Chroot-Umgebung
sehr schwer war, so wirst du vielleicht der Versuchung erliegen, das
System seltener zu aktualisieren/upgraden als du solltest. Dies
wiederum würde dazu führen, dass dein System UNSICHERER ist als ein
System, das zwar auf Chroot verzichtet, dafür aber leichter zu
verwalten ist.

<a name="rootshell"></a>
<h2>10.17 - Kann ich die Rootshell ändern?</h2>
Es wird manchmal gesagt, dass man niemals die Rootshell ändern dürfte,
doch gibt es unter OpenBSD nichts, was dagegen spricht.

<p>
Die Standardshell für <i>root</i> ist unter OpenBSD
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>.

<p>
Eine geschichtliche Unix-Richtlinie ist, nur statisch kompilierte Shells
für root zu benutzen, da im Fall des Singleuser-Modus andere als die
root-Partitionen nicht gemountet werden und dynamisch gelinkte Shells
nicht auf die Bibliotheken auf der <tt>/usr</tt>-Partition zugreifen
können. Dies ist kein wirklich schlimmes Problem für OpenBSD, da das
System dich nach einer Shell fragt, wenn es im Singleuser-Modus
angekommen ist und der Standard
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>
ist.

Die drei standardmäßigen Shells unter OpenBSD
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=csh&amp;sektion=1">csh</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>)
sind alle statisch gelinkt und daher im Singleuser-Modus
einsatzfähig.


<a name="ksh"></a>
<h2>10.18 - Was kann ich noch mit <i>ksh</i> machen?</h2>
Unter OpenBSD ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>
<a href="http://web.cs.mun.ca/~michael/pdksh/">pdksh</a>, die »Public
Domain Korn Shell«, und die gleiche Binary wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>.

<p>
Anwender, die gerne <i>bash</i> benutzen, die oft unter Linux-Systemen
genutzt wird, werden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>
als recht ähnlich einschätzen. Ksh(1) bietet die meisten häufig
genutzten Funktionalitäten von <i>bash</i>, einschließlich der
Tab-Erweiterung, Kommandozeileneditierung und History über die
Pfeiltasten und STRG+A/STRG+E, um zum Anfang/Ende der Kommandozeile
zu springen. Wenn andere Funktionalitäten der <i>bash</i> benötigt
sind, kann <i>bash</i> selbst entweder über
<a href="faq15.html#PkgMgmt">Packages</a> oder
<a href="faq15.html#Ports">Ports</a> installiert werden.

<p>
Der Kommandoprompt von <i>ksh</i> kann auf einfache Weise auf etwas
informativeres geändert werden, weg vom standardmäßigen »$ «, indem die
Variable <tt>PS1</tt> gesetzt wird. Das Einfügen folgender Zeile:

<blockquote><pre>
export PS1='$PWD $ '
</pre></blockquote>

in deine <tt>/etc/profile</tt> führt beispielsweise zu folgendem
Kommandoprompt:

<blockquote><pre>
/home/nick $
</pre></blockquote>

Siehe dir die Datei
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/etc/ksh.kshrc?content-type=text/plain"><tt>/etc/ksh.kshrc</tt></a>
an, in der viele nützliche Funktionalitäten und Beispiele stehen, die
in die <tt>.profile</tt> deines Benutzers geschrieben werden können.

<p>
OpenBSDs ksh(1) wurde mit einigen ,speziellen Zeichen' für den
primären Promptstring (PS1) verbessert, sodass sie ähnlich zu denen in
bash sind. Zum Beispiel:
<blockquote>
<tt>\e - </tt>Füge eine ASCII-Escapesequenz ein.<br>
<tt>\h - </tt>Der Hostname ohne Domänenname.<br>
<tt>\H - </tt>Der gesamte Hostname, einschließlich Domänennamen.<br>
<tt>\n - </tt>Füge einen Zeilenumbruch ein.<br>
<tt>\t - </tt>Die aktuelle Zeit im 24-Stunden-Format HH:MM:SS.<br>
<tt>\u - </tt>Der Benutzername vom aktuellen Anwender.<br>
<tt>\w - </tt>Das momente Arbeitsverzeichnis.  $HOME wird als ~
dargestellt.<br>
<tt>\W - </tt>Der Basisname vom aktuellen Arbeitsverzeichnis.<br>
<tt>\$ - </tt>Gibt # für root-User und $ für alle anderen aus.
</blockquote>

(lies die Manualseite über
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh(1)</a>
für weitere Details, und noch vielen, vielen weiteren Spezialzeichen!
Beachte bitte, dass das Zeichen $ innerhalb doppelter
Anführungszeichen eine besondere Bedeutung hat. Pass also auf!)

<p>
Man könnte folgendes Kommando nutzen:
<blockquote><pre>
export PS1="\n\u@\H\n\w \\$ "
</pre></blockquote>
um einen recht ausgiebigen aber nützlichen Prompt zu bekommen.


<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq9.html">[Zum Kapitel 9 - Zu OpenBSD migrieren]</a>
<a href= "faq11.html">[Zum Kapitel 11 - Das X Window System]</a>
</font>
<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br><small>
<!--
Originally [OpenBSD: faq10.html,v 1.140 ]<br>
$Translation: faq10.html,v 1.32 2008/11/22 11:01:55 paldium Exp $<br>
-->
$OpenBSD: faq10.html,v 1.30 2008/11/26 08:25:02 tobias Exp $
</small>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Platteneinrichtung</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2008 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq13.html">[Zum Kapitel 13 - Multimedia]</a>
<a href= "faq15.html">[Zum Kapitel 15 - Packages und Ports]</a>
</font>

<h1><font color="#e00000">14 - Platteneinrichtung</font></h1><hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#disklabel"  >14.1 - Benutzung von OpenBSDs disklabel(8)</a>
<li><a href="#fdisk"      >14.2 - Benutzung von OpenBSDs fdisk(8)</a>
<li><a href="#NewDisk"    >14.3 - Hinzufügen von weiteren Festplatten unter
    OpenBSD</a>
<li><a href="#SwapFile"   >14.4 - Wie man in eine Datei swappt</a>
<li><a href="#SoftUpdates">14.5 - Softupdates</a>
<li><a href="#Boot386"    >14.6 - Wie bootet OpenBSD/i386?</a>
<li><a href="#LargeDrive" >14.7 - Welche Probleme treten bei großen
    Festplatten mit OpenBSD auf?</a>
<li><a href="#InstBoot"   >14.8 - Installieren von Bootblocks -
    i386/amd64-spezifisch</a>
<li><a href="#Backup"     >14.9 - Sich auf das Schlimmste vorbereiten:
    Backups und Wiederherstellen von Band.</a>
<li><a href="#MountImage" >14.10 - Diskimages unter OpenBSD mounten</a>
<li><a href="#pciideErr"  >14.11 - Hilfe! Ich erhalte Fehler mit
    IDE-DMA!</a>
<li><a href="#RAID"       >14.13 - RAID-Optionen unter OpenBSD</a>
<li><a href="#NegSpace"   >14.14 - Warum sagt mir <tt>df(1)</tt>, dass ich
    mehr als 100&nbsp;% von meiner Platte belegt habe?</a>
<li><a href="#OhBugger"   >14.15 - Partitionen wiederherstellen, nachdem
    das Disklabel gelöscht wurde</a>
<li><a href="#foreignfs"  >14.16 - Kann ich auf Daten zugreifen, die auf
    anderen Dateisystemen als FFS liegen?</a>
<ul>
  <li><a href="#foreignfsafter">14.16.1 - Die Partitionen befinden sich
      nicht in meinem Disklabel! Was kann ich tun?</a>
</ul>
<li><a href="#flashmem"   >14.17 - Kann ich ein Gerät mit Flashspeicher
    unter OpenBSD benutzen?</a>
<li><a href="#DiskOpt"    >14.18 - Die Festplattenleistung
    optimieren</a>
<li><a href="#Async">     >14.19 - Warum verwenden wir keine »async
    mounts«?</a>

</ul>
<hr>

<a name="disklabel"></a>
<h2>14.1 - Benutzung von OpenBSDs disklabel(8)</h2>
<a name="disklabel.1"></a>
<h3>Was ist disklabel(8)?</h3>

<p>
Lies zunächst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>-Manualseite.

<p>
Die Details wie Platten unter OpenBSD eingerichtet werden
unterscheiden sich auf den einzelnen Plattformen. Auf den Plattformen
<a href="../../de/i386.html">i386</a>,
<a href="../../amd64.html">amd64</a>,
<a href="../../de/macppc.html">macppc</a>,
<a href="../../de/zaurus.html">zaurus</a>
und <a href="../../de/armish.html">armish</a> findet die Platteneinrichtung in
zwei Phasen statt. Zuerst wird das OpenBSD-Slice unter Verwendung von
fdisk(8) auf der Festplatte definiert und dann mit disklabel(8) in
OpenBSD-Partitionen unterteilt.

<p>
Alle OpenBSD-Plattformen verwenden jedoch primär disklabel(8) für die
Verwaltung von OpenBSD-Partitionen. Plattformen, die ebenfalls fdisk(8)
einsetzen, legen alle disklabel(8)-Partitionen in einer einzelnen
fdisk-Partition an.

<p>
Labels beinhalten bestimmte Informationen über deine Festplatte; unter
anderem deine Plattengeometrie und Informationen über die Dateisysteme
auf deiner Platte. Sie beinhalten auch Informationen über deine Platte
selbst wie zum Beispiel Umdrehungsgeschwindigkeit, Interleave etc.
Diese Einträge existieren auf Grund früherer Notwendigkeiten und sind
meist nicht einmal korrekt: Mach dir also keine Gedanken darüber. Das
Disklabel wird dann vom Bootstrapprogramm genutzt, um das Laufwerk
anzusprechen und zu wissen, welche Dateisysteme sich auf dem Laufwerk
befinden. Weitere Informationen über Disklabel kannst du in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>-Manualseite
nachlesen.

<p>
Auf einigen Plattformen hilft disklabel, Architekturbegrenzungen bei
der Plattenpartitionierung zu überwinden. Zum Beispiel kann man auf
i386 nur vier primäre Partitionen anlegen;
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
benutzt eine dieser primären Partitionen, die dann *alle* deine
OpenBSD-Partitionen enthält (z.&nbsp;B. »swap«, »/«, »/usr«, »/var«
etc.) - und du hast noch drei weitere für andere Betriebssysteme übrig.

<a name="disklabel.2"></a>
<h3>disklabel(8) während der OpenBSD-Installation</h3>

<p>
Einer der Hauptteile der OpenBSD-Installation ist das erstmalige
Erzeugen der Labels. Während der Installation kannst du disklabel(8)
verwenden, um separate Partitionen zu erstellen. Als Teil des
Installationsprozesses kannst du deine Mountpunkte in disklabel(8)
definieren - im weiteren Verlauf oder auch nach der Installation kannst
du sie aber weiterhin ändern.

<p>
Obwohl es keinen »richtigen« Weg gibt, wie man ein Disklabel anlegt,
gibt es viele falsche. Bevor du versuchst, ein Label für deine Platte
anzulegen, wirf einen Blick auf <a href="faq4.html#Partitioning">diese
Diskussion</a> über das Partitionieren und Partitionsgrößen.

<p>
Um ein Beispiel für die Verwendung von disklabel(8) während der
Installation zu sehen, wirf einen Blick auf das Kapitel
<a href="faq4.html#Disks">Festplatte(n) einrichten</a>, das Teil der
<a href="faq4.html">Installationsanleitung</a> ist.


<p>

<a name="disklabel.3"></a>
<h3>disklabel(8) nach der Installation verwenden</h3>

<p>
Wenn dein System erst einmal installiert ist, solltest du disklabel
nicht mehr allzu oft benutzen müssen. Aber du kannst es gebrauchen, wenn
du z.&nbsp;B. Festplatten hinzufügen, welche entfernen oder auch einfach
umstrukturieren möchtest. Eines der ersten Dinge, die du dann machst,
ist dir den momentanen gültigen Disklabel anzusehen. Und das geht so:

<blockquote><pre>
# <b>disklabel wd0</b> &lt;-- <i>Oder ein anderes Device, das du dir anzeigen lassen möchtest</i>
# Inside MBR partition 3: type A6 start 63 size 29880837
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: Maxtor 51536H2
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 29888820
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        614817            63  4.2BSD   2048 16384  328 # Cyl     0*-   609
  b:        409248        614880    swap                   # Cyl   610 -  1015
  c:      29888820             0  unused      0     0      # Cyl     0 - 29651*
  d:       6291936       1024128  4.2BSD   2048 16384  328 # Cyl  1016 -  7257
  e:        409248       7316064  4.2BSD   2048 16384  328 # Cyl  7258 -  7663
  f:       1024128       9822960  4.2BSD   2048 16384  328 # Cyl  9745 - 10760
  h:       2097648       7725312  4.2BSD   2048 16384  328 # Cyl  7664 -  9744
</pre></blockquote>

<p>
Beachte, dass bisher nur ein Teil des zur Verfügung stehenden
Plattenspeichers zugewiesen wurde.

Mit disklabel gibt es zwei verschiedene Modi für die Editierung des
Disklabels: ein eingebauter kommandozeilenbasierter Editor (mit diesem
hast du OpenBSD ursprünglich installiert) und ein vollständiger Editor
wie beispielsweise
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vi&amp;sektion=1">vi(1)</a>.
Den eingebauten kommandozeilenbasierten Editor wirst du vermutlich als
einfacher zu bedienen empfinden, da er dich durch alle Schritte führt
und nach Bedarf weitere Hilfe ausgibt - der Vollbildeditor hat
selbstverständlich auch seine Daseinsberechtigung.

<p>
Lass uns eine Partition zum gerade gezeigten System hinzufügen.

<p>
<blockquote>
<i>Warnung: Jedes Mal wenn du dein Disklabel editierst setzt du die
gesamten Daten auf deiner Platte einer großen Gefahr aus. Stell sicher,
dass du deine Daten gesichert hast, bevor du ein bestehendes Disklabel
modifizierst!</i>
</blockquote>

<p>
Wir werden hierfür den eingebauten kommandozeilenbasierten Editor
verwenden, der mit der Option -E von disklabel(8) aufgerufen wird.

<blockquote><pre>
# <b>disklabel -E wd0</b>
...
> a k
offset: [10847088]
size: [19033812] 2g
Rounding to nearest cylinder: 4194288
FS type: [4.2BSD]
> p m
device: /dev/rwd0c
type: ESDI
disk: ESDI/IDE disk
label: Maxtor 51536H2
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total bytes: 14594.2M
free bytes: 7245.9M
rpm: 3600

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        300.2M          0.0M  4.2BSD   2048 16384  328 # Cyl     0*-   609
  b:        199.8M        300.2M    swap                   # Cyl   610 -  1015
  c:      14594.2M          0.0M  unused      0     0      # Cyl     0 - 29651*
  d:       3072.2M        500.1M  4.2BSD   2048 16384  328 # Cyl  1016 -  7257
  e:        199.8M       3572.3M  4.2BSD   2048 16384  328 # Cyl  7258 -  7663
  f:        500.1M       4796.4M  4.2BSD   2048 16384  328 # Cyl  9745 - 10760
  h:       1024.2M       3772.1M  4.2BSD   2048 16384  328 # Cyl  7664 -  9744
  k:       2048.0M       5296.4M  4.2BSD   2048 16384   16 # Cyl 10761 - 14921
> q
Write new label?: [y]
</pre></blockquote>

In diesem Fall war disklabel(8) nett und hat einen guten Startoffset
für die Partition berechnet. In den meisten Fällen wird das auch
funktionieren - falls du aber »Löcher« im Disklabel hast (d.&nbsp;h.
falls du eine Partition gelöscht hast oder dir das Leben unnötig schwer
machen willst) musst du eventuell zu Papier und Bleistift greifen und
den passenden Offset selbst ausrechnen.
Beachte, dass es gut möglich ist, dass Dinge hier fehlschlagen, obwohl
disklabel(8) einige Gültigkeitsüberprüfungen durchführt. Sei sicher,
dass du genau weißt, was die Bedeutung dieser Zahlen ist, die du gerade
eingibst.

<p>
Auf den meisten OpenBSD-Plattformen stehen sechzehn Disklabelpartitionen
zur Verfügung: von a bis p (einige »besondere« Systeme haben nur acht).
Jedes Disklabel sollte eine Partition namens c mit dem Dateisystemtyp
(fstype) »unused« aufweisen. Versuche niemals, ein Dateisystem auf c
zu erstellen. Auf dem Bootdevice ist a für die Rootpartition reserviert
und b für die Swappartition. Diese Einschränkung gilt nur für das
Bootdevice. Andere Devices können alle fünfzehn Partitionen außer c für
Dateisysteme nutzen.

<p>
<h3>Tipps und Tricks für disklabel</h3>
<ul>
<li><b>Hilfe erhalten:</b> Im kommandozeilenbasierten Modus kann man
mit Drücken von »?« eine Liste aller verfügbaren Kommandos anzeigen
lassen. »M« gibt die Manualseite von disklabel(8) aus.

<li><b>Auf Standardwerte zurücksetzen:</b> In einigen Fällen möchtest
du vielleicht komplett von vorne beginnen und alle bestehenden
Disklabelinformationen löschen. Das Kommando »D« wird das Label zurück
auf die Standardwerte setzen - als wenn noch nie ein Disklabel auf dem
Laufwerk gewesen wäre.

<li><b>Ein Disklabel duplizieren:</b> In einigen Fällen möchtest du
vielleicht die Partitionierung von einer Platte auf eine andere kopieren
- allerdings nicht 100%ig (zum Beispiel möchtest du zwar die gleichen
Partitionen haben, diese aber auf unterschiedlich großen Laufwerken).
Verwende den Modus -e (Vollbildeditor) von disklabel(8), kopiere die
Partitionen des Ausgangslaufwerks und füge die Zeilen in das neue
Laufwerk ein. Entferne dann die Partition c vom Ausgangslaufwerk und
speicher ab. Somit hast du nun das Plattenlayout auf das andere
Laufwerk kopiert, ohne die Basisparameter geändert zu haben.

<li>(sparc/sparc64) <b>Lege die Swappartition nicht am Anfang deiner
Platte an.</b>

<li>(i386, amd64) <b>Belasse die erste Spur ungenutzt:</b>
Auf einigen Plattformen muss die erste logische Spur ungenutzt
bleiben - sowohl von disklabel(8) als auch von fdisk(8). Dieser
Leitfaden wird manchmal umformuliert in »beginne mit deinen Partitionen
beim Sektor 63«, doch ist das NUR wahr, wenn es sich dabei auch um die
Größe einer Spur auf deiner Hardware handelt. Nimm niemals an, dass
das immer der Fall ist - disklabel wird dir mitteilen, wie viele Sektoren
vermutlich pro Spur vorliegen. Viele andere Plattformen gehen davon
aus, dass OpenBSD-Partitionen beim Sektor 0 beginnen.

<li><b>Devices ohne Disklabel:</b>
Falls ein Device momentan kein OpenBSD-Disklabel hat, dafür aber andere
Dateisysteme (zum Beispiel eine Platte mit zuvor angelegtem
FAT32-Dateisystem) wird der OpenBSD-Kernel ein Disklabel im Speicher
»anlegen«. Hiermit ist eine Grundlage für ein OpenBSD-Disklabel gegeben,
das dann auf die Platte geschrieben werden kann. Fall ein Disklabel
jedoch erstellt und auf die Platte geschrieben wurde und danach ein
Dateisystem angelegt wird, das nicht zu OpenBSD gehört, wird das
Disklabel nicht automatisch aktualisiert. Du musst dies manuell machen,
wenn du möchtest, dass OpenBSD auf dieses Dateisystem zugreifen kann.
Weitere Informationen hierüber befinden sich
<a href="faq14.html#foreignfsafter">weiter unten</a>.

<li><b>»q« gegen »x«:</b>
Aus historischen Gründen speichert »q« im kommandobasierten Editormodus
alle Änderungen ab und verlässt das Programm - »x« hingegen verlässt
das Programm, ohne zu speichern. Dies ist genau das Gegenteil von dem,
was viele Leute aus anderen Umgebungen gewohnt sind. Vor dem Speichern
von Änderungen warnt disklabel(8) jedoch, sodass »x« schnell und
ohne jeglichen Kommentar ausgeführt wird.

</ul>


<a name="fdisk"></a>
<h2>14.2 - Benutzung von OpenBSDs fdisk(8)</h2>

Lies zuerst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Manualseite.

<p>
Auf einigen Plattformen (i386, amd64, macppc, zaurus und armish) wird
fdisk(8) verwendet, um eine Partition zu erstellen, die vom
Boot-ROM des Systems erkannt werden kann und die Disklabelpartitionen
von OpenBSD aufnehmen wird. Andere Plattformen benötigen oder verwenden
fdisk(8) nicht. Mit fdisk(8) kann auch der Masterbootrecord (MBR)
editiert werden, wodurch alle Betriebssysteme auf einem Computer
betroffen sind. Im Gegensatz zu anderen fdisk-ähnlichen Programmen
einiger anderen Betriebssysteme nimmt OpenBSDs fdisk an, dass du weißt
was du tust, und wird dich die meiste Zeit machen lassen was du willst
- somit steht dir ein sehr mächtiges Werkzeug zur Verfügung.
Andererseits lässt es dich eben auch Dinge machen, die du entweder
nicht machen solltest oder die du auch nicht gar nicht vorhattest.
Bei der Verwendung ist also Vorsicht geboten.

<p>
Normalerweise wird nur eine fdisk-Partition für OpenBSD auf einer Platte
angelegt. Diese Partition wird dann mit
<a href="#disklabel">disklabel</a> in weitere
OpenBSD-Dateisystempartitionen aufgeteilt.

<p>


<p>
Um dir nur deine Partitionstabelle mit fdisk anzugucken, verwende:

<blockquote><pre>
# <b>fdisk sd0</b><br>
</pre></blockquote>

<p>
Was dann eine ähnliche Ausgabe wie diese hier erzeugt:

<blockquote><pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
</pre></blockquote>

<p>
In diesem Beispiel betrachten wir die Ausgabe des ersten
SCSI-Laufwerks. Wir können die OpenBSD-Partition (A6) und ihre Größe
sehen. Der * sagt uns, dass die OpenBSD-Partition eine bootbare
Partition ist.

<p>
Im vorherigen Beispiel haben wir uns die Informationen nur angesehen.
Was aber, wenn wir unsere Partitionstabelle verändern wollen? Nun, dazu
müssen wir zunächst die Option <b>-e</b> benutzen. Diese bringt uns dann
zu einer Kommandozeile, die uns mit fdisk interagieren lässt.

<blockquote><pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        swap            Swap two partition entries
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt;
</pre></blockquote>

<p>

<p>Hier ist eine Übersicht über die Kommandos, die man nach der Eingabe
der Option <b>-e</b> benutzen kann.

<ul>
<li><b>help</b>  Zeigt eine Liste der Kommandos an, die fdisk im
interaktiven Editmodus versteht.
<li><b>reinit</b>  Initialisiert die momentane im Speicher befindliche
Kopie des Bootblocks. Hiermit kannst du auf elegante und schnelle Weise
eine - die gesamte Platte in Anspruch nehmende - OpenBSD-Partition
erstellen, den Bootcode aktualisieren und - im Allgemeinen gesagt -
das System für OpenBSD vorbereiten (und nichts weiter außer OpenBSD).
<li><b>disk</b>  Zeigt die momentane Plattengeometrie an, die fdisk
ermittelt hat. Du bekommst eine Möglichkeit sie zu ändern, wenn du
willst.
<li><b>setpid</b>  Ändert eine Partitionsidentifizierung des angegebenen
Partitionstabelleneintrages. Dieses Kommando ist insbesondere nützlich,
um eine existierende Partition OpenBSD wieder zugänglich zu machen.
<li><b>edit</b>  Ändere eine ausgewählte Plattengeometrie in der Kopie
des momentanen Bootblocks.  Das geschieht entweder im
BIOS-Geometriemodus oder in Sektoroffsets und -größen.
<li><b>flag</b>  Macht den jetzigen Partitionstabelleneintrag bootbar.
Nur ein Eintrag kann gleichzeitig bootbar sein. Wenn du von einer
erweiterten Partition booten willst, musst du auch den entsprechenden
Eintrag als bootbar markieren
(OpenBSD selbst kann nur von einer primären Partition gebootet werden,
auch wenn andere Partitionen als aktiv markiert werden können).
<li><b>update</b>  Bringt den Maschinencode in der Speicherkopie des
momentanen Bootblocks auf den aktuellen Stand.
<li><b>select</b>  Wählt und lädt den Bootblock, auf den der Eintrag der
erweiterten Partitionstabelle im momentanen Bootblock zeigt.
<li><b>swap</b>  Tauscht zwei MBR-Einträge miteinander aus, sodass du
den MBR neu ordnen kannst.
<li><b>print</b>  Gibt die momentan im RAM befindliche und gewählte
Kopie des Bootblocks und seinen MBR auf dem Bildschirm aus.
<li><b>write</b>  Schreibt die RAM-Version des Bootblocks auf
die Platte. Du wirst um eine Bestätigung gebeten.
<li><b>exit</b>  Verlässt die momentane Ebene von fdisk, kehrt entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlässt
das Programm, wenn es keinen gibt.
<li><b>quit</b>  Verlässt die momentane Ebene von fdisk, kehrt entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlässt
das Programm, wenn es keinen gibt. Im Gegensatz zu exit schreibt diese
Variante den modifizierten Block auf die Platte.
<li><b>abort</b>  Verlässt das Programm ohne Änderungen zu speichern.
</ul>

<h3>Tipps und Tricks für fdisk</h3>
<ul>
<!-- <li>Auf OpenBSD-Plattformen, die fdisk verwenden, solltest du die
erste Spur ungenutzt lassen. Hiermit lässt du Platz für den
Masterbootrecord, in dem sich die fdisk-Partitionstabelle befindet
(bin mir nicht sicher, ob das wahr ist). -->
<li>fdisk(8) bietet die Möglichkeit an, die Partitionen sowohl direkt
in Sektoren als auch im Zylinder/Kopf/Sektor-Format anzugeben. Für beide
Optionen gibt es gute Gründe - einige Aufgaben werden auf die eine Weise
leichter gelöst, andere auf die andere. Beschränke dich nicht darauf,
nur eine von beiden einzusetzen.
<li>Eine völlig geleerte Platte setzt voraus, dass der Bootcode des
Masterbootrecords geschrieben werden muss, bevor von ihr gebootet werden
kann. Du möchtest den vorhandenen Bootcode eventuell sowieso erneuern
falls dir seine Herkunft unbekannt ist.
<li>Wenn dein System eine Verwaltungs- oder Diagnosepartition besitzt,
dann wird dazu geraten, diese bestehen zu lassen oder sie VOR der
Installation von OpenBSD zu installieren.
<li>Aus historischen Gründen speichert »q« Änderungen ab und verlässt
das Programme - »x« hingegen verlässt das Programme ohne zu speichern.
Dies ist genau das Gegenteil von dem, was Leute von anderen Umgebungen
her gewohnt sind. Vor dem Speichern von Änderungen fragt fdisk(8) nicht
nach - sei bei der Verwendung also sorgfältig.

</ul>


<a name="NewDisk"></a>
<h2>14.3 - Hinzufügen von weiteren Festplatten unter OpenBSD</h2>
<!-- XXX whoa. this section needs rework -->
<p>
Nun, nachdem du deine Festplatte <b>ORDNUNGSGEMÄSS</b> eingebaut hast,
musst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>nur i386 </i>) und auch
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
verwenden, um deine Festplatte unter OpenBSD benutzen zu können.

<p>
Besitzer eines i386-Systems starten mit fdisk. Besitzer anderer
Architekturen können diesen Schritt einfach ignorieren. In dem Beispiel
weiter unten werden wir dem System ein drittes SCSI-Laufwerk hinzufügen.

<blockquote><pre>
# <b>fdisk -i sd2</b>
</pre></blockquote>

Das wird die »echte« Partitionstabelle der Festplatte für eine
ausschließliche Benutzung von OpenBSD initialisieren. Als nächstes musst
du ein Disklabel dafür erzeugen. Das wird wohl etwas verwirrend wirken.

<blockquote><pre>
# <b>disklabel -e sd2</b>

<i>(der Bildschirm wird leer, dein $EDITOR erscheint)</i>
type: SCSI
<i>... Bla ...</i>
sectors/track: 63
total sectors: 6185088
<i>... Bla ...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre></blockquote>

Zunächst einmal ignoriere die Partition c - sie ist immer da und
Programme wie disklabel benötigen sie, um zu funktionieren!
Für OpenBSD ist fstype 4.2BSD. Die gesamte Größe der Festplatte ist
wird unter total sectors angegeben. Nehmen wir an, es handelt sich um
eine 3 Gigabyte große Festplatte. Drei Gigabytes in der Sprache der
Festplattenhersteller sind 3000 Megabytes. Dividiere also
6185088 mit 3000 (benutze
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1"
>bc(1)</a>.
Du erhältst 2061. Um jetzt Partitionsgrößen für a, d, e, f, g, ... zu
erstellen, rechne einfach X * 2061, um X Megabyte Platz auf dieser
Partition zu erhalten. Der Offset für deine erste Partition sollte
derselbe sein, wie unter sectors/track vorher in disklabels Ausgabe
angegeben. Bei uns ist es 63. Der Offset für jede Partition ist
hinterher eine Kombination aus der Größe und dem Offset jeder anderen
Partition (mit Ausnahme der Partition c, da sie keine Rolle in dieser
Gleichung spielt).

<p>
Wenn du aber nur eine Partition auf deiner Festplatte brauchst, zum
Beispiel, wenn du das ganze Ding nur zum Ablegen von Webseiten oder
einem Heimatverzeichnis oder etwas anderem nutzen willst, nimm einfach
die gesamte Größe der Platte und ziehe die Sektoren pro Spur davon ab:
6185088 - 63 = 6185025.  Deine Partition ist:

<blockquote><pre>
    d:  6185025       63    4.2BSD     1024  8192    16
</pre></blockquote>

<b>Wenn dir das alles unnötig komplex erscheint, kannst du disklabel -E
benutzten, um den selben Partitionierungsmodus zu erhalten, den du auf
deiner Installationsdisk hattest!</b>
Dort kannst du 96M benutzen, um 96 Megabytes anzugeben (oder 96G für 96
Gigabytes).

<p>
Das war eine Menge. Aber du bist noch nicht fertig. Zuletzt musst du
noch das Dateisystem auf der Festplatte mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
anlegen.

<blockquote><pre>
# <b>newfs sd2a </b>
</pre></blockquote>

<p>
Oder wie auch immer deine Festplatte nach dem
OpenBSD-Plattennummerierungsschema heißen mag. (Siehe einfach in der
Ausgabe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
nach, um zu sehen, wie die Platte von OpenBSD benannt wurde.)

<p>
Nun überleg dir, wohin du deine gerade neu geschaffene Partition mounten
willst. Sagen wir einfach mal /u. Erzeuge zunächst erstmal /u. Dann
mounte sie.

<blockquote><pre>
# <b>mount /dev/sd2a /u</b>
</pre></blockquote>

<p>
Zuletzt musst du sie noch zur
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
hinzufügen.

<blockquote><pre>
/dev/sd2a /u ffs rw 1 1
</pre></blockquote>

<p>
Was aber, wenn du ein existierendes Verzeichnis wie zum Beispiel
/usr/local auslagern willst? Mounte die neue Platte unter /mnt und
benutze <tt>cpio -pdum</tt>, um /usr/local in das Verzeichnis /mnt zu
kopieren. Passe die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
so an, dass die /usr/local-Partition nun /dev/wd1a ist (deine frisch
formatierte Partition). Beispiel:

<blockquote><pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre></blockquote>

<p>
Starte in den Singleuser-Modus mit <b>boot -s</b> neu, verschiebe
das existierende /usr/local nach /usr/local-backup (oder lösche es
gleich, wenn du mutig bist) und lege ein leeres Verzeichnis namens
/usr/local an. Starte dann das System neu und voila: Die Dateien sind
da!


<a name="SwapFile"></a>
<h2>14.4 - Wie man in eine Datei swappt</h2>

<p>
(Hinweis: Wenn du in eine Datei swappen willst, weil du immer
»virtual memory exhausted«-Fehler bekommst, solltest du lieber
versuchen, deine Begrenzungen auf Prozessebene mittels
cshs <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a>
oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>
zu erhöhen.)

<p>
In eine Datei zu swappen benötigt keinen angepassten Kernel, obwohl das
weiterhin gemacht werden könnte, zeigt dir diese FAQ, wie man den
Swapbereich auf beide Arten hinzufügen kann.

<h3>In eine Datei swappen.</h3>

<p>
In eine Datei zu swappen ist der einfachste und schnellste Weg, um
zusätzlichen Swap zu bekommen. Die Datei darf aber nicht auf einem
Dateisystem mit Softupdates liegen (was ja standardmäßig deaktiviert
ist). Finde zunächst einmal heraus, wie viel Swap du momentan hast
und wie viel du davon benutzt. Das geht mit dem Werkzeug
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>
recht einfach. Zum Beispiel mit diesem Aufruf:

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre></blockquote>

<p>
Das zeigt sowohl alle Geräte, die momentan für das Swappen benutzt
werden, als auch ihre momentane Statistik an. Im obigen Beispiel gibt es
nur ein Gerät namens swap_device. Das ist der vordefinierte Bereich auf
der Platte, der für das Swappen benutzt wird (wird im Übrigen als
Partition b bei Disklabels angezeigt). Wie du auch sehen kannst, wird
das Gerät zurzeit nicht sonderlich belastet oder vielmehr benutzt.
Aber für den Zweck dieses Dokumentes tun wir einfach so, als wenn noch
weitere 32 MB benötigt werden würden.

<p>
Der erste Schritt, um eine Datei als Swapbereich zu nutzen, ist die
Datei zu erzeugen. Am besten macht man das mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>.
Hier ist ein Beispiel, das die 32 M große Datei <i>/var/swap</i>
erzeugt.

<blockquote><pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></blockquote>

<p>
Nachdem das erledigt ist, können wir jetzt das Swappen auf dieses Device
richten. Benutze einfach das folgende Kommando, um das Swappen auf
dieses Device zu lenken:

<blockquote><pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre></blockquote>

<p>
Jetzt müssen wir noch prüfen, ob sie auch korrekt zu unserer Liste der
Swapdevices hinzugefügt wurde.

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></blockquote>

<p>
Jetzt, da die Datei erzeugt wurde und in sie hinein geswappt wird, musst
du noch eine Zeile in deine <i>/etc/fstab</i> hineinschreiben, so
dass die Datei beim nächsten Booten auch benutzt wird. Wenn diese Zeile
nicht hinzugefügt wird, wird dieses Swapdevice nicht konfiguriert.

<blockquote><pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre></blockquote>

<h3>Swappen über ein vnode-device</h3>

<p>
Dies ist eine dauerhaftere Lösung, um mehr Swapbereich zu erhalten.
Um in eine Datei zu swappen, erzeuge zunächst einen Kernel mit vnd0c als
Swap. Wenn du wd0a als root-Dateisystem hast und wd0b als bisherigen
Swap, benutze diese Zeile in deiner Kernelkonfigurationsdatei (wenn du
dir nicht sicher bist, siehe dir das Kapitel »Einen neuen Kernel
kompilieren« in dieser FAQ an):

<blockquote><pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre></blockquote>

<p>
Nachdem das erledigt ist, muss die Datei erzeugt werden, in die geswappt
werden soll. Du solltest dies mit dem selben Kommando wie in den
vorherigen Beispielen machen.

<blockquote><pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></blockquote>

<p>
Da deine Datei jetzt an ihrem Platz ist, musst du die Datei in deine
<i>/etc/fstab</i> eintragen. Hier ist eine Beispielzeile, mit der man
dieses Device beim Booten als Swap benutzt.

<blockquote><pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0
</pre></blockquote>

<p>
An diesem Punkt angekommen musst du deinen Computer neustarten, sodass
die Änderungen am Kernel Effekt haben. Nachdem das passiert ist, ist es
an der Zeit, das Device als Swap zu konfigurieren. Dazu wirst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>
benutzen.

<blockquote><pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre></blockquote>

<p>
Als letzten Schritt musst du den Swap auf diesem Gerät noch einschalten.
Wir machen das genau wie in dem Beispiel oben mit swapctl(8). Und zuletzt
prüfen wir wieder, ob es auch korrekt in unsere Liste der Swapdevices
eingetragen wurde.

<blockquote><pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></blockquote>


<a name="SoftUpdates"></a>
<h2>14.5 - Softupdates</h2>

<p>
Softupdates basieren auf einer Idee, die von
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg&nbsp;Ganger
und Yale&nbsp;Patt</a> vorgeschlagen wurde, und wurden für FreeBSD von
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a> entwickelt.
Softupdates erzwingen eine gewisse Reihenfolge der
Buffercacheoperationen, was die Anforderungen für das Entfernen des
FFS-Codes ermöglicht, der für das synchrone Schreiben von
Verzeichniseinträgen zuständig ist. Daher konnte ein großer
Geschwindigkeitsanwachs in der Leistung der Schreibzugriffe auf Platten
festgestellt werden.

<p>
Die Aktivierung von Softupdates muss mit einer Option während dem
Mounten ausgeführt werden. Wenn eine Partition mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
gemountet wird, kannst du angeben, dass du Softupdates auf dieser
Partition aktivieren möchtest. Dies ist ein Beispieleintrag für
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i>,
der eine Partition <i>sd0a</i> auflistet, die wir mit Softupdates
gemountet haben möchten.

<blockquote><pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre></blockquote>

<p>
Hinweis für Sparc-Anwender: Aktiviere Softupdates nicht auf sun4- oder
sun4c-Maschinen. Diese Architekturen unterstützen nur eine sehr
begrenzte Menge Kernelspeicher und können diese Funktion nicht
verwenden. Trotzdem sind sun4m-Maschinen in Ordnung.

<a name="Boot386"></a>
<h2>14.6 - Wie bootet OpenBSD/i386?</h2>
Der Bootprozess für OpenBSD/i386 ist nicht einfach und verstehen, wie es
funktioniert, kann nützlich sein, um ein Problem zu lösen, wenn Dinge
nicht laufen. Während dem Bootprozess gibt es vier Schlüsselereignisse:
<ol>
<li><b><i>Master Boot Record (MBR):</i></b> Der Master Boot Record ist
der erste physikalische Sektor (512 Byte) auf der Platte. Er beinhaltet
die primäre Partitionstabelle und ein kleines Programm, um den Partition
Boot Record (PBR) zu laden. Bedenke, dass in einigen Umgebungen der
Begriff MBR verwendet wird, um nur auf den Codeteil dieses ersten Blocks
auf der Platte zu verweisen, statt auf den gesamten ersten Block
(einschließlich der Partitionstabelle). Es ist äußerst wichtig, die
Bedeutung von »initialize the MBR« zu verstehen - in der Terminologie
von OpenBSD würde es den gesamten MBR-Sektor neu schreiben, nicht nur
den Code, so wie es auf anderen Systemen der Fall sein könnte. Du wirst
das nur selten machen wollen. Verwende stattdessen fdisk(8)s
Kommandozeilenoption -u (»<tt>fdisk -u wd0</tt>«).

<p>
Obwohl OpenBSD einen MBR beinhaltet, wirst du nicht gezwungen, ihn zu
verwenden, da so gut wie jeder MBR OpenBSD booten kann. Der MBR wird von
dem Programm fdisk(8) verändert, welches verwendet wird, um die
Partitionstabelle zu editieren und um ebenfalls den MBR-Code auf die
Platte zu schreiben.

<p>
OpenBSDs MBR kündigt sich selbst mit der Meldung an:

<blockquote><pre>
Using drive 0, partition 3.
</pre></blockquote>

die die Platte und Partition anzeigt, von der er den PBR laden wird.
Zusätzlich zu dem Offensichtlichen, zeigt er ebenfalls einen angehängten
Punkt ("."), welcher darauf deutet, dass diese Maschine in der Lage ist,
LBA-Übersetzung zum Booten zu verwenden. Wenn die Maschine nicht in der
Lage ist, LBA-Übersetzung zu verwenden, wäre der obige Punkt mit einem
Semikolon (»;«) ausgewechselt worden, das auf CHS-Übersetzung deutet:

<blockquote><pre>
Using Drive 0, Partition 3;
</pre></blockquote>

Bedenke, dass der angehängte Punkt oder das angehängte Semikolon als ein
Indikator für den neuen OpenBSD-MBR angesehen werden kann, der mit
OpenBSD 3.5 eingeführt wurde.

<li><b><i>Partition Boot Record (PBR):</i></b>
Der Partition Boot Record, auch der PBR oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
genannt wird (benannt nach dem Namen der Datei, der den Code
beinhaltet), ist der erste physikalische Sektor der OpenBSD-Partition
auf der Platte. Der PBR ist der Firststage-Bootloader für OpenBSD.
Er wird vom MBR-Code geladen und hat die Aufgabe, OpenBSDs
Secondstage-Bootloader
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
zu laden.
Wie der MBR ist auch der PBR eine sehr kleine Sektion von Code und Daten
- insgesamt nur 512 Byte. Das ist nicht genug, um eine vollständig
dateisystembewusste Applikation zu laden, sodass, statt den PBR
<tt>/boot</tt> auf der Platte ausfindig machen zu lassen, die
BIOS-verfügbare Stelle von <tt>/boot</tt> physikalisch in den PBR
während der Installation eingetragen wird.

<p>
Der PBR wird von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot(8)</a>
installiert, das
<a href="faq14.html#InstBoot">später in diesem Dokument</a> genauer
beschrieben wird.
Der PBR kündigt sich selbst mit der Meldung an:
<blockquote><pre>
Loading...
</pre></blockquote>
die einen Punkt für jeden Dateisystemblock anzeigt, den er versucht
auszulesen. Ebenfalls zeigt der PBR an, ob er LBA oder CHS zum Laden
verwendet - wenn er CHS-Übersetzung verwendet, zeigt er eine Nachricht
mit einem Semikolon an:
<blockquote><pre>
Loading;...
</pre></blockquote>
Das ältere (vor v3.5) biosboot(8) zeigte die Nachricht »<tt>reading
boot...</tt>« an.

<li><b><i>Secondstage-Bootloader, <tt>/boot</tt>:</i></b> <tt>/boot</tt>
wird vom PBR geladen und hat die Aufgabe, auf das OpenBSD-Dateisystem
durch das BIOS der Maschine zuzugreifen und den aktuellen Kernel
ausfindig zu machen und zu laden. boot(8) übergibt ebenfalls
verschiedene Optionen und Informationen an den Kernel.
<p>
boot(8) ist ein interaktives Programm. Nachdem es geladen ist versucht
es, <tt>/etc/boot.conf</tt> ausfindig zu machen und zu laden, wenn sie
existiert (was auf einer standardmäßigen Installation nicht der Fall
sein muss) und verarbeitet sämtliche Kommandos in ihr. Wenn es durch
<tt>/etc/boot.conf</tt> nicht anders angeordnet wurde, gibt es dem
Benutzer einen Prompt aus:

<blockquote><pre>
probing: pc0 com0 com1 apm mem[636k 190M a20=on]
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 2.10
boot>
</pre></blockquote>

Es gibt dem Benutzer (standardmäßig) fünf Sekunden lang die Möglichkeit,
andere Aufgaben auszuführen, aber wenn keine vor dem Ablauf der Zeit
eingegeben wurde, startet es sein normales Verhalten: Den Kernel
<tt>bsd</tt> von der root-Partition der ersten Festplatte laden.
Der Secondstage-Bootloader untersucht deine Systemhardware durch das
BIOS (da der OpenBSD-Kernel noch nicht geladen ist). Oben kannst du ein
paar Dinge sehen, die er gesucht und gefunden hat:
<ul>
<li><b>pc0</b> - Die Standardtastatur und -bildschirmausgabe eines
i386-Systems.
<li><b>com0, com1</b> - Zwei serielle Schnittstellen
<li><b>apm</b> - »Advanced Power Management«-BIOS-Funktionen
<li><b>636k 190M</b> - Die Menge des herkömmlichen (unterhalb von 1 M)
und erweiterten (oberhalb von 1 M) Speichers, den er gefunden hat
<li><b>fd0 hd0+</b> - Die BIOS-Laufwerke, die er gefunden hat: in diesem
Fall ein Disketten- und ein Festplattenlaufwerk.
</ul>

Das »+«-Zeichen nach hd0 zeigt an, dass das BIOS <tt>/boot</tt>
mitgeteilt hat, dass diese Festplatte über LBA angesprochen werden kann.
Wenn eine erstmalige Installation ausgeführt wird, siehst du ab und zu
einen * nach einer Festplatte - dies deutet auf eine Platte hin, die so
scheint, als wenn sie kein OpenBSD-Disklabel beinhaltet.

<li><b><i>Kernel: <tt>/bsd</tt></i>:</b> Dies ist das Ziel des
Bootprozesses: Den OpenBSD Kernel in den RAM laden und sauber
auszuführen.  Wenn der Kernel einmal geladen wurde, kann OpenBSD direkt
auf die Hardware zugreifen, nicht mehr durch das BIOS.

</ol>

So, der Anfang vom Start des Bootprozesses könnte wie folgt aussehen:

<blockquote><pre>
Using drive 0, partition 3.                      <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 2.10
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2008 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 4.4 (GENERIC) #1021: Tue Aug 12 17:16:55 MDT 2008
    deraadt@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC
   ...
</pre></blockquote>


<h3>Was fehlschlagen kann</h3>
<ul>
<li><b>Beschädigter/ungültiger/inkompatibler MBR:</b>
Normalerweise hat eine gebrauchte Festplatte irgendeinen MBR-Code
installiert, aber wenn die Platte neu ist oder von einer anderen
Plattform übernommen wurde UND du nicht mit Yes auf die Frage »Use
entire disk« Frage vom
<a href="faq4.html#Disks">Installationsprozess</a> geantwortet hast,
kann es sein, dass du mit einer Platte ohne gültigem MBR da stehst und
daher nicht in der Lage sein wirst zu booten, obwohl sie eine gültige
Partitionstabelle hat.

<p>
Du kannst den OpenBSD-MBR auf deine Festplatte unter Verwendung vom
Programm fdisk installieren. Boote dein Installationsmedium und wähle
Shell aus, um auf den Kommandoprompt zu gelangen:

<blockquote><pre>
# <b>fdisk -u wd0</b>
</pre></blockquote>

Du kannst auch einen bestimmten MBR auf deine Platte mit fdisk
schreiben:
<blockquote><pre>
# <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre></blockquote>

Hiermit wird die Datei <tt>/usr/mdec/mbr</tt> als dein System-MBR
installiert. Diese bestimmte Datei einer standardmäßigen
OpenBSD-Installation ist ebenfalls der standardmäßige MBR, der in
fdisk integriert wurde. Es könnte aber jeder andere MBR hier angegeben
werden.

<li><b>Ungültige <tt>/boot</tt>-Ortsangabe im PBR installiert:</b>
Wenn installboot(8) den Partition Boot Record installiert, schreibt er
die Blocknummer und den Offset von <tt>/boot</tt>s Inode in den PBR.
Daher wird das Löschen oder Ersetzen von <tt>/boot</tt> ohne
erneutes Ausführen von <a href="faq14.html#InstBoot">installboot(8)</a>
dein System in einen Zustand versetzen, in dem es nicht mehr booten
kann, da der PBR laden wird, auf was auch immer die Inode zeigt, die
angegeben wurde. Das wird vermutlich nicht mehr der erhoffte
Secondstage-Bootloader sein!

Seit <tt>/boot</tt> unter Verwendung von BIOS-Aufrufen ausgelesen wird,
waren ältere Versionen vom PBR sehr sensibel auf
BIOS-Plattenübersetzungen. Wenn du die Plattengeometrie (z.&nbsp;B.
wenn du die Platte aus einem Computer genommen hast, der
CHS-Übersetzung verwendet hat, und es in einen steckst, der
LBA-Übersetzung verwendet oder sogar die Übersetzungsoption im BIOS
geändert hast) geändert hast, wird es <i>für das BIOS so wirken</i>, als
wenn sie an einem anderen Ort liegen würde (es muss auf einen anderen
nummerischen Block zugegriffen werden, um die gleichen Daten von der
Platte zu erhalten), sodass du installboot(8) erneut ausführen musst,
bevor das System neugestartet werden kann. Der neue (von OpenBSD 3.5 und
später) PBR ist sehr viel toleranter im Bezug auf Übersetzungsänderungen.
</ul>

Da der PBR sehr klein ist, ist die Anzahl der Fehlermeldungen sehr
begrenzt und recht kryptisch. Typische Nachrichten sind:

<ul>
<li><b>ERR R</b> - Das BIOS gab einen Fehler zurück als es versucht hat,
einen Block von der Platte zu lesen.
Es bedeutet meistens genau das, was es aussagt: Von deiner Platte konnte
nicht gelesen werden.
<li><b>ERR M</b> - Eine ungültige
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>-Nummer
wurde aus dem Header des Secondstage-Bootloaders gelesen. Dies bedeutet
normalerweise, dass, was auch immer eingelesen wurde, NICHT
<tt>/boot</tt> war, was darauf hinweist, dass installboot(8) nicht
korrekt ausgeführt wurde, die /boot-Datei geändert wurde oder du die
Fähigkeit deines BIOS erschöpft hast, um von einer
<a href="#LargeDrive">großen Platte</a> zu lesen.

</ul>
Andere Fehlermeldungen werden in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386"
>biosboot(8)</a>-Manualseite ausführlich besprochen.

<p>
Für weitere Informationen über den i386-Bootprozess, siehe:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.htm">http://www.ata-atapi.com/hiw.htm</a>
  Hale Landis' »How it Works«-Dokumente.
</ul>

<a name="LargeDrive"></a>
<h2>14.7 - Welche Probleme treten bei großen Festplatten mit OpenBSD
auf?</h2>

<p>
OpenBSD unterstützt sowohl FFS- als auch FFS2- (ebenfalls bekannt als
UFS und UFS2) Dateisysteme. FFS ist das historische OpenBSD-Dateisystem,
FFS2 seit Version 4.3 verfügbar. Bevor die speziellen Grenzen der
jeweiligen Systeme betrachtet werden, müssen wir zuerst auf ein paar
generelle Systemeinschränkungen eingehen.

<p>
Selbstverständlich sind die Fähigkeit eines Dateisystems und die
Fähigkeit einer bestimmten Hardware zwei unterschiedliche Dinge.
Eine neue 250 G große IDE-Festplatte kann unter Umständen nicht mit
älteren (vor >137G-Standard) Interfaces funktionieren (obwohl sie
meistens einwandfrei arbeiten) und einige sehr alte SCSI-Adapter sind
bekannt dafür, dass sie Probleme mit moderneren Laufwerken haben und
einige alte BIOSe werden hängen, wenn sie einer modern bestückten
Festplatte begegnen. Du musst die Fähigkeiten deiner Hardware
respektieren.

<h3>Partitionsgröße und Lokalitätsbegrenzungen</h3>
Leider ist die volle Funktionalität des OS nicht verfügbar, bis
NACHDEM das OS in den Speicher geladen wurde. Der Bootprozess verwendet
(und ist daher auch darauf beschränkt) die Boot-ROM des Systems.

<p>
Aus diesem Grund muss die /bsd-Datei (der Kernel) innerhalb des vom
Boot-ROM adressierbarem Bereich liegen. Das bedeutet für einige ältere
i386-Systeme, dass die root-Partition vollständig innerhalb der ersten
504 M liegen muss, aber neuere Computer können diese Grenze bei 2 G,
8 G, 32 G, 128 G oder mehr haben. Es ist ebenfalls sinnvoll zu erwähnen,
dass viele relativ neue Computer, die Laufwerke mit mehr als 128 G
Speicher unterstützen tatsächlich eine BIOS-Begrenzung für die ersten
128 G für das Booten haben. Du kannst diese Systeme mit großen
Laufwerken betreiben, aber deine root-Partition muss in dem Bereich
liegen, der vom Boot-ROM unterstützt wird.

<p>
Bedenke, dass es möglich ist, ein 40 G großes Laufwerk in einen alten
486er einzubauen und auf diesem OpenBSD mit einer großen Partition zu
installieren und zu denken, dass du erfolgreich die vorherige Regel
gebrochen hast. Trotzdem kann es dich auf einem höchst unangenehmen Weg
verfolgen:

<ul>
 <li>Du installiert eine 40 G /-Partition. Es funktioniert, da das
 Basis-OS und alle seine Dateien (einschließlich /bsd) innerhalb der
 ersten 504 M liegen.
 <li>Du benutzt das System und endest mit mehr als 504 M Dateien auf
 ihm.
 <li>Du aktualisiert und erstellst deinen eigenen Kernel, was auch
 immer, und kopierst deinen neuen /bsd über den alten.
 <li>Du startest neu.
 <li>Du bekommst eine Meldung wie »ERR M« oder andere Probleme während
 dem Booten.
</ul>
<p>
Warum? Weil, wenn du eine neue /bsd-Datei »über« die alte kopierst,
überschreibt sie nicht die alte - ihr wird einem neuen Ort auf der Platte
zugewiesen, möglicherweise außerhalb der 504-M-Grenze, die das
BIOS hat. Der Bootloader wird nun nicht mehr in der Lage sein, die
/bsd-Datei zu erhalten und das System hängt.

<p>
Um OpenBSD zum Booten zu bringen, müssen die Bootloader (biosboot(8) und
<tt>/boot</tt> im Falle von i386/amd64) und der Kernel (<tt>/bsd</tt>)
innerhalb des Bereiches sein, den die Boot-ROM unterstützt und
innerhalb ihrer eigenen Fähigkeiten. Um sicher zu gehen, ist die Regel
einfach:

<p>
<b>Die gesamte root-Partition muss innerhalb des BIOS (oder Boot-ROM)
vom Computer adressierbaren Speicher liegen.</b>

<p>
Einige Nicht-i386-Anwender denken, dass sie dies nicht betrifft, jedoch
haben die meisten Plattformen eine Art Begrenzung des ROMs bezüglich der
Plattengröße. Herauszufinden, wie groß diese Begrenzung denn nun
tatsächlich ist, kann schwer sein.

<p>
Dies ist ein weiterer guter Grund <a href="faq4.html#Partitioning">deine
Festplatte zu partitionieren</a>, statt nur eine große Partition zu
verwenden.

<h3>Zeit- und Speicheranforderungen von fsck(8)</h3>
Eine weitere Überlegung mit großen Dateisystemen ist die Zeit und der
Speicher, die benötigt werden, um as Dateisystem nach einem Crash oder
einer Stromunterbrechung einem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
zu unterziehen.
Man sollte nicht ein 120 G großes Dateisystem auf ein System mit 32 M
RAM setzen und erwarten, dass es fsck(1) erfolgreich nach einem Crash
ausführt. Eine grobe Richtlinie ist, dass das System zumindest 1 M
Arbeitsspeicher für jedes 1 G des Plattenspeichers haben sollte, um
erfolgreich fsck gegen die Platte auszuführen. Zu diesem Zeitpunkt
kann zwar geswappt werden, doch wird dies mit einem großen
Geschwindigkeitseinbruch geschehen. In den meisten Fällen ist daher
davon abzuraten - es sei denn es gibt spezielle Gründe dafür.

<p>
Die benötigte Zeit, um fsck gegen ein Laufwerk auszuführen kann ein
Problem werden, sobald das Dateisystem an Größe gewinnt. Du musst fsck
aber nur auf den Plattenspeicher anwenden, der tatsächlich zu
gemounteten Dateisystemen gehört. Dies ist ein weiterer Grund, NICHT
sofort deinen gesamten Plattenbereich zu allokieren, nur weil er
vorhanden ist. Dateisysteme nur lesend oder gar nicht gemountet zu
haben hilft dabei, sie beim nächsten Stolpern über das Stromkabel
keinem erneuten fsck(8) zu unterziehen.

<p>
Falls du mehrere Platten in deinem System hast denke bitte daran, dass
nach einem Absturz alle Platten gleichzeitig mit fsck(8) überprüft
werden, sodass deutlich mehr RAM pro Platte benötigt wird.

<p>
Wenn man eines Tages Dateisysteme mit etwas mehr als 1&nbsp;TB unter
Verwendung von Standardfragment- und Blockgrößen hat, wird fsck
1&nbsp;GB RAM benötigen; das ist das Applikationslimit unter OpenBSD.
Größere Fragmente und/oder Blöcke werden die Anzahl Inodes verringern
und größere Dateisysteme ermöglichen.

<h3>FFS gegen FFS2</h3>
Mit FFS unterstützt OpenBSD ein individuelles Dateisysteme von bis zu
2<sup>31</sup>-1 oder 2.147.483.647 Sektoren. Jeder dieser Sektoren ist
512 Byte groß, womit man ein kleines bisschen unter 1&nbsp;T liegt.
FFS2 ist in der Lage, deutlich größere Dateisysteme zu unterstützen,
obwohl andere Grenzen längst erreicht sind, bevor das Dateisystem voll
ausgereizt ist.

<p>
Der Boot-/Installationskernel <i>unterstützt nur FFS</i> (kein FFS2),
sodass wichtige Systempartitionen (<tt>/, /usr, /var, /tmp</tt>) nicht
mit FFS2 formatiert werden sollten, da ansonsten Wartungsprobleme
auftreten könnten (es sollte ohnehin keinen Grund geben, warum diese
Partitionen so riesig sein sollten). Deshalb sollten sehr große
Partitionen nur für Partitionen wie <tt>/home, /var/www, /bigarray</tt>
etc. genutzt werden, die nicht entscheidend für das System sind.

<p>
Bevor du Upgrades durchführst, setze alle FFS2-Partitionen auf »noauto«,
damit der Installationskernel sie nicht (miss)handelt (der eben keine
FFS2-Partitionen unterstützt).

<p>
Beachte, dass nicht alle Controller und Laufwerke große Platten
unterstützten. <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ami&amp;sektion=4"
>ami(4)</a> zum Beispiel unterstützt maximal 2&nbsp;TB pro logischem
Volumen. Viele wurden bisher einfach noch nicht getestet. Zu dem
Zeitpunkt, als dieser Text verfasst wurde, standen noch keine IDE- oder
SATA-Laufwerke mit eine Speicherkapazität über 1&nbsp;TB für Tests
bereit, sodass wir nicht sicher sagen können, ob alles perfekt läuft.

<a name="InstBoot"></a>
<h2>14.8 - Installieren von Bootblocks - i386/amd64-spezifisch</h2>

<p>
Aktuelle Versionen von OpenBSD (3.5 und später) verfügen über einen
sehr robusten Bootloader, der mit den unterschiedlichen
Plattengeometrien besser umgehen kann als der frühere Bootloader.
Allerdings sind beide empfindlich gegenüber der Position von
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>/boot</a></tt> auf der Festplatte. Falls du Änderungen durchführst,
die boot(8) auf der Platte verschieben (tatsächlich oder nur eine neue
I-Node), so wirst du dein System »beschädigen« - es wird nicht mehr
hochfahren. Um den Bootblock zu reparieren, damit du wieder normal
booten kannst, lege einfach eine Bootdiskette in dein Diskettenlaufwerk
ein und gib am Bootprompt »b hd0a:/bsd« ein, um ihn zu zwingen, von der
ersten Festplatte zu booten (und nicht von der Diskette). Deine Maschine
sollte normal booten.
Nun musst du den Firststage-Bootloader
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386"
>biosboot(8)</a>) basierend auf der neuen Position von <tt>/boot</tt>
erneut installieren, indem du das Programm
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386"
>installboot(8)</a> aufrufst.

<p>
In unserem Beispiel gehen wird davon aus, dass du von sd0
bootest (für IDE wäre es wd0 etc.).

<blockquote><pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre></blockquote>

<p>
Wenn eine neuere Version des Bootblocks benötigt wird, wirst du diese
selber kompilieren müssen. Und das geht so:

<blockquote><pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (oder wie deine Festplatte auch immer heißen mag)
</pre></blockquote>

<a name="Backup"></a>
<h2>14.9 - Sich auf das Schlimmste vorbereiten: Backups und
Wiederherstellen von Band.</h2>

<h3>Einführung:</h3>

<p>
Wenn du so etwas wie einen Produktionsserver laufen lassen willst, ist
es ratsam, irgendeine Form des Backups für den Fall zu haben, dass eine
deiner Festplatten versagt oder einen Crash hat.

<p>
Diese Information wird dir helfen, die Standardwerkzeuge
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
zu benutzen, die als Teil von OpenBSD ausgeliefert werden. Ein
fortgeschritteneres Werkzeug ist
<a href="http://www.amanda.org">Amanda</a>, das über
<a href="faq15.html#PkgMgmt">Packages</a> verfügbar ist und auch mehrere
Server auf ein Bandlaufwerk sichern kann. In den meisten Umgebungen sind
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
aber ausreichend. Wenn du aber mehrere Maschinen sichern willst,
ist Amanda auf jeden Fall einen Blick wert.

<p>
Die Beispiele in diesem Dokument benutzen sowohl SCSI-Festplatten als
auch Bänder. In einer Produktionsumgebung empfehlen wir SCSI und kein
IDE wegen der Art und Weise, wie IDE mit Badblocks umgeht. Das heißt
aber nicht, dass diese Informationen nutzlos sind, wenn du IDE benutzt,
sondern einzig deine Gerätenamen werden sich leicht unterscheiden. Zum
Beispiel wäre sd0a in einem IDE-basierten System wd0a.

<h3>Backup aufs Band bringen:</h3>

<p>
Um sein Backup auf ein Band zu bringen, muss man wissen, wo die
Dateisysteme gemountet sind. Das findet man mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)"</a>-Kommando
am Shellprompt heraus. Dabei sollte eine Ausgabe wie diese
herauskommen:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
In diesem Beispiel ist das root-Dateisystem (/) physikalisch auf sd0a -
also auf der SCSI-Festplatte 0, Partition a. Das /usr-Dateisystem
befindet sich auf sd0h - also SCSI-Festplatte 0, Partition h.

<p>
Ein weiteres Beispiel einer etwas größeren Mounttabelle könnte so
aussehen:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
In diesem fortgeschritteneren Beispiel befindet sich das root- (/)
Dateisystem auf sd0a. Das /var-Dateisystem befindet sich auf sd0d, das
/home-Dateisystem auf sd0e und schlussendlich /usr auf sd0h.

<p>
Um ein Backup deiner Maschine zu machen, musst du dump mit jeder
festgelegten Partition füttern. Hier ist ein Beispiel der Kommandos, um
die einfachere Mounttabelle weiter oben zu sichern:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Für die etwas fortgeschrittenere Mounttabelle würde man etwas wie das
hier benutzen:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Du kannst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>-Manualseite
ansehen, um genau zu erfahren, was jede Kommandozeilenoption macht. Hier
ist eine kurze Übersicht der Parameter, die oben verwendet wurden:

<ul>
<li><b>0</b> - Führe einen Level-0-Dump durch - hole alles
<li><b>a</b> - Versuche automatisch die Bandlänge herauszufinden
<li><b>u</b> - Bringe die Datei /etc/dumpdates auf den neuesten Stand,
um zu reflektieren, wann die letzte Sicherung gemacht wurde
<li><b>f</b> - Welches Bandlaufwerk benutzt werden soll (/dev/nrst0 in
diesem Fall)
</ul>

<p>
Zuletzt welche Partition gesichert werden soll (/dev/rsd0a usw.)

<p>
Das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
wird am Ende benutzt, um das Band zurückzuspulen. Sieh dir die
mt-Manualseite an, wenn du mehr Informationen haben willst (wie etwa
eject).

<p>
Wenn du dir nicht sicher bist, wie dein Bandlaufwerk heißt, benutze
einfach dmesg, um das herauszufinden. Ein Beispieleintrag von dmesg für
ein Bandlaufwerk könnte so aussehen:

<blockquote><pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre></blockquote>

<p>
Du hast vielleicht bemerkt, dass bei der Sicherung das Bandlaufwerk als
<tt>nrst0</tt> anstatt von <tt>st0</tt> bezeichnet wird, wie man es
in dmesg sieht. Wenn du auf <tt>st0</tt> statt <tt>nrst0</tt> zugreifst,
benutzt du das selbe physikalische Gerät, sagst ihm aber, dass es nicht
zurückspulen soll, nachdem der Job im raw-Modus beendet wurde. Um
mehrere Dateien auf ein einziges Band zu sichern, stelle sicher, dass du
nicht zurückspulst - sprich das richtige Gerät (<tt>rst0</tt>) benutzt -
ansonsten wirst du mit der zweiten Sicherung die erste überschreiben
usw. Du findest in der Manualseite zu dump eine ausführlichere
Beschreibung.

<p>
Wenn du ein kleines Skript namens backup schreiben würdest, könnte es
z.&nbsp;B. so aussehen:

<blockquote><pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre></blockquote>

<p>
Wenn regelmäßige nächtliche Backups gefordert sind, könnte man
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
benutzen, um das Backup jede Nacht automatisch zu starten.

<p>
Es ist außerdem hilfreich, auf einem Blatt Papier aufzuschreiben, wie
groß jedes Dateisystem sein muss. Du kannst »<tt>df -h</tt>« benutzen,
um herauszufinden, wie viel Platz jede Partition momentan verbraucht. Das
ist dann nützlich, wenn eine Platte versagt und du die Partitionstabelle
auf der neuen Platte wieder erstellen musst.

<p>
Deine Daten wiederherzustellen hilft außerdem noch gegen Fragmentierung.
Der beste Weg, um sicherzustellen, dass du alle Dateien erwischst, ist
es, im Singleuser-Modus zu booten. Dateisysteme müssen nicht gemountet
werden, um gesichert zu werden. Vergiss aber nicht, root (/) zu mounten,
denn sonst wird dein dump versagen, wenn er versucht, Dumpdaten zu
schreiben. Gib einfach »<tt>bsd -s</tt>« am boot&gt;-Prompt ein, um in
den Singleuser-Modus zu gelangen.

<h3>Den Inhalt eines dump-Bandes ansehen:</h3>


<p>
Nachdem du deine Dateisysteme zum ersten Mal gesichert hast, ist es
sicher eine gute Idee, dein Band zu testen und sicherzustellen, dass es
auch die Daten enthält, die darauf sein sollen.

<p>
Du kannst den folgenden Befehl benutzen, um eine Auflistung der Dateien
auf einem dump-Band zu erhalten:

<blockquote><pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre></blockquote>

<p>
Das listet die Dateien auf der 1. Partition des dump-Bandes (des
Sicherungsbands) auf. Wie in den Beispielen weiter oben ist 1 dein root-
(/) Dateisystem.

<p>
Um den Inhalt der 2. Partition zu sehen und die Ausgabe in eine Datei
umzulenken, würde man z.&nbsp;B. solch ein Kommando benutzen:

<blockquote><pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre></blockquote>

<p>
Wenn du eine Mounttabelle wie die oben aufgeführte hättest, wäre 2 /usr
- wenn deine aber etwas größer wäre, könnte 2 auch /var sein oder
irgendwas anderes. Die Sequenznummer unterliegt auf jeden Fall der
gleichen Reihenfolge, mit der das Dateisystem auf das Band gesichert
wurde.


<h3>Wiederherstellen vom Band:</h3>

<p>
Das Beispielszenario wäre sinnvoll, wenn deine eigentliche Festplatte
komplett ausgefallen wäre. Falls du aber nur eine einzige Datei
wiederherstellen willst, sieh dir die restore-Manualseite genau an und
achte besonders auf die Anweisungen für den interaktiven Modus.

<p>
Wenn du gut vorbereitet bist, kann der Prozess des Ersetzens einer
Festplatte sehr schnell von statten gehen. Die normale
OpenBSD-Installations/Bootdiskette enthält bereits das benötigte
restore-Werkzeug genauso wie die ausführbaren Dateien, um neue
Partitionen zu erstellen und deine Festplatte bootbar zu machen. In
den meisten Fällen sind diese Disketten und dein Sicherungsband alles,
was du brauchst, um wieder alles betriebsbereit zu bekommen.

<p>
Nachdem du das kaputte Laufwerk physikalisch ersetzt hast, sind die
grundlegenden Schritte zur Wiederherstellung folgende:

<ul>
<li>
<p>
Boote von der OpenBSD-Installations/Bootdiskette. Wähle Shell aus dem
Menü aus. Nimm dein neuestes und schreibgeschütztes Band und lege es in
dein Laufwerk ein.
<br>
<li>
<p>
Benutze das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Kommando,
um eine primäre OpenBSD-Partition auf dieser neu installierten
Festplatte zu erzeugen. Beispiel:

<blockquote><pre>
# <b>fdisk -e sd0</b>
</pre></blockquote>

<p>
Sieh einfach in die <a href="#fdisk">fdisk-FAQ</a>, um genaueres zu
erfahren.

<li>
<p>
Mit dem disklabel-Kommando stellst du dann deine
OpenBSD-Partitionstabelle in der primären OpenBSD-Partition wieder her,
die du gerade mit fdisk erzeugt hast. Beispiel:

<blockquote><pre>
# <b>disklabel -E sd0</b>
</pre></blockquote>

<p>
(Vergiss den Swap nicht; siehe dazu die
<a href="#disklabel">disklabel-FAQ</a> für weitere Informationen)

<li>
<p>
Benutze das newfs-Kommando, um ein neues sauberes Dateisystem auf jeder
Partition zu erstellen, die du mit den oben aufgeführten Schritten
erstellt hast. Beispiel:

<blockquote><pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre></blockquote>

<li>
<p>
Mounte dein neu vorbereitetes root- (/) Dateisystem auf /mnt. Beispiel:

<blockquote><pre>
# <b>mount /dev/sd0a /mnt</b>
</pre></blockquote>

<li>
<p>
Wechsel in das gemountete root-Dateisystem und beginne mit dem
Wiederherstellungsprozess. Beispiel:

<blockquote><pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre></blockquote>

<li>
<p>
Wenn die Platte bootbar sein soll, schreibe mit dem folgenden Befehl
einen neuen MBR auf deine Festplatte. Beispiel:

<blockquote><pre>
# <b>fdisk -i sd0</b>
</pre></blockquote>

<li>
<p>
Zusätzlich zum Schreiben eines neuen MBR musst du Bootblöcke
installieren, um von ihr booten zu können. Das Folgende ist ein
kurzes Beispiel:

<blockquote><pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre></blockquote>

<li>
<p>
Dein neues root-Dateisystem auf der eingebauten Festplatte sollte jetzt
fertig sein, sodass du davon booten und damit beginnen kannst, den Rest
der Dateien wiederherzustellen. Da dein Betriebssystem noch nicht
komplett ist, solltest du alles im Singleuser-Modus wiederherstellen.
Benutze die folgenden Kommandos am Shellprompt, um deine Festplatten
zu unmounten und das System anzuhalten:

<blockquote><pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre></blockquote>

<li>
<p>
Entferne die Installations/Bootdiskette aus dem Laufwerk und starte
dein System neu. Benutze das folgende Kommando am
OpenBSD-boot&gt;-Prompt:

<blockquote><pre>
boot&gt; <b>bsd -s</b>
</pre></blockquote>

<p>
Das bsd -s führt dazu, dass der Kernel im Singleuser-Modus gestartet
wird, der nur ein root- (/) Dateisystem braucht.

<li>
<p>
Unter der Annahme, dass du die obigen Schritte richtig ausgeführt hast
und nichts schief gegangen ist, solltest du von einem Prompt begrüßt
werden, der dich nach einem Pfad zu einer Shell fragt, oder du Return
drücken sollst. Drücke Return, um die sh zu benutzen. Als nächstes
willst du sicherlich root im Lese/Schreibmodus (rw) remounten und nicht
mehr im schreibgeschützten Modus benutzen (ro). Dazu benutze
Folgendes:

<blockquote><pre>
# <b>mount -u -w /</b>
</pre></blockquote>

<li>
<p>
Sobald du im Lese/Schreibmodus remountet hast kannst du fortfahren,
deine restlichen Dateisysteme wiederherzustellen. Beispiel:

<blockquote><pre>
<i>(einfache Mounttabelle)</i>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

<i>(umfassendere Mounttabelle)</i>
#	<b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
#	<b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
#	<b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre></blockquote>

<p>
Benutze »<b>restore rvsf</b>« statt eines einfachen rsf, um die Namen
von Objekten zu sehen, während sie vom dump-Set ausgepackt werden.

<li>
<p>
Nachdem du jetzt auch alle Dateien der anderen Dateisysteme
wiederhergestellt hast, führe einen Neustart in den Multiuser-Modus
durch. Wenn alles geklappt hat, sollte dein System wieder genau so
sein, wie zum Zeitpunkt deiner letzten Sicherung, und bereit, wieder
eingesetzt zu werden.
</ul>

<a name="MountImage"></a>
<h2>14.10 - Diskimages unter OpenBSD mounten</h2>

<p>
Um ein Diskimage (ISO-Images, Diskimages, die mit dd erstellt wurden
etc.) unter OpenBSD zu mounten, musst du ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)</a>-Device
konfigurieren. Zum Beispiel, wenn du ein ISO-Image unter
<i>/tmp/ISO.image</i> hast, würdest du die folgenden Schritte machen,
um es zu mounten:

<blockquote><pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre></blockquote>

<p>
Bedenke bitte, dass du den Typ <i>cd9660</i> angeben musst, wenn es
eine CD ist. Das gilt aber auch für die anderen Typen. Du musst also
z.&nbsp;B. <i>ext2fs</i> beim Mounten eines Linux-Diskimages angeben.

<p>
Um das Image wieder zu unmounten, benutze die folgenden Kommandos.

<blockquote><pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre></blockquote>

<p>
Mehr Informationen gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>-Manualseite.

<a name="pciideErr"></a>
<h2>14.11 - Hilfe! Ich erhalte Fehler mit IDE-DMA!</h2>

<p>
DMA-IDE-Übertragungen, die durch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>
unterstützt werden, sind unzuverlässig. Bis vor kurzem wurden die
meisten Mainstreambetriebssysteme, die behaupteten, dass sie
DMA-Übertragungen mit IDE-Laufwerken unterstützen, nicht mit
standardmäßig aktivierter Unterstützung wegen unzuverlässiger Hardware
ausgeliefert. Nun werden viele dieser gleichen Maschinen mit OpenBSD
verwendet.

<p>
OpenBSD ist aggressiv und versucht, den höchsten DMA-Modus zu benutzen,
den es konfigurieren kann. Dies führt in einigen Konfigurationen zu
Datenkorruptionen aufgrund von defekten Motherboardchipsets,
fehlerhaften Treibern, die Probleme verursachen und/oder Lärm auf den
Kabeln. Glücklicherweise schützt Ultra-DMA die Datenübertragungen mit
einem CRC, um Korruptionen zu entdecken. Falls ein Fehler bei einem
solchen Ultra-DMA CRC geschieht, wird OpenBSD eine Fehlermeldung
ausgeben und erneut versuchen, die Daten zu übertragen.

<blockquote><pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre></blockquote>

<p>
Nach ein paar Fehlversuchen wird OpenBSD zu einem langsameren (und damit
hoffentlich zuverlässigeren) DMA-Modus herunterschalten. Nach den
Ultra-DMA-Modi wird dann zu einem PIO-Modus heruntergeschaltet.

<p>
UDMA-Fehler werden meistens durch minderwertige oder beschädigte Kabel
verursacht. Kabelprobleme sollten normalerweise zuerst in Betracht
gezogen werden, wenn du viele DMA-Fehler oder unerwartet niedrige
DMA-Leistung erhältst. Es ist ebenfalls eine schlechte Idee, das CD-ROM
an den gleichen Kanal wie die Festplatte zu stecken.

<p>
Wenn das Ersetzen der Kabel nicht zur Lösung des Problems führt und
OpenBSD nicht erfolgreich herunterschaltet oder der Prozess zu einem
Einfrieren deiner Maschine führt, möchtest du vielleicht dein System
auf einen niedrigeren DMA- oder UDMA-Level standardmäßig begrenzen.
Dies kann unter Verwendung von <a href="faq5.html#BootConfig">UKC</a>
oder <a href="faq5.html#config">config(8)</a> realisiert werden, indem
man die Optionen des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>-Devices
ändert.


<a name="RAID"></a>
<h2>14.13 - RAID-Optionen unter OpenBSD</h2>
RAID (Redundant Array of Inexpensive Disks) gibt die Möglichkeit,
mehrere Laufwerke zu verwenden, um bessere Leistung, Kapazität und/oder
Redundanz zu erhalten, als man aus einem einzelnen Laufwerk herausholen
kann. Während eine vollständige Diskussion über die Vorteile und Risiken
von RAID außerhalb des Rahmens dieses Artikels liegt, existieren einige
Punkte, die so wichtig sind, dass sie nun besprochen werden sollten:

<ul>
<li>RAID hat nichts mit Backup zu tun.
<li>RAID allein wird die Ausfallzeit nicht eliminieren.
</ul>

Wenn diese Information neu für dich ist, ist das kein guter
Ausgangspunkt, um RAID zu erforschen.

<h3>Software Möglichkeiten</h3>
OpenBSD beinhaltet RAIDframe - eine software-basierte RAID-Lösung.
Dokumentation hierfür kann an folgenden Stellen gefunden werden:

<ul>
<li><a href="#Optraid">Plattenoptimierung, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe-Homepage</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">Manualseite
     für raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">Manualseite
     für raid(4)</a>
</ul>

<p>
Die root-Partition kann direkt von OpenBSD unter Verwendung der
Option Autoconfiguration von RAIDframe gespiegelt werden.

<p>
OpenBSD 3.7-stable und neuer beinhaltet ebenfalls Mirroring als
Funktionalität des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>-Treibers.
Dieses System wurde in den GENERIC-Kernel integriert und befindet sich
im bsd.rd-Kernel einiger Plattformen (amd64, hppa, hppa64, i386), so
dass es viel einfacher genutzt werden kann, obwohl es einige
Begrenzungen im Bezug auf das Neuerzeugen des Arrays hat.

Siehe:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">Manualseite
zu ccd(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">Manualseite
zu ccdconfig(8)</a>
</ul>

<h3>Hardwaremöglichkeiten</h3>
<p>
Viele OpenBSD-<a href="../../de/plat.html">Plattformen</a> beinhalten
Unterstützung für etliche Hardware-RAID-Produkte. Die Möglichkeiten
variieren von Plattform zu Plattform: Siehe die passende
Hardwareunterstützungsseite (<a href="../../de/plat.html">hier</a>
aufgelistet).

<p>
Eine andere Möglichkeit, die für viele Plattformen bereit steht, ist
eine der vielen Produkte, die mehrere Laufwerke dazu bringt, wie ein
großes IDE- oder SCSI-Laufwerk zu agieren und die dann in einen
standardmäßigen IDE- oder SCSI-Adapter gesteckt werden. Diese Geräte
können nahezu auf jeder Hardwareplattform funktionieren, die entweder
SCSI oder IDE verwenden.

<p>
Einige Hersteller dieser Produkte:
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Hinweis: Dies sind nur Produkte, die von OpenBSD-Anwendern verwendet
und gemeldet wurden - dies ist weder eine Art Werbung noch ist es eine
ausführliche Liste.)

<h3>Keine Möglichkeit</h3>
<p>
Eine häufig gestellte Frage in den
<a href="../../de/mail.html">Mailinglisten</a> ist »Werden die
kostengünstigen IDE- oder SATA-RAID-Controller (wie zum Beispiel jene,
die die Highpoint-, Promise- oder Adaptec-HostRAID-Chips benutzen)
unterstützt?« Die Antwort ist »Nein«. Diese Karten und Chips sind nicht
echte Hardware-RAID-Controller sondern eher BIOS-assistierte Bots für
ein Software-RAID. Da OpenBSD bereits Software-RAID auf eine
hardwareunabhängige Art und Weise unterstützt, besteht kein großes
Verlangen bei den OpenBSD-Entwicklern, diese spezielle Unterstützung
für diese Karten zu implementieren.

<p>
Fast alle Onboard-SATA- oder -IDE-»RAID«-Controller sind von diesem
softwarebasierten Stil und funktionieren normalerweise einwandfrei als
SATA- oder IDE-Controller unter Verwendung des standardmäßigen
IDE-Treibers
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>).
Sie werden aber nicht als Hardware-RAID-System unter OpenBSD
funktionieren.

<a name="NegSpace"></a>
<h2>14.14 - Warum sagt mir <tt>df(1)</tt>, dass ich mehr als 100&nbsp;%
von meiner Platte belegt habe?</h2>
Leute sind manchmal erstaunt darüber, herausfinden zu müssen, dass sie
<i>negativen</i> verfügbaren Plattenspeicher haben oder mehr als
100&nbsp;% eines Dateisystems in Verwendung ist, wie es von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;sektion=1">df(1)</a>
angezeigt wird.

<p>
Wenn ein Dateisystem mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
erstellt wird, wird ein Teil des verfügbaren Speichers vor den normalen
Benutzern in Reserve gehalten. Dies stellt einen Spielraum für Fehler
bereit, wenn du versehentlich die Platte füllst und hilft, die
Plattenfragmentierung auf einem Minimum zu halten. Standardwert hierfür
ist 5&nbsp;% der Plattenkapazität, sodass, falls der
Systemadministrator sorglos die Platte auffüllt, du bis zu 105&nbsp;%
Speicher sehen kannst, der verwendet wird.

<p>
Wenn der 5-%-Wert für dich nicht angemessen erscheint, kannst du ihn mit
dem Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">tunefs(8)</a>
ändern.

<a name="OhBugger"></a>
<h2>14.15 - Partitionen wiederherstellen, nachdem das Disklabel gelöscht
wurde</h2>

<p>
Wenn du eine Partitionstabelle beschädigt hast, gibt es einige Dinge,
die du versuchen kannst, um sie wiederherzustellen.

<p>
Zu aller erst Panik. Das würde sowieso passieren - aber dann hast du
es jedenfalls hinter dir. Mach einfach nichts Unvernünftiges. Halte
deine Panik von der Maschine fern. Dann entspanne dich und guck, ob dir
die unten stehenden Schritte vielleicht weiterhelfen.

<p>
Eine Kopie des Disklabels wird für jede Platte als Teil der täglichen
Systemverwaltung unter <tt>/var/backups</tt> gespeichert. Angenommen,
dass du die var-Partition weiterhin hast, kannst du einfach die Ausgabe
lesen und sie zurück in das Disklabel schreiben.

<p>
Falls du die Partition nicht mehr sehen kannst, gibt es zwei
Möglichkeiten. Behebe genug Fehler der Platte, bis du sie sehen kannst
oder behebe genug Fehler der Platte, um deine Daten von ihr zu bekommen.

Abhängig davon, was passiert ist, könnte der eine oder ein anderer
Weg bevorzugt sein (mit sterbenden Platten, von denen du zuerst
die Daten haben willst, könntest du mit schlampigen Fingern nur das
Label bekommen).

<p>

Das erste Werkzeug, das du brauchst, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(achte auf den Unterstrich, es wird nicht »scanffs« genannt).
Das Werkzeug scan_ffs(8) durchsucht die Platte und versucht,
Partitionen zu finden, und teilt dir die Informationen mit, die es über
sie herausgefunden hat. Du kannst diese Informationen nutzen, um das
Disklabel neu zu erstellen. Wenn du einfach nur <tt>/var</tt>
zurückhaben willst, kannst du die Partition für <tt>/var</tt> wieder
erstellen und dann das gesicherte Label nutzen, um den Rest von diesem
aus zu erstellen.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel;sektion=8">disklabel(8)</a>
wird sowohl die Erkenntnis des Kernels über das Disklabel erneuern
als auch versuchen, das Label auf die Platte zu schreiben.
Selbst wenn der Bereich der Platte, in dem das Disklabel liegt, nicht
lesbar ist, wirst du trotzdem in der Lage sein, bis zum nächsten
Neustart
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>
aufzurufen.


<a name="foreignfs"></a>
<h2>14.16 - Kann ich auf Daten zugreifen, die auf anderen Dateisystemen
als FFS liegen?</h2>
<!-- This article written by Steven Mestdagh,
steven@openbsd.org, and released under the BSD license -->

Ja. Andere unterstützte Dateisysteme sind unter anderem: ext2 (Linux),
ISO9660 und UDF (CD-ROM-, DVD-Medien), FAT (MS-DOS und Windows), NFS,
NTFS (Windows) und AmigaDOS. Einige von ihnen haben eingeschränkte - zum
Beispiel nur schreibgeschützte - Unterstützung.  Beachte, dass FreeBSDs
UFS2-Dateisystem nicht unterstützt wird.

<p>
Wir werden hier einen allgemeinen Überblick darüber geben, wie man eines
dieser Dateisysteme unter OpenBSD verwendet. Um in der Lage zu sein, ein
Dateisystem zu benutzen, muss es gemountet sein. Für Details und
Optionen für mount, konsultiere bitte die Manualseite zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
und die Manualseite zum mount-Kommando für das Dateisystem, das du
mounten möchtest, z.&nbsp;B. mount_msdos, mount_ext2fs,&nbsp;...

<p>
Zu aller erst musst du wissen, auf welchem Device sich dein Dateisystem
befindet. Vielleicht einfach deine erste Festplatte (<tt>wd0</tt> oder
<tt>sd0</tt>), es könnte aber auch weniger offensichtlich sein.
Alle erkannten und konfigurierten Devices deines Systems werden in der
Ausgabe vom Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
aufgeführt: ein Devicename, gefolgt von einer einzeiligen Beschreibung
des Devices. Mein erstes CD-ROM-Laufwerk wird beispielsweise wie folgt
erkannt:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

<p>
Du kannst
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
verwenden, um eine viel kürzere Liste der verfügbaren Platten zu
erhalten. Das Kommando

<blockquote><pre>
# sysctl hw.disknames
</pre></blockquote>

wird alle Platten anzeigen, die deinem System momentan bekannt sind,
z.&nbsp;B.:

<blockquote><pre>
hw.disknames=cd0,cd1,wd0,fd0,cd2
</pre></blockquote>

<p>
An diesem Punkt angekommen ist es Zeit dafür, herauszufinden, welche
Partitionen sich auf dem Device befinden, und auf welcher Partition das
gewünschte Dateisystem liegt. Daher untersuchen wir das Device mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
Das Disklabel beinhaltet eine Liste, die aus maximal 16 Partitionen
besteht. Partition c steht immer für das gesamte Device. Partitionen
a - b und d - p werden von OpenBSD genutzt. Partitionen i - p können
automatisch für Dateisysteme anderer Betriebssysteme allokiert werden.
In diesem Fall werde ich mir das Disklabel meiner Festplatte betrachten,
welches eine Anzahl verschiedener Dateisysteme beinhaltet.

<p>
<b>HINWEIS: OpenBSD wurde nach allen anderen Betriebssystemen
installiert</b> und während der Installation wurde ein Disklabel
erstellt, das alle Partitionen der nativen als auch der anderen
Dateisysteme enthält, die sich auf der Platte befanden. Wenn du jedoch
andere Dateisysteme installiert nachdem das OpenBSD-Disklabel bereits
auf der Platte installiert wurde, musst du sie nachträglich manuell
hinzufügen oder ändern. Dies wird in <a href="#foreignfsafter">diesem
Unterkapitel</a> behandelt.

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        408366      20338290  4.2BSD   2048 16384   16 # Cyl 20176*- 20581
  b:       1638000      20746656    swap                   # Cyl 20582 - 22206
  c:      78165360             0  unused      0     0      # Cyl     0 - 77544
  d:       4194288      22384656  4.2BSD   2048 16384   16 # Cyl 22207 - 26367
  e:        409248      26578944  4.2BSD   2048 16384   16 # Cyl 26368 - 26773
  f:      10486224      26988192  4.2BSD   2048 16384   16 # Cyl 26774 - 37176
  g:      12182499      37474416  4.2BSD   2048 16384   16 # Cyl 37177 - 49262*
  i:         64197            63 unknown                   # Cyl     0*-    63*
  j:      20274030         64260 unknown                   # Cyl    63*- 20176*
  k:       1975932      49656978   MSDOS                   # Cyl 49262*- 51223*
  l:       3919797      51632973 unknown                   # Cyl 51223*- 55111*
  m:       2939832      55552833  ext2fs                   # Cyl 55111*- 58028*
  n:       5879727      58492728  ext2fs                   # Cyl 58028*- 63861*
  o:      13783707      64372518  ext2fs                   # Cyl 63861*- 77535*

</pre></blockquote>

<p>
Wie du in dieser Ausgabe erkennen kannst, werden die OpenBSD-Partitionen
zuerst aufgelistet. Nach diesen werden einige ext2-Partitionen und
eine MSDOS-Partition aufgelistet, sowie ein paar unbekannte (unknown)
Partitionen. Auf i386- und amd64-Systemen kannst du mehr über diese
unter Verwendung des Werkzeugs
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
in Erfahrung bringen.
Für den neugierigen Leser: Partition i ist eine Wartungspartition, die
vom Hersteller erzeugt wurde, Partition j ist eine NTFS-Partition und
Partition l ist eine Swappartition für Linux.

<p>
Sobald du herausgefunden hast, welche dieser Partitionen die ist, die du
benutzen möchtest, kannst du den letzten Schritt durchführen: das
Dateisystem, das sich auf dieser befindet, mounten. Die meisten
Dateisysteme werden vom GENERIC-Kernel unterstützt: Wirf einfach einen
Blick in die Kernelkonfigurationsdatei, die sich im Verzeichnis
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt> befindet.
Einige werden jedoch nicht unterstützt, z.&nbsp;B. ist die
NTFS-Unterstützung experimentell und daher nicht im GENERIC.
Wenn du eines der Dateisysteme nutzen möchtest, die nicht in GENERIC
unterstützt werden, musst du <a href="faq5.html#Options">einen
angepassten Kernel erzeugen</a>.

<p>
Wenn du die Informationen auf zuvor beschriebene Weise gesammelt hast,
ist es nun an der Zeit, das Dateisystem zu mounten.
Lass uns annehmen, dass ein Verzeichnis namens <tt>/mnt/otherfs</tt>
existiert, welches wir als Mountpunkt nutzen werden, unter dem wir das
gewünschte Dateisystem mounten werden.
In diesem Beispiel werden wir das ext2-Dateisystem von Partition m
mounten:

<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/otherfs</b>
</pre></blockquote>

<p>
Wenn du vorhast, dieses Dateisystem regulär zu nutzen, kannst du etwas
Zeit sparen, indem du eine Zeile in <tt>/etc/fstab</tt> schreibst; zum
Beispiel etwas wie:

<blockquote><pre>
/dev/wd0m /mnt/otherfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>

Beachte den Wert 0 im fünften und sechsten Feld. Diese bedeuten, dass
wir nicht möchten, dass die Dateisysteme mit dump gesichert oder unter
Verwendung von fsck überprüft werden. Generell gilt, dass du solche
Aufgaben eher mit dem dazugehörigem Betriebssystem machen möchtest.

<a name="foreignfsafter"></a>
<h3>14.16.1 - Die Partitionen sind nicht in meinem Disklabel! Was kann
ich tun?</h3>

Wenn du andere Dateisysteme auf deinem System angelegt hast (resultiert
meist aus der Installation eines anderen Betriebssystems) nachdem du
OpenBSD bereits installiert hast, wird ein Disklabel bereits vorliegen
und nicht automatisch aktualisiert, sodass es die neuen fremden
Dateisystempartionen enthielte. Wenn du diese verwenden möchtest,
dann musst du diese Partitionen manuell unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
hinzufügen oder editieren.

<p>
Beispielsweise habe ich eine meiner bestehenden ext2fs-Partitionen
geändert: Unter Verwendung von Linux' fdisk-Programm habe ich die
Größe der o-Partition (siehe die Disklabelausgabe weiter oben) auf 1 G
reduziert. Wir können dies leicht sehen, indem wir einen Blick auf die
Startposition (Offset: 64372518) und die Größe (13783707) werfen.
Beachte, dass diese Werte Sektornummern und dass die Verwendung von
Sektornummern (nicht Megabyte oder ein anderes Maß) die genaueste
Angabe ist und der sicherste Weg, um diese Informationen zu lesen.

<p>
Vor dem Ändern sah die Partition wie diese aus (Ausgabe von OpenBSDs
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Werkzeug
[nur die wichtigen Informationen werden hier angegeben]):

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4864 254 63 [    64372518:    13783707 ] Linux files*
. . .
</pre></blockquote>

Wie du sehen kannst sind die Startposition und die Größe genau so, wie
sie zuvor von disklabel(8) angegeben wurden. (Sei jetzt nicht wegen dem
Wert verwirrt, der als Offset angegeben wird: der Wert bezieht sich auf
die Startposition der erweiterten Partition, in der sich die
ext2-Partition befindet.)

<p>
Nachdem die Partitionsgröße unter Linux geändert wurde, sieht sie wie
folgt aus:

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4137 254 63 [    64372518:     2104452 ] Linux files*
. . .
</pre></blockquote>

Dies muss nun unter Verwendung von disklabel(8) geändert werden.
Zum Beispiel kannst du <tt>disklabel -e wd0</tt> aufrufen, womit du
einen Editor startest, der mit der Umgebungsvariable EDITOR (Standard
ist vi) angegeben wird. Ändere mit diesem Editor die Zeile des
Disklabels, um diese auf die neue Größe anzupassen:

<blockquote><pre>
  o:       2104452      64372518  ext2fs
</pre></blockquote>

Schreibe das Disklabel auf die Platte, wenn du fertig bist. Nun, da das
Disklabel wieder aktuell ist, solltest du in der Lage sein, die
Partitionen wie oben beschrieben wieder mounten zu können.

<p>
Du kannst einen sehr ähnlichen Prozess ausführen, um neue Partitionen
hinzuzufügen.


<a name="flashmem"></a>
<h2>14.17 - Kann ich ein Gerät mit Flashspeicher unter OpenBSD
benutzen?</h2>
<!-- This article written by Steven Mestdagh,
steven@openbsd.org, and released under the BSD license -->

Normalerweise sollte ein Speichergerät erkannt werden, wenn es an eine
Schnittstelle deiner Maschine angeschlossen wird. Kurz nach dem
Anschließen werden einige Nachrichten auf der Konsole des Kernels
angezeigt. Wenn ich zum Beispiel meinen USB-Flashspeicher anschließe,
sehe ich Folgendes auf meiner Konsole:

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 123 cyl, 64 head, 32 sec, 512 bytes/sec, 251904 sec total
</pre></blockquote>

Diese Zeilen deuten darauf, dass der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass&amp;sektion=4">umass(4)</a>-
(USB-Massenspeicher-) Treiber an das Speichergerät angehängt wurde und
dass es das SCSI-System nutzt. Die beiden letzten Zeilen sind die
wichtigsten: Sie sagen, an welche Gerätedatei das Speichergerät
angehängt wurde, und wie groß der gesamte Speicherplatz ist.
Wenn du diese Zeilen - warum auch immer - verpasst haben solltest,
kannst du sie nachträglich mit dem Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
betrachten. Die angegebene CHS-Geometrie ist eine fiktive, da der
Flashspeicher wie eine normale SCSI-Platte verarbeitet wird.

<p>
Wir werden nun zwei Szenarien besprechen.

<h3>Das Gerät ist neu/leer und du möchtest es nur mit OpenBSD
nutzen</h3>

Du musst ein Disklabel und mindestens eine Partition auf diesem Gerät
erstellen. Bitte lies <a href="#disklabel">OpenBSDs disklabel
verwenden</a> und die Manualseite zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
für Details hierüber.

<p>
In diesem Beispiel habe ich nur die Partition <i>a</i> erstellt, auf
der ich ein FFS-Dateisystem erstellen werde:

<blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
    cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
        122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Lass uns das Dateisystem, das wir auf der Partition <i>a</i> erstellt
haben, unter <tt>/mnt/flashmem</tt> mounten.
Erstelle zuerst einen Mountpunkt, wenn er noch nicht existiert.

<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>

<h3>Du hast das Speichergerät von jemandem erhalten, mit dem du Daten
austauschen möchtest</h3>

<p>
Möglicherweise wird diese andere Person nicht OpenBSD nutzen, sodass
sich ein fremdes Dateisystem auf diesem Speichergerät befinden kann.
Daher müssen wir zuerst alle Partitionen auf diesem Gerät finden, so
wie es in <a href="#foreignfs">FAQ 14 - Fremde Dateisysteme</a>
beschrieben steht.

<blockquote><pre>
# <b>disklabel sd0</b>

# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  c:        251904             0  unused      0     0      # Cyl     0 -   122
  i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

Wie man in der Ausgabe von disklabel sehen kann, gibt es nur eine
Partition names <i>i</i>, das ein FAT-Dateisystem beinhaltet, das von
einer Windows-Maschine erstellt wurde. Wie gewöhnlich stellt die
Partition <i>c</i> das gesamte Gerät dar.

<p>
Lass uns nun das Dateisystem auf der Partition <i>i</i> unter
<tt>/mnt/flashmem</tt> mounten.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>

Nun können wir damit beginnen, es wie jede andere Platte anzusprechen.

<p>
<b>WARNUNG:</b>
Du solltest das Dateisystem <b>vor dem Herausziehen</b> des Geräts
<b>immer erst unmounten</b>.
Wenn du das nichts tust, könnte das Dateisystem in einem nicht
konsistenten Zustand zurückgelassen werden, was im schlimmsten Fall
Datenverlust bedeutet.

<p>
Nach dem Entfernen des Speichergeräts von deiner Maschine wirst du
wieder sehen, dass der Kernel Meldungen hierüber auf der Konsole
ausgibt:

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<p>
<a name= "DiskOpt"></a>
<h2>14.18 - Die Festplattenleistung optimieren</h2>

<p>
Die Festplattenleistung ist ein wichtiger Faktor in der
Gesamtgeschwindigkeit deines Computers. Sie wird umso wichtiger,
wenn dein Computer eine Multiuserumgebung beheimatet
(Benutzer aller Arten - von solchen, die sich einloggen, bis zu denen,
die Serverdienste nutzen). Datenspeicher brauchen ständige
Aufmerksamkeit; insbesondere, wenn deine Partition überläuft
oder deine Platten versagen. OpenBSD kennt verschiedene Optionen, um
die Geschwindigkeit deiner Festplattenoperationen zu erhöhen
und Fehlertoleranz zu bieten.

<p>
<ul>
<li><a href="#Optccd">CCD</a> - Concatenated Disk Driver.
<li><a href="#Optraid">RAID</a>
<li><a href="#Optsoftu">Softupdates</a>
<li><a href="#Optmaxvnodes">Größe des namei()-Caches</a>
</ul>

<p>
<a name="Optccd"></a>
<h3>14.18.1 - CCD</h3>

Die erste Option ist die Benutzung des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>
- des Concatenated Disk Driver.
Dieser erlaubt dir, mehrere Partitionen in eine virtuelle Platte zu
verwandeln (und damit kannst dafür sorgen, dass mehrere Festplatten wie
eine einzige aussehen). Dieses Konzept ist ähnlich wie das von LVM
(logical volume management), das in mehreren kommerziellen Unix-Arten
zu finden ist.

<p>
Wenn du GENERIC benutzt, ist ccd bereits eingeschaltet (in
<tt>/usr/src/sys/conf/GENERIC</tt>).  Wenn du einen veränderten
Kernel benutzt, musst du ihn vielleicht wieder in deine
Kernelkonfiguration einfügen. Wie auch immer, auf jeden Fall muss sich
eine Zeile wie die folgende in deiner Konfigurationsdatei befinden:

<blockquote><pre>
<strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre></blockquote>

<p>
Das obige Beispiel gibt dir bis zu 4 ccd-Devices (virtuelle Platten).
Jetzt musst du festlegen, welche Partitionen auf deinen realen
Festplatten du in den ccd einbinden willst. Benutze disklabel, um diese
Partitionen als ccd-Typ zu markieren. Auf einigen Architekturen
erlaubt dir disklabel das vielleicht nicht. In diesem Fall markiere sie
einfach als FFS.

<p>
Wenn du ccd dazu benutzt, um mittels striping Leistung zu gewinnen,
solltest du wissen, dass du keine optimale Leistung bekommst, bis du das
gleiche Festplattenmodell mit den gleichen Disklabeleinstellungen benutzt.

<p>
Editiere /etc/ccd.conf, bis sie etwa so aussieht:
(Mehr Informationen über das Konfigurieren von ccd findest du unter
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>)

<blockquote><pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre></blockquote>

<p>
Um die Änderungen wirksam zu machen, führe das hier aus:

<blockquote><pre>
# ccdconfig -C
</pre></blockquote>

<p>
Solange /etc/ccd.conf existiert, wird sich ccd automatisch beim Booten
konfigurieren.
Jetzt hast du eine neue Festplatte (ccd0): eine Kombination von
/dev/sd2e und /dev/sd3e. Benutze disklabel einfach wie gewöhnlich, um
die Partition oder Partitionen zu erzeugen, die du benutzen willst.
Nutze erneut die Partition c nicht, um darauf irgendetwas zu speichern.
Stelle sicher, dass deine benutzten Partitionen mindestens einen
Zylinder vom Anfang der Disk weg ist.

<p>
<a name="Optraid"></a>
<h3>14.18.2 - RAID</h3>

Eine weitere Lösung ist
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>,
wofür du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
nutzen musst, um deine RAID-Geräte zu kontrollieren. OpenBSDs RAID
basiert auf Greg Osters
<a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD-Port</a>
der
CMU-<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a>-Software.
OpenBSD hat Unterstützung für die RAID-Level
0, 1, 4 und 5.

<p>
Für raid muss - wie auch bei ccd - Unterstützung im KERNEL sein.
Diese Treiberunterstützung für RAID ist im Gegensatz zu ccd allerdings
nicht im GENERIC-Kernel enthalten; sie muss also extra in deinen Kernel
einkompiliert werden (RAID-Unterstützung vergrößert deinen
i386-Kernel um gute 500k).

<blockquote><pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre></blockquote>

<p>
Lies die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>- und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>-Manualseiten
für die kompletten Details. Es gibt dafür viele Optionen und mögliche
Konfigurationen, und ein detaillierter Überblick sprengt den Rahmen
dieses Dokumentes.

<p>
<a name="Optsoftu"></a>
<h3>14.18.3 - Softupdates</h3>

Ein weiteres Werkzeug zum Erhöhen der Systemgeschwindigkeit sind
Softupdates. Eine der langsamsten Operationen im traditionellen
BSD-Dateisystem ist das Aktualisieren der Metainfos (was unter anderem
immer dann geschieht, wenn du Dateien oder Verzeichnisse erzeugst oder
löschst). Softupdates versucht die Metainfo im RAM zu aktualisieren,
statt jedes einzelne Metainfoupdate auf die Platte zu schreiben. Ein
weiterer Nebeneffekt ist, dass die Metainfos auf der Festplatte immer
auf dem aktuellen Stand sind. Das heißt, ein Systemabsturz sollte kein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
beim folgende Booten benötigen, sondern eine einfache Hintergrundversion
von fsck, die Änderungen an den Metainfos im RAM macht (a la
Softupdates). Das heißt, dass Reboots viel schneller sind, da
nicht mehr auf fsck gewartet werden muss! (OpenBSD hat diese
Funktionalität leider noch nicht.) Mehr über Softupdates findest du im
<a href="#SoftUpdates">Softupdates-FAQ</a>-Eintrag.

<p>
<a name="Optmaxvnodes"></a>
<h3>11.1.4 - Größe des namei()-Caches</h3>

Die name-to-inode-Übersetzung (a.&nbsp;k.&nbsp;a. <!-- need to write
the manual page first... <a href="">namei(3)</a> --> namei()-Cache)
kontrolliert die Geschwindigkeit der
pathname-to-<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>-Übersetzung.
Ein sinnvoller Weg zum Herausfinden der passenden Größe des Caches
wäre eine große Anzahl namei()-Cachemisses, die man mit einem
Werkzeug wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a>
messen könnte (was eine Untersuchung des momentanen berechneten Wertes
mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a> voraussetzt, das diesen Parameter <tt>kern.maxvnodes</tt>
nennt) und diesen Wert zu vergrößern, bis sich entweder die Hitrate des
namei()-Caches verbessert oder es bewiesen ist, dass das System nicht
wesentlich von einer Erhöhung der Größe des namei()-Caches profitiert.
Nachdem der Wert festgestellt wurde, kannst du ihn für die nächsten
Systemstarts mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>
setzen.

<p>
<a name= "Async"></a>
<h2>14.19 - Wieso benutzen wir keine »async mounts«?</h2>

<p>
Frage: »Ich gebe einfach ein ,mount -u -o async /' ein, was ein Paket,
welches ich brauche, benutzbar macht (das darauf besteht alle paar
Momente ein paar hundert Dateien zu ändern).

Wieso wird asynchrones Mounting abgelehnt und ist nicht standardmäßig
aktiviert (wie in manchen anderen Unixen)? Wäre das nicht ein
einfacherer und daher auch ein sichererer Weg, die Leistung mancher
Applikation zu erhöhen?«

<p>
Antwort: »Asynchrone Mounts sind tatsächlich schneller als synchrone
Mounts - aber auch unsicherer. Was passiert im Falle eines
Stromausfalls - oder bei einem Hardwareproblem? Die Suche nach
Geschwindigkeit darf nicht auf Kosten der Stabilität und Zuverlässigkeit
des Systems gehen. Siehe auch die Manualseite von
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>.«

<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>

<p>
Auf der anderen Seite kannst du mehr Geschwindigkeit erhalten, wenn du
sowieso nur mit temporären Daten umgehst, die du nach einem Crash wieder
rekonstruieren kannst, indem du eine separate Partition nur für
diese Daten benutzt, die asynchron gemountet ist. Tue das aber <i>nur,
wenn</i> dir der Verlust aller Daten in der Partition nach irgendeinem
Problem nichts ausmacht. Daher sind
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>-Partitionen
asynchron gemountet, weil sie ja nach jedem Neustart sowieso gelöscht
und neu erzeugt werden.


<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq13.html">[Zum Kapitel 13 - Multimedia]</a>
<a href= "faq15.html">[Zum Kapitel 15 - Packages und Ports]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq14.html,v 1.176 ]<br>
$Translation: faq14.html,v 1.90 2008/11/22 11:01:56 paldium Exp $<br>
-->
$OpenBSD: faq14.html,v 1.73 2008/11/26 08:25:02 tobias Exp $
</small>

</body>
</html>

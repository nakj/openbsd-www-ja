<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>13 - Multimedia</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>

<!--
Copyright (c) 2005-2007 Steven Mestdagh <steven@openbsd.org>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq12.html">[Zum Kapitel 12 - Hardware- und plattformspezifische Fragen]</a>
<a href= "faq14.html">[Zum Kapitel 14 - Platteneinrichtung]</a>
</font>

<h1><font color="#e00000">13 - Multimedia</font></h1><hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#confaudio"  >13.1 - Wie konfiguriere ich mein
  Audiodevice?</a>
<li><a href="#playaudio"  >13.2 - Unterschiedliche Audiotypen
  abspielen</a>
<li><a href="#playCD"     >13.3 - Wie kann ich Audio-CDs unter OpenBSD
  abspielen?</a>
<li><a href="#recordaudio">13.4 - Kann ich OpenBSD benutzen, um
  Audiostücke aufzuzeichnen?</a>
<li><a href="#midi"	  >13.5 - Wie verwende ich meine
  MIDI-Instrumente?</a>
<li><a href="#lossyaudio" >13.6 - Was gibt es über Ogg-Vorbis- und
  MP3-Encoding zu sagen?</a>
<li><a href="#playDVD"    >13.7 - Wie kann ich Video-DVDs unter OpenBSD
  abspielen?</a>
<li><a href="#burnCD"     >13.8 - Wie brenne ich CDs und DVDs?</a>
<ul>
<li><a href="#burnIntro">13.8.1 - Einführung und grundlegende
  Einrichtung</a>
  <li><a href="#writeCD"  >13.8.2 - CDs brennen</a>
  <li><a href="#writeDVD" >13.8.3 - DVDs brennen</a>
</ul>
<li><a href="#convert"    >13.9 - Ich möchte meine Mediendateien aber im
  Format XYZ haben.</a>
<li><a href="#streaming"  >13.10 - Ist es möglich, Streams unter
  OpenBSD abzuspielen?</a>
<li><a href="#javaplugin" >13.11 - Kann ich mit meinem Webbrowser
  Java verwenden? (nur i386 u. amd64)</a>
<li><a href="#flashplugin">13.12 - Kann ich mit meinem Webbrowser
  Flash verwenden? (nur i386)</a>
<!--
<li><a href="#camera"     >13.xx - Kann ich meine Digitalkamera unter
  OpenBSD verwenden?</a>
<li><a href="#scanner"    >13.yy - Wie richte ich meinen Scanner ein und
  wie verwende ihn?</a>
-->
</ul>
<hr>

<a name="confaudio"></a>
<h2>13.1 - Wie konfiguriere ich mein Audiodevice?</h2>

Die Gerätedateien unter OpenBSD, die mit Audio zu tun haben, sind
<tt>/dev/audio</tt>, <tt>/dev/sound</tt>, <tt>/dev/audioctl</tt> und
<tt>/dev/mixer</tt>. Bitte lies die Manualseite für
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audio&amp;sektion=4">audio(4)</a>,
um einen guten Überblick über die Audiotreiberschicht zu erhalten.

<p>
Alle unterstützten Audiotreiber befinden sich bereits im GENERIC-Kernel,
sodass keine weitere Konfiguration oder Installation der Treiber
notwendig ist. Um die Optionen für deinen Soundchip zu erfahren, musst
du herausfinden, welchen Soundchip du hast. Unterstützte Chips können
auf der Hardwarekompatibilitätsseite für deine
<a href="../../de/plat.html">Plattform</a> gefunden werden.
Wenn OpenBSD bei dir bereits läuft, siehe nach, ob in der Ausgabe vom
Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
ein Soundtreiber aufgelistet wird und lies die Manualseite für diesen,
um weitere spezifische Informationen wie zum Beispiel Optionen und
andere Details über diesen Treiber zu erfahren.
Ein Beispiel für einen Audiochip in einer Ausgabe von dmesg ist:

<blockquote><pre>
auich0 at pci0 dev 31 function 5 "Intel 82801BA AC97" rev 0x04: irq 10, ICH2 AC97
ac97: codec id 0x41445360 (Analog Devices AD1885)
ac97: codec features headphone, Analog Devices Phat Stereo
audio0 at auich0
</pre></blockquote>

<p>
Du kannst testen, ob dein Audiodevice bereits ordnungsgemäß läuft, indem
du eine Audiodatei (normalerweise mit der Endung .au) an es sendest.
Wenn du keine Audiodatei hast, kannst du ebenfalls irgendeine Text-
oder Binärdatei an das Device senden:

<blockquote><pre>
$ <strong>cat filename > /dev/audio</strong>
</pre></blockquote>

Wenn du etwas hörst (sollte es keine Audiodatei gewesen sein, wird es
sich nicht gut anhören und vielleicht auch laut sein), bedeutet das,
dass der Chip von OpenBSD unterstützt wird und beim Hochfahren vom
Kernel erkannt und konfiguriert wurde.

<p>
<b>Hinweis:</b>
Nicht jede Unterart oder Verarbeitung aller Chips wurde getestet oder
auf Fehler untersucht.

<p>
Wenn du nach dem Eingeben des Kommandos nichts gehört hast, kann es
einige mögliche Gründe hierfür geben:
<ul>
<li>Die Datei, die du an das Device gesendet hast, war zu klein und
du konntest einfach nichts hören. Versuche erneut, eine Datei zu
senden, die mindestens 10 kB groß ist.
<li>Der Chip wurde korrekt erkannt und konfiguriert, aber der Sound
wurde ausgeschaltet und muss erst eingeschaltet werden, damit man etwas
hören kann. Siehe weiter unten.
<li>Der Chip wurde erkannt aber nicht richtig konfiguriert. Vielleicht
hast du eine alte ISA-Karte, die mit einer anderen E/A-Adresse oder
mit einem anderen IRQ-Wert konfiguriert werden muss, um Konflikte mit
anderen Hardwarekomponenten zu verhindern. Du kannst auf einfache Weise
unter Verwendung der
<a href="faq5.html#BootConfig">User Kernel Configuration (UKC)</a>
unterschiedliche Kombinationen testen.
<li>Deine Karte oder dein Chipsatz wird nicht vollständig unterstützt.
</ul>

<p>
Bedenke, dass selbst wenn du etwas gehört hast, das noch nicht unbedingt
bedeutet, dass alles so funktionieren wird wie du es gerne möchtest.
Wenn du beim Abspielen von Sounds Probleme hast, solltest du die
folgenden Dinge aus dieser Liste überprüfen:
<ul>
<li>Finde Informationen über dein Soundgerät. Verwende die Dokumentation
oder verwende eine Internetsuchmaschine, um die Spezifikationen zu
ermitteln. Diese können dir eventuell dabei helfen, die Ursache deines
Problems zu finden.
<li>Bitte stelle sicher, dass <b>alle</b> deine Ausgabekanäle auch
Sound ausgeben können (d.&nbsp;h. dass sie nicht auf mute stehen), bevor
du ein Problem berichtest (siehe weiter unten, wie man die Ausgabe
aktiviert). Manchmal kann es sein, dass die aufgelisteten Ausgabekanäle
nicht der Wahrheit entsprechen und zum Beispiel der Kopfhörerausgang
mit dem Lineausgang vertauscht wurde.
<li>Es kann sein, dass ein nicht sonderlich gut geeigneter Treiber für
dein Soundgerät verantwortlich ist und dass du bessere Ergebnisse
bekommst, wenn du einen anderen Treiber verwendest. Es ist nicht
sonderlich leicht, diese Art von Problem zu erkennen, doch solltest du
einen genauen Blick auf die Ausgabe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
werfen, um die Zeilen zu finden, die etwas über die Audiotreiber sagen.
Wenn du siehst, dass mehr als nur ein Soundtreiber zugewiesen wird
(oder es mehrere versuchen), dann versuche sie nach und nach jeweils
zu testen, indem du mittels
<a href="faq5.html#BootConfig">User Kernel Configuration (UKC)</a>
einige deaktivierst und nur einen belässt.
<li>Vielleicht hast du ein Soundgerät, das nur eine bestimmte Samplerate
abspielen kann. In diesem Fall gibt es Audiowerkzeuge, die das
Rateresampling unterstützen, wie es in
<a href="#playaudio">Unterschiedliche Audiotypen abspielen</a> genauer
erläutert wird.


</ul>

<p>
Um die Parameter für dein Audiodevice einzustellen - wie zum Beispiel
die Samplerate - kannst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audioctl&amp;sektion=1">audioctl(1)</a>
verwenden.
Um die Lautstärke oder andere Mixereinstellungen zu konfigurieren,
kannst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mixerctl&amp;sektion=1">mixerctl(1)</a>
benutzen.
Beide Werkzeuge werden als Teil des Basissystems mitgeliefert.

<p>
Um zum Beispiel die Lautstärke vom linken sowie vom rechten Kanal
auf 200 zu setzen, würdest du beispielsweise (Siehe Hinweis 2 weiter
unten) Folgendes aufrufen:

<blockquote><pre>
$ <strong>mixerctl outputs.master=200,200</strong>
outputs.master: 255,255 -&gt; 207,207
</pre></blockquote>

Beachte, dass der Wert 207 wird. Der Grund hierfür ist, dass mein
Audiodevice einen AC'97-Codec hat, der nur 5 Bits für
Lautstärkekontrolle verwendet. Das führt zu gerade einmal 32
möglichen Werten. Selbstverständlich kann andere Hardware eine
andere Anzahl Bytes haben.

<p>
Um den Masterkanal zu aktivieren, würdest du Folgendes aufrufen:

<blockquote><pre>
$ <strong>mixerctl outputs.master.mute=off</strong>
outputs.master.mute: on -&gt; off
</pre></blockquote>

<p>
Um deine Änderungen fest einzutragen, musst du <i>/etc/mixerctl.conf</i>
editieren. Beispielsweise:

<blockquote><pre>
$ <strong>cat /etc/mixerctl.conf</strong>
outputs.master=200,200
outputs.master.mute=off
outputs.headphones=160,160
outputs.headphones.mute=off
</pre></blockquote>

<b>Hinweis 1:</b>
Es kann sein, dass du mehr Anschlüsse sehen kannst, als sich auf deiner
Soundkarte oder deinem Mainboard befinden. Der Grund hierfür ist, dass
es normalerweise günstiger ist, Chips auf den Boards zu installieren,
als die Buchsen für die Anschlüsse einzubauen, sodass nicht jede
Option des Audiochips notwendigerweise auch die Außenwelt erreicht.

<p>
<b>Hinweis 2:</b>
Die Ausgaben deines Audiodevices könnte auf deinem System anders benannt
sein. Zum Beispiel ist es möglich, dass du kein outputs.master wie in
der oben aufgeführten Ausgabe hast. Stattdessen müsstest du zum Beispiel
outputs.output oder eine andere Einstellung ändern. Diese Namen hängen
vom Audiotreiber ab. Du kannst den passenden Namen auf einfache Weise
herausfinden, indem du die Kontrollwerte mit Folgendem Aufruf auflisten
lässt:

<blockquote><pre>
$ <b>mixerctl -a</b>
</pre></blockquote>


<a name="playaudio"></a>
<h2>13.2 - Unterschiedliche Audiotypen abspielen</h2>

<h3>Digitalisiertes Audio</h3>

<h4>Verlustfreie Audioformate (AU, PCM, WAV, FLAC, TTA)</h4>

Einige der verlustfreien Audioformate können ohne Software von
Drittanbietern abgespielt werden - vorausgesetzt die Software kennt
die Kodierung des Formats.
Diese Formate sind unter anderem Sun audio (AU), rohe PCM-Dateien
(ohne Header) und RIFF-WAV-Dateien.
<p>
Wenn Du vorhast, eine solche Datei abzuspielen, solltest du die genauen
Parameter kennen: Kodierungstyp, Anzahl der Kanäle, die Abtastrate
und die Bitanzahl der Abtastung.
Wenn du diese Informationen nicht hast, kannst Du sie mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=file&amp;sektion=1">file(1)</a>
feststellen:

<blockquote><pre>
$ <strong>file music.au</strong>
music.au:  Sun/NeXT audio data: 16-bit linear PCM, stereo, 44100 Hz
</pre></blockquote>

<blockquote><pre>
$ <strong>file music.wav</strong>
music.wav: Microsoft RIFF, WAVE audio data, 16 bit, stereo 44100 Hz
</pre></blockquote>

Die verbleibenden Dinge, die man noch über dieses Beispiel wissen
sollte, ist dass die Datei die Littleendian-Byteanordnung und
»signed linear quantization« nutzt. Das kannst du heraus finden,
indem du den Header mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hexdump&amp;sektion=1">hexdump(1)</a>
ansiehst. Wenn du headerlose (Raw-)Dateien hast, gibt es keine
Möglichkeit, diese Parameter im  Vorfeld zu bestimmen.
Setze die folgenden Parameter mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audioctl&amp;sektion=1">audioctl(1)</a>.

<blockquote><pre>
play.encoding=slinear_le
play.rate=44100
play.channels=2
play.precision=16
</pre></blockquote>

Leite als nächstes die Audiodatei durch ein Soundlaufwerk:

<blockquote><pre>
$ <strong>cat music.au > /dev/sound</strong>
</pre></blockquote>

Wenn du die korrekten Werte gesetzt hast, solltest du das hören, was du
erwartet hattest.

<p>
Merke: Benutze immer <tt>/dev/sound</tt> (nicht <tt>/dev/audio</tt>),
wenn du willst, dass die mit audioctl eingerichteten Werte auch
gesichert bleiben.

<p>
Es gibt noch andere Programme, die du benutzten kannst; beispielsweise
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1">aucat(1)</a>
und <tt>audio/waveplay</tt>, die in den Packages und Ports zur Verfügung
stehen. Selbstverständlich gibt es noch andere, populäre Software wie
XMMS, die in der Lage ist, solche Dateien und auch andere Audioformate
abzuspielen.

<p>
Abgesehen von dem zuvor Beschriebenen gibt es Audioformate, die
verlustfreie Kompression verwenden. Beispiele für solche Formate sind:
»Free Lossless Audio Codec« (FLAC) und TTA. Die FLAC-Implementation
wurde auf OpenBSD portiert und kann unter <tt>audio/flac</tt> in den
Ports oder Packages gefunden werden.

<h4>Audioformate mit verlustbehafteter Komprimierung (Ogg Vorbis, MP3,
WMA, AAC)</h4>

Verlustfreie Kompressionsverfahren werden oft in Audio- oder anderen
Mediadateien verwendet.
Die Idee dahinter ist, eine Menge Daten während der Komprimierung
zu verwerfen. Diese Verfahren reduzieren den Platzbedarf und die
Anforderungen an die Bandbreite. Das Ergebnis ist sowohl eine geringere
Datenmenge als auch eine noch akzeptable Abspielqualität.

<p>
Ein gutes Beispiel hierfür ist das freie, offene und unpatentierte
<a href="http://www.vorbis.com/">Ogg-Vorbis</a>-Format.
Um Ogg-Vorbis-Dateien abzuspielen, kannst du das Programm ogg123
benutzen, welches im Package <tt>audio/vorbis-tools</tt> enthalten ist.
Zum Beispiel:

<blockquote><pre>
$ <strong>ogg123 music.ogg</strong>

Audio Device:   Sun audio driver output

Playing: music.ogg
Ogg Vorbis stream: 2 channel, 44100 Hz
Time: 00:02.95 [02:21.45] of 02:24.40  (133.1 kbps)  Output Buffer  87.5%
</pre></blockquote>

Selbstverständlich existieren Ogg-Vorbis-Plugins auch für andere
Software.

<p>
Ein weiteres sehr populäres Beispiel ist die »MPEG-1 Audio Layer 3«-
(MP3-) Komprimierung, welche - warum auch immer - einige Lizenzen und
Patente hat. MP3-Dateien können von vielen Programmen wiedergegeben
werden. Schau einfach mal durch die <tt>audio</tt>-Sektion der
Portliste oder der Packages.

<p>
Was ist mit dem proprietären »Windows Media Audio«- (WMA-) Format?
Dateien solchen Formates können mittels <tt>x11/mplayer</tt>
abgespielt werden, welches das
<a href="http://ffmpeg.sourceforge.net">FFmpeg</a>-Framework nutzt.

<p>
Ein guter Startpunkt, um mehr über Audiodateiformate zu lernen, ist
dieser Wikipedia-Artikel:
<a href="http://en.wikipedia.org/wiki/Audio_file_format">Audio file formats</a>.

<h4>Mit Soundgeräten arbeiten, die eine feste Rate haben</h4>

Einige Soundgeräte können nur mit festen Samplerates arbeiten. Zum
Beispiel könnte es sein, dass du versuchst, eine 22050-Hz-Datei mit
einem Soundchip abzuspielen, der nur 48000 Hz verarbeiten kann.

<p>
Es gibt Audiowerkzeuge in der Packages- und Ports-Collection, die
dieses Problem angehen, indem sie ein Rateresampling durchführen.
Zum Beispiel hat <tt>x11/mplayer</tt> eine Option namens
<tt>-srate</tt>, mit der die gewünschte Samplerate eingestellt werden
kann. Du solltest diese dann auf die von deinem Soundgerät setzen.
KDEs <tt>artsd</tt> und einige Spiele unterstützen ähnliche Optionen.
Lies die Dokumentation deiner spezifischen Audioanwendung, um
herauszufinden, ob ein Rateresampling unterstützt wird.


<h3>Künstlich erzeugter Klang</h3>

<h4>MIDI</h4>

Das »Musical Instrument Digital Interface«-Protokoll (MIDI),
wird über <a href="#midi">MIDI-Devices</a> verarbeitet.
Wenn du keinen MIDI-Synthesizer hast, aber dennoch eine
Standard-MIDI-Datei (»standard MIDI file«, SMF) abspielen möchtest,
kannst du Software einsetzen, die MIDI-Daten rendert und aus ihnen
Audiodateien erstellt.
Standardmäßig rendert der <tt>audio/timidity</tt>-Port MIDI-Dateien
und spielt sie auf einem Audiodevice ab:

<blockquote><pre>
$ <strong>timidity file.mid</strong>
</pre></blockquote>

<h4>MOD</h4>

Ein Soundtrackermodul ist ein binäres Format, welches Audiosamples
in einer geordneten Befehlsreihenfolge mischt. Dies macht es möglich,
eher lange Stücke digitalisierter Musik in einer vernünftigen Qualität
abzuspielen.

<p>
Der einfachste Weg, deine favorisierten MOD-Dateien unter OpenBSD
abzuspielen, ist wahrscheinlich, die XMMS-Software zu benutzen. Diese
ist in den Ports und Packages verfügbar.
Du solltest das Subpackage <tt>-mikmod</tt> installieren, damit XMMS
die MikMod-Bibliothek nutzen kann, welche das MOD-, S3M-, IT- und
XM-Modul-Format unterstützt.

<p>
Du kannst darüber hinaus noch andere sogenannte Tracker in der
<tt>audio</tt>-Ports- und Packagesektion finden. Beispiele hierfür
sind tracker und soundtracker. Mit diesen Trackern kannst du
nicht nur Dateien abspielen, sondern auch eigene Module erstellen.
Beachte jedoch, dass nicht jedes Trackerformat von den Programmen
in den Ports unterstützt wird.
Du bist aber stets willkommen, deinen favorisierten Tracker als
<a href="../../de/porting.html">Port hinzuzufügen</a>.


<a name="playCD"></a>
<h2>13.3 - Wie kann ich Audio-CDs unter OpenBSD abspielen?</h2>

Um eine Audio-CD über den analogen Ausgang deines CD-ROM-Laufwerks
abzuspielen, kannst du:
<ul>
<li>Den Kopfhörerausgang benutzen. Dieser ist i.&nbsp;d.&nbsp;R. an der
Vorderseite des Laufwerks zu finden.
<li>Den Audioausgang an den Ausgang deiner Audiokarte verbinden. Ja,
das ist eine zusätzliche Verbindung zum Daten- (SCSI/IDE) und
Stromanschluss.
</ul>

<p>
Ein nettes Kommandozeilenprogramm mit dem Namen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1">cdio(1)</a>
wurde mit in das Standardsystem übernommen. Wird es ohne Parameter
aufgerufen, arbeitet es im interaktiven Modus. Willst du die CD gleich
abspielen lassen, dann benutze:

<blockquote><pre>
$ <strong>cdio play</strong>
</pre></blockquote>

<p>
Beachte, dass es vom ersten CD-ROM-Laufwerk liest. Standard ist
<tt>cd0</tt>. Beachte auch, dass der aktive Benutzer auch die nötigen
Rechte besitzt, um vom CD-ROM-Laufwerk lesen zu können (z.&nbsp;B.
<tt>/dev/rcd0c</tt>). Da das Laufwerk standardmäßig nur von root und der
Gruppe operator gelesen werden kann, solltest du der Einfachheit halber
den Benutzer zur Gruppe operator hinzufügen, indem du die Zeile der
Gruppe in <tt>/etc/group</tt> anpasst. Alternativ dazu kannst du die
Rechte einfach anpassen.

<p>
Beachte, dass du eventuell den CD-Input des Mixers einschalten musst.
Der tatsächliche Name des Inputs variiert von System zu System genau so,
wie es bei der Ausgabe der Fall ist. Das Kommando wird aber diesem
ähneln:

<blockquote><pre>
$ <strong>mixerctl inputs.cd.mute=off</strong>
</pre></blockquote>

<p>
Es sei erwähnt, dass es eine Vielzahl X11-basierter Spieler in der
Ports- und Packagekollektion gibt, falls du lieber eine schöne GUI
magst. Sieh einfach mal in der entsprechenden <tt>audio</tt>-Sektion
nach.


<a name="recordaudio"></a>
<h2>13.4 - Kann ich OpenBSD benutzen, um Audiostücke
aufzuzeichnen?</h2>

Ja. Um das zu tun, kannst du /dev/sound oder /dev/audio als
Eingabelaufwerk benutzen.
<p>
Schaue dir zuerst die relevanten Aufnahmeparameter mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audioctl&amp;sektion=1">audioctl(1)</a>
an.
Zum Beispiel:

<blockquote><pre>
record.encoding=mulaw
record.rate=8000
record.channels=1
record.precision=8
</pre></blockquote>

Hier benutze ich uneinheitliche Unterteilungen mit dem
mu-law-Algorithmus, einem Kanal, einer Samplingrate von 8000 Hz und
8 Bit je Sample. Die Algorithmen mu-law und A-law sind besonders
hilfreich bei der Digitalisierung von Sprachsignalen, da sie eine höhere
Effizienz bei der Kodierung haben, d.&nbsp;h. dass die Qualität der
Sprachsamples bei einer gegebenen Anzahl Bits vergleichsweise
besser sein wird. Oder anders herum kann eine vorgegebene Qualität
mit vergleichsweise weniger Bits realisiert werden.

<p>
Solltest du dich entscheiden, die zuvor genannten Werte (nur diese!) zu
verwenden, so kannst du das /dev/audio-Laufwerk benutzen, welches diese
Werte standardmäßig schon verwendet; die Werte müssen nicht extra
gesetzt werden.

<p>
Stelle als nächstes sicher, dass das richtige Quelllaufwerk gewählt ist
und die Quelldatei ungedämpft ist.
Du kannst die erforderlichen Parameter mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mixerctl&amp;sektion=1">mixerctl(1)</a>
setzen.
Als Beispiel:

<blockquote><pre>
inputs.mic.mute=on
inputs.mic.preamp=on
inputs.mic.source=mic0
record.source=mic
record.volume=255,255
record.volume.mute=off
record.mic=0
record.mic.mute=off
</pre></blockquote>

In diesem Beispiel habe ich von einem Mikrofon aufgenommen.
Vorverstärkung ist aktiviert. Es ist sonst möglich, dass der
aufgenommene Klang sehr leise ist.

<p>
Benutze für die eigentliche Aufnahme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cat&amp;sektion=1">cat(1)</a>
oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>:

<blockquote><pre>
$ <strong>dd if=/dev/audio of=myvoice.raw</strong>
</pre></blockquote>

Drücke [STRG]-C, um die Aufnahme zu beenden.
Die Ausgabe ist eine rohe Folge von Bytes.
Dieser Sound kann abgespielt werden, wie es in der Sektion
<a href="#playaudio">Unterschiedliche Audiotypen abspielen</a>
beschrieben wird.
Für einen schnellen Test (in Annahme der korrekten Parameter):

<blockquote><pre>
$ <strong>dd if=myvoice.raw of=/dev/audio</strong>
</pre></blockquote>

<p>
Es sei nochmal erwähnt: Wenn du andere Kodierungsparameter setzt,
solltest du das /dev/sound-Laufwerk benutzen. Weitere Beispiele für
Kodierungsparameter:

<blockquote><pre>
record.encoding=slinear_le
record.rate=22050
record.channels=2
record.precision=8
</pre></blockquote>

Dies wird zu einer PCM führen, die »signed linear (uniform)
quantization« bei einer Samplingrate von 22050 Hz in Stereo beinhaltet,
die in einer Littleendian-Bytereihenfolge gespeichert wird, und 8 Bits
verwendet, um ein Sample wiederzugeben (2^8 = 256
Quantifizierungsebenen).

<p>
<b>Hinweis</b>:
Du möchtest deine Aufnahme, die jetzt im rohen Format (ohne Header)
vorliegt, in ein Format konvertieren, mit dem du sie dann besser
weiterverarbeiten kannst. Lies <a href="#convert">FAQ 13 -
Konvertierung</a>, um mehr darüber zu erfahren.

<a name="midi"></a>
<h2>13.5 - Wie verwende ich meine MIDI-Instrumente?</h2>

Das »Musical Instrument Digital Interface«- (MIDI) Protokoll bietet
standardisierte und effiziente Hilfsmittel, um musikalische
Aufführungsinformationen als elektronische Daten zu repräsentieren.
MIDI-Daten enthalten lediglich Anweisungen für einen Synthesizer,
um Klänge abzuspielen, statt die Musik an sich.
Weitere Informationen:
<a href="http://www.harmony-central.com/MIDI/Doc/tutorial.html">Tutorial
on MIDI and Music Synthesis</a>

<!-- <h3>Devices setup</h3> --->

<p>
Um MIDI-Daten abspielen zu können, muss ein Synthesizer über einen
MIDI-Port an der Maschine angeschlossen sein. Dementsprechend wird
auch ein MIDI-Instrument benötigt, um MIDI-Daten aufzuzeichnen
(z.&nbsp;B. ein MIDI-Keyboard). Auf einigen Soundkarten befinden sich
eingebettete MIDI-Synthesizer, die als MIDI-Ports erkannt werden.
Fortgeschrittene MIDI-Instrumente können mehrere Unterkomponenten
enthalten (Synthesizer, Keyboards, Mischpulte etc.), diese werden
unter OpenBSD als weitere MIDI-Ports aufgelistet.

<p>
Wenn du OpenBSD bereits in Betrieb genommen hast, schau in der Ausgabe
des dmesg(8)-Kommandos nach, welche MIDI-Ports gefunden wurden. Eine
Beispielauflistung der MIDI-Ports in einer Ausgabe von dmesg ist:

<blockquote><pre>
midi0 at pcppi0: &lt;PC speaker&gt;
umidi0 at uhub2 port 2 configuration 1 interface 0 "Roland Roland XV-2020" rev 1.10/1.00 addr 2
midi1 at umidi0: &lt;USB MIDI I/F&gt;
umidi1 at uhub1 port 2 configuration 1 interface 1 "Evolution Electronics Ltd. USB Keystation 61es" rev 1.00/1.25 addr 3
midi2 at umidi1: &lt;USB MIDI I/F&gt;
</pre></blockquote>

Es werden drei MIDI-Ports aufgelistet, dabei handelt es sich um:

<ul>
<li> <tt>/dev/rmidi0</tt> - den PC-Speaker
<li> <tt>/dev/rmidi1</tt> - über USB angeschlossenen Synthesizer
<li> <tt>/dev/rmidi2</tt> - ein MIDI-Masterkeyboard
</ul>

Um dein MIDI-Keyboard zu testen, kannst du das Werkzeug <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hexdump&amp;sektion=1"
>hexdump(1)</a> verwenden. Die gespielten MIDI-Daten können wie folgt
angezeigt werden:

<blockquote><pre>
$ <strong>hexdump -e '1/1 "%02x\n"' &lt;/dev/rmidi2 </strong>
90
3c
71
...
</pre></blockquote>

Die Ausgabe des Keyboards kann wie folgt direkt zur Eingabe des
Synthesizers weitergeleitet werden:

<blockquote><pre>
$ <strong>cat -u /dev/rmidi1 &gt;/dev/rmidi2</strong>
</pre></blockquote>

Nun kannst du über den Synthesizer hören, was du auf dem MIDI-Keyboard
spielst.
Die Informationen darüber, was du gerade spielst, werden tatsächlich
in Echtzeit von /dev/rmidi1 an /dev/rmidi2 gesendet.
Bitte lies die <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=midi&amp;sektion=4"
>midi(4)</a>-Manualseite für weitere Informationen.

<!-- <h3>Playing, recording MIDI sequences</h3> --->

<p>
Das Hauptwerkzeug zum Abspielen von Standard-MIDI-Dateien ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=midiplay&amp;sektion=1"
>midiplay(1)</a>. Standard-MIDI-Dateien abspielen ist ganz einfach
möglich (in diesem Beispiel über den Synthesizer):

<blockquote><pre>
$ <strong>midiplay -d 1 file.mid</strong>
</pre></blockquote>

Beachte, dass wir die MIDI-Gerätenummer 1 (d.&nbsp;h.
<tt>/dev/rmidi1</tt>) als Parameter angegeben haben, da standardmäßig
Gerätenummer 0 verwendet wird.

<p>
Um MIDI-Dateien aufzunehmen, kannst du das <tt>smfrec</tt>-Werkzeug
verwenden, das sich im <tt>audio/midish</tt>-Port befinden, zum
Beispiel:

<blockquote><pre>
$ <strong>smfrec -d /dev/rmidi1 -i /dev/rmidi2 file.mid</strong>
</pre></blockquote>

Hiermit wird aufgezeichnet, was auf dem Keyboard (<tt>/dev/rmidi2</tt>)
gespielt wird , während es in Echtzeit an den Synthesizer
(<tt>/dev/rmidi1</tt>) gesendet wird, so dass du hören kannst, was
du gerade spielst. Komplizierte Anwendungen wie Editieren, Routing
und Mixen sowie Transformieren von MIDI-Daten können mit dem
<tt>rmidish</tt>-Werkzeug im <tt>audio/midish</tt>-Port realisiert
werden.

<a name="lossyaudio"></a>
<h2>13.6 - Was gibt es über Ogg-Vorbis- und MP3-Encoding zu
sagen?</h2>

Diese Formate wurden bereits in der Sektion
<a href="#playaudio">Unterschiedliche Audiotypen abspielen</a>
aufgeführt. In dieser Sektion werden wir eine kurze Einführung in die
Kodierung solcher Dateien geben. Wenn du interessiert bist, etwas über
die Kompressionscodecs zu lernen, kannst die Wikipedia-Artikel über
<a href="http://en.wikipedia.org/wiki/Vorbis">Vorbis</a> und
<a href="http://en.wikipedia.org/wiki/MP3">MP3</a> lesen.

<h3>Ogg Vorbis</h3>

Die Kodierung von einem rohen, WAV- oder AIFF-Audioformat in
<a href="http://www.vorbis.com/">Ogg Vorbis</a> kann mit dem
Programm <b>oggenc</b> durchgeführt werden, welches in dem
Package <tt>audio/vorbis-tools</tt> enthalten ist. Dies kann aus den
OpenBSD-Ports oder -Packages bezogen werden.

<p>
Nehmen wir an, du hättest eine Anzahl WAV-Dateien, die bereit sind,
kodiert zu werden - beispielsweise dein Lieblingsalbum, welches du von
der CD extrahiert hast.
Um alle diese Dateien mit einer ungefähren Bitrate von 192 kbps zu
kodieren, könntest du das folgende Kommando verwenden:
<blockquote><pre>
$ <strong>oggenc *.wav -b 192</strong>
</pre></blockquote>

Wenn der Vorgang beendet ist, wirst du einen Satz .ogg-Dateien im
aktuellen Verzeichnis finden.
Weitere ausführliche Beispiele sowie Optionen für die Kodierung sind
im oggenc-Manual zu finden.

<h3>MPEG-1 Audio Layer 3 (MP3)</h3>

Solltest du das MP3-Format nutzen wollen, so kannst du den
<a href="http://mp3dev.org/">»Lame ain't an MP3 encoder« (LAME)</a>
benutzen, ein erklärendes Programm um mehr über MP3-Kodierung zu
lernen. Lame ist im OpenBSD-Ports-Tree enthalten.
Wegen der MP3-Patente ist das Package nicht auf den
<a href="../../de/orders.html">offiziellen CD-Sets</a> zu finden.

<p>
Nachfolgend ein kleines Beispiel einer Kodierung einer WAV-Datei mit
einer Bitrate von 192 kbps:
<blockquote><pre>
$ <strong>lame -b 192 track01.wav track01.mp3</strong>
</pre></blockquote>

Für alle Optionen und Details, schaue bitte in das mitgelieferte
Manual zu Lame.


<a name="playDVD"></a>
<h2>13.7 - Wie kann ich Video-DVDs unter OpenBSD abspielen?</h2>

OpenBSD unterstützt DVD-Medien über das ISO-9660-Dateisystem, das
ebenfalls auf CD-ROMs genutzt wird, und - seit OpenBSD 3.8 - ebenfalls
über das neuere
<a href="http://www.osta.org/specs/">Universal-Disk-Format- (UDF-)</a>
Dateisystem, das man auf einigen DVDs vorfinden kann.
Die meisten DVD-Videos und DVD-ROMs verwenden jedoch das
UDF-Bridgeformat, welches eine Kombination von DVD-MicroUDF (ein Teil
von UDF 1.0) und dem ISO-9660-Dateisystem ist. Es wird als
Abwärtskompatibilität genutzt.

<p>
Da die meisten Computer mit DVD-ROM-Laufwerken softwareseitige
Dekodierung verwenden ist es empfehlenswert, mindestens einen Pentium
II mit 350 MHz zu verwenden, um eine gute Wiedergabequalität zu
erhalten.

<p>
Einige populäre Mediaprogramme, die DVDs abspielen können, wurden auf
OpenBSD portiert. Beispiele sind
<a href="http://www.dtek.chalmers.se/groups/dvd/">ogle</a>,
<a href="http://www.mplayerhq.hu/">mplayer</a>,
<a href="http://www.xinehq.de/">xine</a> und
<a href="http://kaffeine.sourceforge.net/">kaffeine</a>.
Bitte lies die Installationsanweisungen, die im entsprechenden Package
mitgeliefert werden, denn die Programme könnten vorher noch
konfiguriert werden müssen.
Mit diesen Programmen ist es möglich, die DVD durch direkten Zugriff
auf die Rohdaten abzuspielen.
Selbstverständlich kann man die DVD auch zuerst mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_cd9660&amp;sektion=8">mount_cd9660(8)</a>
mounten und sie dann von diesem oder von einem anderen gemounteten
Dateisystem abspielen.

<p>
<b>Anmerkung:</b>
<ul>
<li>Fast alle DVDs, die du kaufst, sind mit dem »Content Scrambling
System« (CSS) verschlüsselt.
Um in der Lage zu sein, auch diese abspielen zu können, kannst du die
<b>libdvdcss</b>-Bibliothek benutzen. Sie kann ebenfalls als Port oder
Package installiert werden.

<li>Bedenke, dass ein Ländercode auf der DVD sein könnte. Dies sollte
allerdings kein Problem beim Abspielen mit dem Computer darstellen.
</ul>


<a name="burnCD"></a>
<h2>13.8 - Wie brenne ich CDs und DVDs?</h2>

<a name="burnIntro"></a>
<h3>13.8.1 - Einführung und grundlegende Einrichtung</h3>

Stelle zunächst sicher, dass dein CD/DVD-Brenner von deinem Kernel
erkannt und konfiguriert worden ist.
Die meisten SCSI-Laufwerke werden unterstützt. IDE/ATAPI- und
USB-Laufwerke werden durch SCSI-Emulation unterstützt. Dein Laufwerk
kannst du schnell in der Ausgabe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
finden.
Suche einfach Zeilen, die mit cd beginnen. Als Beispiel:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;TOSHIBA, CD-ROM XM-5702B, 2826&gt; SCSI0 5/cdrom removable
cd1 at scsibus1 targ 4 lun 0: &lt;PLEXTOR, CD-R PX-R412C, 1.04&gt; SCSI2 5/cdrom removable
</pre></blockquote>

<h4>Aber <tt>cdrecord -scanbus</tt> funktioniert nicht!</h4>

Das stimmt. OpenBSD nutzt unterschiedliche Namensplatzhalter für
Laufwerke als das Betriebssystem, worauf das cdrecord-Programm
geschrieben worden ist. Alle konfigurierten Laufwerke sollten in der
Ausgabe von dmesg - wie soeben gezeigt - erscheinen. Die Information,
die du brauchst, ist hier zu finden.

<h4>Error: <tt>mount_cd9660: /dev/cd2c on /mnt/cdrom: No such file or directory</tt></h4>

Standardmäßig erstellt der OpenBSD-Installer nur 2 Laufwerkseinträge:
für <tt>cd0</tt> und <tt>cd1</tt>.
Um ein <tt>cd2</tt>-Laufwerk zu benutzen, musst du den entsprechenden
Laufwerkseintrag selbst erstellen.
Der empfohlene Weg, dies zu tun, ist das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=MAKEDEV&amp;sektion=8">MAKEDEV(8)</a>-Skript
(wähle die entsprechende Plattform aus):

<blockquote><pre>
# <strong>cd /dev</strong>
# <strong>./MAKEDEV cd2</strong>^
</pre></blockquote>

In den folgenden Teilen werden wir auf den CD/DVD-Brenner meistens
durch die »<i>rohe</i> Charaktergerätedatei« und <b>nicht</b> das
<i>block</i>-Laufwerk zugreifen.

<h4>CD/DVD-Brenneroperationen überprüfen</h4>

Es ist empfohlen, stets zu prüfen, ob der CD/DVD-Brenner korrekt
arbeitet.  In diesem Beispiel benutzen wir diesen USB-2.0-DVD-Brenner:

<blockquote><pre>
cd2 at scsibus2 targ 1 lun 0: &lt;LITE-ON, DVDRW LDW-851S, GS0C&gt; SCSI0 5/cdrom removable
</pre></blockquote>

Benutze ihn, indem du eine CD/DVD darin mountest.
Wenn erwünscht, kannst du auch die Übertragungsrate messen, wenn du
Dateien von dem CD/DVD-Laufwerk auf die Festplatte kopierst.
Das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=time&amp;sektion=1">time(1)</a>-Kommando
wird ein williger Helfer sein.

<p>
Wenn hier irgendwelche Fehler auftreten, ist es weise, diese Fehler
zunächst zu beheben, bevor du probierst, CDs/DVDs zu beschreiben.

<h3>Ich möchte jetzt meine CD beschreiben. Können wir anfangen?</h3>

Bevor wir weitermachen, ein paar Worte darüber, was man berücksichtigen
sollte:

<ul>
<li>Lasse keine Jobs laufen, die intensiv auf die Festplatte zugreifen,
während du eine CD/DVD beschreibst. Dies reduziert die Ausgabe auf
deinen CD/DVD-Brenner. Wenn der Brenner dann zu lange auf die
Ausgabe warten muss, wird ein leerer Puffer verarbeitet. Dieses
Phänomen wird als Pufferunterlauf bezeichnet.
<li>Verhindere während des Schreibvorgangs jegliche Erschütterungen
deines Brenners. Erschütterungen können den Laser von seiner Bahn
abdriften lassen. Die Daten werden so u.&nbsp;U. nicht korrekt
geschrieben.
<li>Nicht jeder DVD-Brenner unterstützt jedes Format; siehe weiter
unten.
</ul>

<a name="writeCD"></a>
<h3>13.8.2 - CDs brennen</h3>

<h4>Daten-CD-ROMs erstellen</h4>

Zunächst wirst du ein ISO-9660-Dateisystem auf der CD-ROM erstellen
wollen. Um das zu tun, kannst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mkhybrid&amp;sektion=8">mkhybrid(8)</a>
aus dem Basissystem oder das mkisofs-Werkzeug verwenden, das sich im
cdrtools-<a href="faq15.html#PkgMgmt">Package</a> befindet und mit
größeren Dateistrukturen besser umgehen kann. Im folgenden Beispiel
verwenden wir mkhybrid - der Aufruf von mkisofs ist sehr ähnlich.

<p>
Als Beispiel sagen wir, dass wir die OpenBSD-Kernelquellen in einem
ISO-9660-Image speichern wollen.

<blockquote><pre>
$ <strong>mkhybrid -R -o sys.iso /usr/src/sys</strong>

Using ALTQ_RMC.000;1 for  /usr/src/sys/altq/altq_rmclass_debug.h (altq_rmclass.h)
...
Using IEEE8021.00H;1 for  /usr/src/sys/net80211/ieee80211_amrr.c (ieee80211.c)
 10.89% done, estimate finish Sat Nov  3 08:01:23 2007
 21.78% done, estimate finish Sat Nov  3 08:01:28 2007
...
 87.12% done, estimate finish Sat Nov  3 08:01:31 2007
 98.01% done, estimate finish Sat Nov  3 08:01:32 2007
Total translation table size: 0
Total rockridge attributes bytes: 896209
Total directory bytes: 2586624
Path table size(bytes): 11886
Max brk space used 0
45919 extents written (89 Mb)
</pre></blockquote>

<p>
Die Option <tt>-R</tt> sagt <tt>mkhybrid</tt>, dass die
Rock-Ridge-Erweiterungen in dem ISO-9660-Image zu erstellen sein werden.
Das »Rock Ridge Interchange«-Protokoll wurde entwickelt, um die
POSIX-Dateisystemsemantik in ISO-9660-Dateisystemen zu unterstützen
(z.&nbsp;B. lange Dateinamen, Benutzerrechte, Datei- und Softlinks,
Laufwerksknoten, tiefe Dateihierachien [mehr als 8 Unterverzeichnisse]
etc.)

<p>
Wenn du willst, dass lange Dateinamen auf deiner CD-ROM unter DOS und
Windows gelesen werden können, dann solltest du die Option <tt>-J</tt>
benutzen, um die Joliet-Erweiterung dem ISO-9660-Image hinzuzufügen.

<p>
Nachdem das Dateisystem erstellt worden ist, kannst du es überprüfen,
indem du das
<a href="faq14.html#MountImage">ISO-9660-Image mountest</a>.
Wenn das in Ordnung ist, ist alles bereit, um die CD-R(W) zu brennen.
Am einfachsten ist es, hierfür das <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1"
>cdio(1)</a>-Werkzeug zu verwenden.

<p>
Wenn du wiederbeschreibbare CDs verwendest (wie zum Beispiel CD-RW),
dann musst du das Medium erst löschen, bevor du es brennen kannst.

<blockquote><pre>
# <strong>cdio -f cd1c blank</strong>
</pre></blockquote>

Du kannst das zuvor erstellte ISO-Image nun auf eine unbeschriebene
CD-R(W) brennen. Dazu kannst du folgendes Kommando verwenden:

<blockquote><pre>
# <strong>cdio -f cd1c tao sys.iso</strong>
</pre></blockquote>

Mit den gerade verwendeten Optionen sagen wir cdio, dass das zweite
CD-ROM-Laufwerk als Brenner genutzt werden soll.

<p>
Um zu überprüfen, ob die CD korrekt gebrannt worden ist, kannst du sie
mounten und prüfen, ob die Daten entsprechend vorhanden sind.
Um das Dateisystem zu mounten, solltest du das <i>block</i>-Laufwerk
für das CD-ROM-Laufwerk benutzen, welches in diesem Fall auch der
CD-Brenner ist.

<blockquote><pre>
# <strong>mount /dev/cd1c /mnt/cdrom</strong>
</pre></blockquote>


<h4>Audio-CDs erstellen</h4>

Um Audio-CDs zu brennen, kannst du ebenfalls <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1"
>cdio(1)</a> mit der Option <tt>tao -a</tt> verwenden.

<p>
Als Beispiel werde ich eine Sicherungskopie von einer meiner Musik-CDs
erstellen. Dazu sind zwei Schritte nötig:

<ol>
<li>Ziehe die Audiotracks von der originalen CD. Als Beispiel:
<blockquote><pre>
# <strong>cdio -f cd1c cdrip</strong>
</pre></blockquote>

Dieses Kommando extrahiert eine Reihe WAV-Dateien von deinem zweiten
CD-ROM-Laufwerk auf deine Festplatte.
<li>Schreibe die Audiotracks auf eine leere CD. Zum Beispiel:
<blockquote><pre>
# <strong>cdio -f cd1c tao -a *.wav</strong>
</pre></blockquote>
</ol>


<a name="writeDVD"></a>
<h3>13.8.3 - DVDs brennen</h3>

Es gibt einige wichtige Dinge, die du über DVDs wissen solltest, bevor
du anfängst, deine eigenen DVDs zu brennen.

<p>
<b>Wichtige Anmerkungen:</b>
<ul>
<li>Wenn du wirklich alles über DVDs wissen möchtest, empfehle ich dir
das wirklich ausführliche
<a href="http://www.dvddemystified.com/dvdfaq.html">DVD-FAQ</a> zu
studieren.
<li>In dieser Sektion konnten wir nur begrenzt testen. Außerdem haben wir
sicherlich nicht alle möglichen Kombinationen von Rohlingen und Brennern
probieren können. Bisher hatten wir keine positiven Erfahrungen mit
irgendeinem der weiter unten aufgeführten DVD-Formaten gemacht -
wir haben auch noch von keinen Erfolgserlebnissen gehört.
Wir würden uns aber freuen, wenn du uns
<a href="mailto:faq@openbsd.org">deine Erfahrungen zu dieser Sektion
mitteilen würdest</a>.
</ul>

<h4>Unterschiedliche DVD-Formate</h4>

Es gibt eine Menge unterschiedliche DVD-Formate. Üblicherweise
werden die Formate DVD-R, DVD-RW, DVD+R und DVD+RW verwendet (R
bedeutet, dass die DVDs einmal beschreibbar sind. RW bedeutet, dass
sie einige tausendmal beschrieben werden können).
Dies sind stark konkurrierende Standards.

<p>
Einen großen Unterschied stellt das DVD-RAM-Format dar, welches
hauptsächlich als Datenlaufwerk entwickelt worden ist und erweiterte
Paketschreibfunktionen bietet, was es möglich macht, es als eine Art
optische Festplatte zu nutzen. Für die Benutzung im Zusammenhang mit
Video wird DVD-RAM nicht empfohlen - das Format ist nicht kompatibel zu
einem normalen DVD-Player.

<p>
Der sinnvollste Weg ist es, Medien zu verwenden, die zu deinem
DVD-Brenner passen. Wenn du zu anderen DVD-Spielern kompatibel sein
möchtest, dann gehe sorgfältig vor und lies
<a href="http://www.dvddemystified.com/dvdfaq.html#4.3.1">diese
Sektion</a> der DVD-FAQ.

<h4>DVD-Brenngeschwindigkeit</h4>

Es könnte hilfreich sein, festzuhalten, dass die Angabe der
DVD-Geschwindigkeit anders ist als die einer CD-ROM.
Die folgende Tabelle gibt einen Überblick:
<p>
<table border="1" style="empty-cells: show;">
<tr align="center">
<td>DVD-Lese/Schreibgeschwindigkeit</td>
<td>Übertragungsrate (MB/s)</td>
<td>Äquivalente CD-R(W)-Lese/Schreibgeschwindigkeit</td>
</tr>
<tr align="center">
<td>1x</td>
<td>1,32</td>
<td>9x</td>
</tr>
<tr align="center">
<td>2x</td>
<td>2,64</td>
<td>18x</td>
</tr>
<tr align="center">
<td>4x</td>
<td>5,28</td>
<td>36x</td>
</tr>
<tr align="center">
<td>8x</td>
<td>10,57</td>
<td>72x</td>
</tr>
</table>

<p>
Wie der Tabelle zu entnehmen ist, ist die Transferrate relativ hoch und
du solltest prüfen, ob dein Bus (SCSI, [E]IDE/ATAPI, USB) genug
Leistung bietet, um den Durchsatz zu gewährleisten. Besonders die
älteren USB-1.0- und -1.1-Schnittstellen arbeiten mit langsameren
Übertragungsraten wie 1,5 MBit/s und 12 MBit/s.
Das bedeutet, dass USB 1.0 einen maximalen Durchsatz von 178,8 kByte/s
und USB 1.1 einen maximalen Durchsatz von 1,43 MB/s hat.
USB 2.0 ist mit 480 MBit/s bzw. 1,43 MB/s um einiges schneller.
Allgemein kann man sagen, dass die Geschwindigkeit von SCSI- und
(E)IDE/ATAPI-Bussen völlig ausreichend ist.

<h4>Brennen der DVD</h4>

Grundsätzlich kann man sagen, dass das Brennen von DVDs ähnlich dem
Brennen von CD-ROMs ist. Die verwendete Software ist jedoch
unterschiedlich. Derzeit ist die beste Möglichkeit <b>growisofs</b> aus
dem <tt>sysutils/dvd+rw-tools</tt>-Package. Dieses Programm schreibt ein
ISO-9660-Image auf die DVD. Es werden alle wiederbeschreibbaren
DVD-Formate von den dvd+rw-tools unterstützt.

<p>
Für den Fall, dass du mehr über das Medium in deinem DVD-Brenner
(z.&nbsp;B. wenn du die Informationsbeilagen verloren hast oder einfach
nur - wie ich - schlecht organisiert bist) erfahren möchtest, kannst du
das Programm <b>dvd+rw-mediainfo</b> benutzen.

<!--blockquote><pre>
$ <strong>dvd+rw-mediainfo /dev/rcd2c</strong>
INQUIRY:                [LITE-ON ][DVDRW LDW-851S  ][GS0C]
GET [CURRENT] CONFIGURATION:
 Mounted Media:         1Ah, DVD+RW
 Current Write Speed:   4.0x1385=5540KB/s
 Write Speed #0:        4.0x1385=5540KB/s
 Write Speed #1:        2.4x1385=3324KB/s
GET [CURRENT] PERFORMANCE:
 Write Performance:     4.0x1385=5540KB/s@[0 -> 0]
 Speed Descriptor#0:    00/0 R@2.4x1385=3324KB/s W@4.0x1385=5540KB/s
 Speed Descriptor#1:    00/0 R@2.4x1385=3324KB/s W@2.4x1385=3324KB/s
READ DVD STRUCTURE[#0h]:
 Media Book Type:       92h, DVD+RW book [revision 2]
 Media ID:              SONY/S11
 Legacy lead-out at:    2295104*2KB=4700372992
READ DISC INFORMATION:
 Disc status:           blank
 Number of Sessions:    1
 State of Last Session: empty
 Number of Tracks:      1
READ TRACK INFORMATION[#1]:
 Track State:           blank
 Track Start Address:   0*2KB
 Free Blocks:           2295104*2KB
 Track Size:            2295104*2KB
READ CAPACITY:          1*2048=2048
</pre></blockquote-->

Es gibt zwei Möglichkeiten, eine DVD zu brennen:
<ul>
<li>Erstelle ein ISO-9660-Image deiner DVD und speichere es auf deiner
Festplatte. Danach brenne dieses Image auf eine DVD.
<li>Schreibe gleich ein ISO-9660-Image von deinen Daten auf die DVD.
</ul>

<p>
Ich habe vorab ein ISO-9660-Image von den OpenBSD-CVS-Modulen (src,
XF4, Ports und www) in meinem /cvs-Verzeichnis auf meiner Festplatte
erstellt. Ich habe das folgende Kommando verwendet, welches dem zum
Erstellen von CD-ROM-Images sehr ähnlich ist.

<blockquote><pre>
$ <strong>mkisofs -R -o cvs.iso /cvs</strong>
</pre></blockquote>

Wenn erwünscht, teste das ISO-9660-Dateisystem, indem du das
<a href="faq14.html#MountImage">Image mountest</a>.
Um dieses Image (über 2 GB) auf eine leere DVD zu brennen, kann man
Folgendes benutzen:

<blockquote><pre>
# <strong>growisofs -dvd-compat -Z /dev/rcd2c=cvs.iso</strong>
Executing 'builtin_dd if=cvs.iso of=/dev/rcd2c obs=32k seek=0'
/dev/rcd2c: pre-formatting blank DVD+RW...
/dev/rcd2c: "Current Write Speed" is 4.1x1385KBps.
  23822336/1545832448 ( 1.5%) @3.9x, remaining 5:19
  42172416/1545832448 ( 2.7%) @3.9x, remaining 5:20
  60522496/1545832448 ( 3.9%) @3.9x, remaining 4:54
...
1504706560/1545832448 (97.3%) @3.9x, remaining 0:07
1523318784/1545832448 (98.5%) @3.9x, remaining 0:04
1541898240/1545832448 (99.7%) @3.9x, remaining 0:00
/dev/rcd2c: flushing cache
/dev/rcd2c: writing lead-out
/dev/rcd2c: reloading tray
</pre></blockquote>

Die Option <tt>-Z</tt> sagt growisofs, dass es eine Initialsession
auf mein DVD-Laufwerk brennen soll, welches an cd2 gebunden ist.
Die Option <tt>-dvd-compat</tt> sagt, dass die DVD geschlossen werden
soll, d.&nbsp;h. keine weiteren Brennvorgänge sind mehr möglich.
Dies sollte eine bessere Kompatibilität zu Video-DVD-Spielern und
älteren DVD-ROM-Einheiten bieten.

<p>Beachte auch, wie growisofs die Geschwindigkeit anzeigt. In diesem
Fall 3,9-fache DVD Geschwindigkeit. Das ist entsprechend der Kombination
des Rohlings und des Brenners, wie auch dvd+rw-mediainfo anzeigt.

<p>
Wenn du zu wenig Platz hast, um vorab das ISO-9660-Image auf deiner
Festplatte zu erstellen, dann kannst du es auch direkt auf die DVD
brennen. Aber zuvor machen wir einen Testlauf, welcher das Erstellen
eines ISO-9660-Images simuliert.

<blockquote><pre>
# <strong>growisofs -dry-run -Z /dev/rcd2c -R /cvs</strong>
</pre></blockquote>

Wenn dieses Kommando erfolgreich ist, dann starte es nochmal ohne
-dry-run.

<blockquote><pre>
# <strong>growisofs -Z /dev/rcd2c -R /cvs</strong>
</pre></blockquote>

<p>
Es ist außerdem möglich, Daten zu einer bereits beschriebenen DVD
hinzuzufügen, indem man die Option -M verwendet. Dann wird eine neue
Session geschrieben.

<blockquote><pre>
# <strong>growisofs -M /dev/rcd2c -R /mydata</strong>
</pre></blockquote>

Für mehr Informationen über growisofs, lies bitte das Manual.

<p>
Wenn du den Brennvorgang abgeschlossen hast, so mounte die DVD und
prüfe, ob alle Daten, die gebrannt werden sollten, auch tatsächlich
vorhanden sind.

<h4>Warum erhalte ich nicht die zu erwartende Brenngeschwindigkeit?</h4>

Anstelle der zuvor beschriebenen Ausgabe könntest du Folgendes sehen:

<blockquote><pre>
   4784128/1545832448 ( 0.3%) @0.7x, remaining 26:50
   7929856/1545832448 ( 0.5%) @0.7x, remaining 29:05
  14123008/1545832448 ( 0.9%) @0.7x, remaining 27:06
...
</pre></blockquote>

was um einiges langsamer ist.
Das bedeutet, dass du aus irgendwelchen Gründen nicht genug
Datendurchsatz auf dem Bus hast, den dein DVD-Brenner verwendet.
In dem vorigen Beispiel war der USB-DVD-Brenner an einer Maschine
angeschlossen, auf der das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ehci&amp;sektion=4">ehci(4)</a>-Laufwerk,
das vom USB-2.0-Controller benutzt wird, nicht korrekt initialisiert
werden konnte. Wie immer bist du herzlich eingeladen, Patches und
Testergebnisse zu erstellen. Der DVD-Brenner fällt also zurück in seinen
USB-1.1-Modus, welcher langsamer ist, und erhält somit einen
reduzierten Datendurchsatz. Allerdings ist USB 1.1 auf 12 MBit/s
begrenzt, was 1,43 MB/s oder 1,08-fache Brenngeschwindigkeit der DVD
bedeutet. Der DVD-Brenner verwendet eine geringere Brenngeschwindigkeit,
um das Risiko von Pufferunterläufen zu reduzieren.

<a name="convert"></a>
<h2>13.9 - Ich möchte meine Mediendateien aber im Format XYZ haben.</h2>

<h3>Zwischen verschiedenen Audioformaten konvertieren</h3>

Lass uns davon ausgehen, dass du die Soundaufnahme aus
<a href="#recordaudio">FAQ 13 - Audioaufnahme</a> weiter verarbeiten
willst. Diese Aufzeichnung wurde im rohen Format abgespeichert. Es
wäre sinnvoll, sie zu konvertieren, da das rohe Format keinen Header
einfügt und die Aufnahmeparameter daher bei jeder Verwendung der Datei
angegeben werden müssten.

<p>
Ein Soundkonvertierungswerkzeug ist <tt>audio/sox</tt>, das über
Packages und Ports zur Verfügung steht.
<b>sox</b> unterstützt AIFF-, AU-, MP3-, Ogg-Vorbis-, RIFF-WAV- und
rohe Formate neben weiteren exotischen Formaten, auf die man treffen
könnte. Es folgt ein Beispiel für die Konvertierung der Aufzeichnung
zum RIFF-WAV-Format.

<blockquote><pre>
$ <strong>sox -U -c 1 -r 8000 -b myvoice.raw myvoice.wav</strong>
</pre></blockquote>

Beachte, dass die angegeben Parameter mit den Parametern übereinstimmen,
die bei der Aufnahme angegeben wurden.
Dies war nur ein Beispiel. Weitere audiobezogene Bibliotheken und
andere Softwareprodukte können für die Audiokonvertierung genutzt
werden.

<p>
<b>Hinweis:</b>
Es ist nicht empfehlenswert, zwischen verschiedenen verlustbehafteten
Kompressionsformaten zu konvertieren. Beispielsweise lassen MP3- und
Vorbis-Formate unterschiedliche Stellen der originalen Audiowaveform
fallen. Solltest du also eine MP3-Datei ins Ogg-Vorbis-Format
konvertieren, dann wird das Resultat sich eventuell schlechter anhören
als die Original-MP3.

<h3>Zwischen verschiedenen Audioformaten konvertieren</h3>

Es ist wichtig, eine klare Grenze zwischen folgenden Eigenschaften
zu ziehen:
<ul>
<li>Das Containerdateiformat - weit verbreitete Beispiele sind
MP4, OGG, MPEG, MOV, AVI, ASF.
<li>Der Videocodec - zum Beispiel MPEG-1, MPEG-2, MPEG-4-kompatible
Codecs (wie z.&nbsp;B. Xvid und DivX), FFmpeg, WMV,&nbsp;... -
lies diesen
<a href="http://en.wikipedia.org/wiki/Video_codec">Wikipedia-Artikel
über Videocodecs</a>, um mehr über sie zu erfahren.
</ul>

Unter OpenBSD ist momentan die Unterstützung für MPEG- und AVI-Container
am ausgereiftesten. Keine Werkzeuge im Ports-Tree können momentan
Stream in MP4-Containern erstellen.

<p>
Zwei oft eingesetzte Werkzeuge sind <tt>multimedia/transcode</tt> und
<b>mencoder</b> (Teil von <tt>x11/mplayer</tt>). Sie verwenden - oder
könnten es - die <b>libavcodec</b>-Bibliothek als Teil des Ports
<tt>graphics/ffmpeg</tt>, dessen Ausgabe gute Qualität hat. Du kannst
selbstverständlich <b>ffmpeg</b> auch gleich direkt verwenden.
Es sollte auch möglich sein, den XviD-Encoder aus
<tt>multimedia/xvidcore</tt> zu nutzen.

<p>
Die Dokumentation, die in Form von Manualseiten und HTML-Dokumenten
in <tt>/usr/local/share/doc</tt> vorliegt, beinhaltet viele Beispiele -
daher wird DRINGEND dazu geraten, diese Dokumentation zu lesen.


<a name="streaming"></a>
<h2>13.10 - Ist es möglich, Streams unter OpenBSD abzuspielen?</h2>

Ja, ist es. Viele Audio- und Videostreams werden auf einer begrenzten
Anzahl Plattformen problemlos funktionieren. Ein paar von ihnen nicht.

<p>
Diese Sektion soll keine ausführliche Liste aller funktionierenden
Streamingformate sein, die auf irgendeiner Hardwarearchitektur
funktionieren. Um mehr darüber zu erfahren, solltest du dich ausgiebig
mit Streamingmedien auseinandersetzen. Eine etwas alte aber dennoch
gute Einführung bietet dieses
<a href="http://www.oreilly.com/catalog/sound/chapter/ch05.html">Kapitel
über Streamingmedien</a> des O'Reilly-Buchs mit dem Titel Designing Web
Audio.

<p>
Das erste, was man einsehen sollte, ist dass es viele verschiedene
Streamingprotokolle gibt. Das Streaming<b>protokoll</b> definiert, wie
die Streams über das Netzwerk gesendet werden. Sie wurden entwickelt,
um eine effiziente Übertragung von Audio/Video über das Internet in
Echtzeit bereitzustellen. Größtenteils ist das Streamingprotokoll
ein Applikationsprotokoll (Schicht 7), welches entweder UDP oder TCP
(Schicht 4) als Transportprotokolle nutzt. Das »User Datagram«-Protokoll
UDP ist für diese Aufgaben sehr gut geeignet, da es keine Rückantworten
auf die Pakete erfordert oder jegliche andere Netzwerklasten hervorruft.
Viele spezialisierte aber proprietäre Protokolle wurden entwickelt,
z.&nbsp;B. Microsoft Media Services (MMS) oder das »Real Time
Streaming«-Protokoll (RTSP). Wie wir sehen werden wird auch HTTP (das
wiederum TCP nutzt) ebenfalls verwendet, obwohl es keine Möglichkeit
bietet, Streams bei einer konstanten Bitrate anzubieten, wie es etwa
UDP, RTSP und MMS machen.

<p>
Ebenso gibt es ein Streaming<b>format</b>, das definiert, wie die
Audio/Videodaten organisiert und abgespielt werden können. Die
am weitesten verbreiten Formate sind MP3, Real Audio (RA, RM) und
Windows Media (ASF) - alles proprietäre Technologien. Ab und zu könntest
du auch auf einen Stream treffen, der das offene Ogg-Vorbis-Format
nutzt.

<p>
Um ein Beispiel zu liefern, werde ich ein paar Schritt erklären, wie man
<a href="http://www.radio1.be">Radio 1</a> hören kann - einen der
belgischen Nationalradiosender. Browsereingebettete Plugins stehen unter
OpenBSD nicht zur Verfügung, daher muss man etwas mehr tun als nur ein
einfaches »click and play«.

<ul>
<li>Stelle fest, welches Streamingprotokoll und -format genutzt
wird.<br>
Dies wird normalerweise auf der Website angegeben, von der aus du auf
den Stream zugreifst. In diesem Fall folgte ich dem Link »Listen live«
von der Hauptseite. Dort erfuhr ich, dass mein Betriebssystem nicht
unterstützt wird. Sie waren freundlich indem sie mir mitteilen, dass ich
auch auf ihre MP3-Streams zugreifen kann, ohne ihren eingebetteten
Flashplayer benutzen zu müssen. Abgesehen davon erschien eine Liste von
Links zu den nationalen Radiosendern, wodurch ich mit dem nächsten
Schritt weitermachen konnte. Achte darauf, dass ich einen
Browser verwendet habe, der JavaScript konnte, um so weit kommen zu
können.
<li>Ermittle die genaue URL.<br>
Viele Websites verweisen auf eine Containermetadatei oder Playlist
(z.&nbsp;B. M3U, ASX, RAM), welche die tatsächliche URL des Streams
beinhalten. Speichere die Datei einfach ab und lies die URL aus ihr. In
meinem Beispiel wäre sie:

<blockquote><pre>
$ <strong>ftp http://internetradio.vrt.be/dab/hoeluisteren/pc/help/gebruiksvoorwaarden/stream_11.m3U</strong>
$ <strong>cat stream_11.m3U</strong>
http://mp3.streampower.be/radio1-mid.mp3
http://mp3.streampower.be/radio1-low.mp3
http://mp3.streampower.be/radio1-high.mp3
</pre></blockquote>

Es sieht so als, als könnte ich sogar zwischen schlechter, normaler und
guter Qualität des Streams aussuchen. Andere Websites beinhalten einen
JavaScript-Code, um die URL zu generieren. In diesem Fall ist der beste
Ratschlag: Lies den HTML-Quelltext und die Skripte, auf die er verlinkt.
Es ist gut möglich, dass du so die URL rekonstruieren kannst.

<li>Um Streams abzuspielen, solltest du am besten <tt>x11/mplayer</tt>
verwenden, der über Packages und Ports verfügbar ist.
Er unterstützt die meisten Streamingprotokolle und -formate. Außerdem
ist bekannt, dass er auf den Plattformen amd64, i386, powerpc und
sparc64 läuft. Es gibt aber auch Alternativen:
<b>ogg123</b> aus <tt>audio/vorbis-tools</tt> (für Ogg-Vorbis-Streams),
<tt>audio/mpg123</tt> und <tt>audio/mpg321</tt> (für MP3-Streams),
XMMS aus <tt>audio/xmms</tt> und Videolan Client aus <tt>x11/vlc</tt>.
Das Beispiel weiterführend:

<blockquote><pre>
$ <strong>mplayer http://mp3.streampower.be/radio1-mid.mp3</strong>
</pre></blockquote>

<li>Wenn du möchtest, kannst du es dir auch etwas einfacher machen,
indem du ein Alias in deine <tt>.profile</tt> mit aufnimmst:

<blockquote><pre>
alias radio1='mplayer http://mp3.streampower.be/radio1-mid.mp3'
</pre></blockquote>

</ul>

<!--
check out http://www.cbc.ca/listen/index.html
it has DivX streams over MMS as well as Ogg Vorbis streams over HTTP.
maybe a good example but also nearly an ideal case...
-->

Windows-Media- (AFS-)Streams funktionieren meistens auch, obwohl
sie Daten beinhalten könnten, die nur durch den
<tt>graphics/win32-codecs</tt>-Port verarbeiten werden können, welcher
auch nur auf i386 läuft (»pkg_info win32-codecs« wird dir sagen, welche
Codecs unterstützt werden).
Einige Real-Audio-Streams können mit Hilfe von <b>mplayer</b> auf i386
angesehen werden, wenn er in Verbindung mit den Ports
<tt>graphics/win32-codecs</tt> und <tt>emulators/fedora/base</tt>
genutzt wird (lies
<a href="http://marc.info/?t=107060510300001&amp;r=1&amp;w=2">diesen
Thread</a> der Ports-Mailingliste).

<a name="javaflash"></a>
<a name="javaplugin"></a>
<h2>13.11 - Kann ich mit meinem Webbrowser Java verwenden? (nur i386 u.
amd64)</h2>


Das Java-Plugin ist Teil des Java Development Toolkits (JDK).
Lizenzprobleme machen es OpenBSD unmöglich, Binärpackages des JDKs
auszuliefern. Das bedeutet, dass du es aus den Ports installieren
musst. Weitere Informationen über das Erzeugen des JDKs kannst du
in <a href="faq8.html#Programming">FAQ 8 - Programmiersprachen</a>
erhalten. Sobald du mit dem Übersetzen vom JDK fertig bist kannst du
entscheiden, ob du das gesamte JDK-Package oder nur die
Java-Laufzeitumgebung (JRE) installieren möchtest, welches sich in
einem Subpackage befindet und das Browserplugin beinhaltet.

<p>
Nach der Installation werden Instruktionen angezeigt, wie man das
Java-Plugin mit den Webbrowsern Firefox oder Seamonkey verwendet.
Erstelle die symbolischen Verknüpfungen wie es beschrieben wird. Du
solltest dann das Java-Plugin nach dem Eingeben von »about:plugins« in
der Adresszeile sehen können.

<p>
Für KDEs Webbrowser Konqueror muss sich die java-Binary entweder im
PATH befinden oder der absolute Pfadname über das Menü
Settings -&gt; Configure Konqueror -&gt; Java &amp; JavaScript
angegeben werden. Standardmäßig befindet sich die java-Binary in
<tt>/usr/local/jre-<i>version</i>/bin/</tt> oder
<tt>/usr/local/jdk-<i>version</i>/bin/</tt>; je nachdem, ob du das
JRE oder das JDK installiert hast.

<p>
<b>Hinweis:</b> Java-Unterstützung wurde nur mit den Webbrowsern
Firefox, Seamonkey und Konqueror getestet. Wenn es auch mit anderen
Browsern gut funktioniert, lass es uns bitte wissen.


<a name="flashplugin"></a>
<h2>13.12 - Kann ich mit meinem Webbrowser Flash verwenden? (nur
i386)</h2>

Das Flash-Plugin wird von Adobe nur in Binärform ausgeliefert.
Adobe bietet kein natives OpenBSD-Plugin an - es gibt aber
ein Linux-Plugin, das du unter Verwendung der Linux-Emulation nutzen
kannst. Dieses Plugin steht nur für die i386-Plattform bereit.

<p>
Es ist eine gute Idee, etwas über die Linux-Emulation in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=compat_linux&amp;sektion=8">compat_linux(8)</a>-Manualseite
nachzulesen bevor du weitermachst - sinnvoll wäre auch
<a href="faq9.html#Interact">FAQ 9 - Linux-Binarys unter OpenBSD
ausführen</a>.

<p>
Wenn du die Thematik verstanden und die benötigten Dateien noch
nicht installiert hast, installiere einfach das Fedora-Package.
Angenommen, dass deine Umgebungsvariable <tt>PKG_PATH</tt> gesetzt
ist (siehe <a href="faq15.html#Easy">FAQ 15</a>),

<blockquote><pre>
# <b>pkg_add fedora_base</b>
</pre></blockquote>

Dies wird <tt>kern.emul.linux=1</tt> automatisch setzen - aber nicht
permanent. Wenn du dauerhaft Linux-Emulation benötigst, kannst du das
in <tt>/etc/sysctl.conf</tt> setzen (wird in
<a href="faq9.html#Interact">FAQ 9 - Linux-Binarys unter OpenBSD
ausführen</a> erläutert).

<p>
Eine weitere Sache, die du wissen solltest, ist dass Shared Librarys
und Module von Linux nicht mit OpenBSD-Programmen genutzt werden können,
sodass du ebenfalls einen Linux-Browser benötigst.

<p>
Ein Kandidat hierfür ist der Webbrowser
<a href="http://www.opera.com/">Opera</a>, der über den Ports-Tree
installiert werden kann. OpenBSD bietet hierfür keine Packages an, da
die Lizenz von Opera die Weiterverbreitungsbestimmungen nicht klar genug
abdeckt. Die Installation sollte aber nicht allzu lang dauern, da der
Browser in binärer Form von Opera Software ausgeliefert wird.
Hiernach kannst du einfach das Flash-Plugin über den Ports-Tree
installieren.

<blockquote><pre>
# <b>cd /usr/ports/www/opera</b>
# <b>make install</b>
# <b>cd /usr/ports/www/opera-flashplugin</b>
# <b>make install</b>
</pre></blockquote>

<p>
<b>Hinweis:</b>
Es sollte vollkommen ausreichen, nur den letzten Schritt auszuführen,
da das Portssystem die Abhängigkeiten automatisch installieren wird.
Wir haben diesen Prozess aber in mehrere Schritte aufgeteilt, damit
wir diese besser erläutern konnten.

<p>
Wenn du dich an diese Anleitungen gehalten hast, dann wird das
Flash-Plugin aufgelistet sobald du »about:plugins« in der Adressleiste
eingegeben hast.

<!--
Das könnte interessant sein aber derzeit ist keine Hardware zum Testen
verfügbar

<a name="camera"></a>
<h2>13.xx - Kann ich meine Digitalkamera unter OpenBSD benutzen?</h2>

<a name="scanner"></a>
<h2>13.yy - Wie kann ich meinen Scanner einrichten und benutzen?</h2>
-->

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq12.html">[Zum Kapitel 12 - Hardware- und plattformspezifische Fragen]</a>
<a href= "faq14.html">[Zum Kapitel 14 - Platteneinrichtung]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[zurück]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq13.html,v 1.123 ]<br>
$Translation: faq13.html,v 1.43 2008/11/01 09:32:31 paldium Exp $<br>
-->
</small>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>4 - Installationsanleitung für OpenBSD 4.4</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2008 by OpenBSD.">
</head>

<!-- Passes validator.w3.org.  Please keep it this way -->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>

<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq3.html">[Zum Kapitel 3 - Wo man OpenBSD herbekommt]</a>
<a href= "faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
</font>

<h1><font color="#e00000">4 - Installationsanleitung für
OpenBSD 4.4</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href= "#Overview"    >4.1 - Übersicht der
   OpenBSD-Installationsprozedur</a>
<li><a href= "#Checklist"   >4.2 - Checkliste für die Installation</a>
<li><a href="#MkInsMedia"   >4.3 - Bootbare
   OpenBSD-Installationsmedien erzeugen</a>
    <ul>
    <li><a href="#UnixFlop" >4.3.1 - Disketten unter Unix erzeugen</a>
    <li><a href="#DosFlop"  >4.3.2 - Disketten unter Windows oder DOS
       erzeugen</a>
    <li><a href="#MkCD-ROM" >4.3.3 - Eine Boot-CD erzeugen</a>
    </ul>
<li><a href="#Boot"         >4.4 - OpenBSD-Installationsimages booten</a>
<li><a href="#Install"      >4.5 - Eine Installation durchführen</a>
  <ul>
  <li><a href="#Start"      >4.5.1 - Mit der Installation beginnen</a>
  <li><a href="#Disks"      >4.5.2 - Festplatte(n) einrichten</a>
  <li><a href="#Hostname"   >4.5.3 - Den Hostnamen des Systems
     setzen</a>
  <li><a href="#Network"    >4.5.4 - Das Netzwerk konfigurieren</a>
  <li><a href="#InstMedia"  >4.5.5 - Das Installationsmedium
     auswählen</a>
  <li><a href="#Filesets"   >4.5.6 - Dateisets auswählen</a>
  <li><a href="#Finish"     >4.5.7 - Zum Ende kommen</a>
  </ul>

<li><a href= "#FilesNeeded" >4.6 - Welche Dateien werden zur
   Installation benötigt?</a>
<li><a href= "#Partitioning" >4.7 - Wie viel Platz brauche ich für eine
   OpenBSD-Installation?</a>
<li><a href= "#Multibooting">4.8 - Multibooting OpenBSD/i386</a>
<li><a href= "#SendDmesg"   >4.9 - Nach der Installation deine Dmesg an
   dmesg@openbsd.org schicken</a>
<li><a href= "#AddFileSet"  >4.10 - Ein Dateiset nach der Installation
   hinzufügen</a>
<li><a href= "#bsd.rd"      >4.11 - Was ist bsd.rd?</a>
<li><a href= "#InstProb"    >4.12 - Allgemeine
   Installationsprobleme</a>
  <ul>
  <li><a href="#cpq16m"     >4.12.1 - Mein Compaq erkennt nur 16&nbsp;M
     RAM</a>
  <li><a href="#noboot"     >4.12.2 - Mein i386 bootet nach der
     Installation nicht</a>
  <li><a href="#sshhang"    >4.12.3 - Mein System bootet, aber hing
     bei der ssh-Schlüsselgenerierung</a>
  <li><a href="#noftplist"  >4.12.4 - Ich bekam die Meldung »Failed to
     change directory« als ich die Installation durchführte</a>
  <li><a href="#blankfdisk" >4.12.5 - Meine fdisk-Partitionstabelle ist
     kaputt oder leer!</a>
  </ul>
<li><a href= "#site"        >4.13 - Anpassen des
  Installationsprozesses</a>
<li><a href= "#Multiple"    >4.14 - Wie kann ich mehrere gleichartige
   Systeme installieren?</a>
<li><a href="#getdmesg"     >4.15 - Woher bekomme ich eine dmesg(8),
   damit ich ein Problem mit der Installation melden kann?</a>
</ul>
<hr>

<p>
<a name= "Overview"></a>
<h2>4.1 - Übersicht der OpenBSD-Installationsprozedur</h2>

<p>
OpenBSD hat eine robuste und anpassbare textbasierte
Installationsroutine und kann mit einer einzelnen Diskette installiert
werden. Die meisten Architekturen lassen sich auf fast gleichem Wege
installieren; allerdings gibt es Unterschiede in den Details.
In jedem Fall wird dringend dazu geraten, das plattformspezifische
INSTALL-Dokument im <i>Plattform</i>-Verzeichnis auf der CD-ROM oder der
FTP-Seiten (z.&nbsp;B. <tt>i386/INSTALL.i386</tt>,
<tt>mac68k/INSTALL.mac68k</tt> oder <tt>sparc/INSTALL.sparc</tt>)
durchzulesen.

<p>
Die OpenBSD-Installation benutzt einen speziellen Kernel mit einigen
Werkzeugen und Installationsskripten, die sich auf einer vorgeladenen
RAM-Disk befinden. Nachdem dieser Kernel
gebootet wurde, wird das Betriebssystem aus einigen komprimierten
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>-Dateien
(<tt>.tgz</tt>) extrahiert, die sich nicht auf der vorgeladenen
RAM-Disk befinden und daher von einer anderen Quelle bezogen werden
müssen.
Es existieren mehrere Wege, diesen Installationskernel zu booten:

<ul>
<li><b>Diskette:</b>
Die bereitgestellten Diskettenimages können benutzt werden,
um Installationsdisketten auf einem anderen
<a href="#UnixFlop">Unix-ähnlichen</a> System oder
<a href="#DosFlop">DOS/Windows</a>-System zu erstellen.
Typische Dateinamen sind <tt>floppy44.fs</tt>, obwohl für einige
Plattformen mehrere Diskettenimages vorhanden sind.

<li><b>CD-ROM:</b> Für einige Plattformen wird ein CD-ROM-Image
(<tt>cd44.iso</tt> zum reinen Booten oder <tt>install44.iso</tt> für
eine gesamte Installation) bereitgestellt, mit dem eine bootbare
CD-ROM gebrannt werden kann.

<li><b>Bestehende Partition:</b> Der <a href="#bsd.rd">RAM-Disk</a>-Kernel
kann von einer bereits existierenden OpenBSD-Partition geladen
werden (z.&nbsp;B. nach einem Upgrade oder einer Neuinstallation).

<li><b>Netzwerk:</b> Manche Systeme können über
das Netzwerk booten (zum Beispiel unter Verwendung von
<a href="faq6.html#PXE">PXE</a> oder einem anderen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskless&amp;sektion=8">Netzwerkbootprozess</a>).

<li><b>Ein Dateisystemimage auf Platte schreiben (Miniroot):</b> Ein
Dateisystemimage, das auf eine existierende Partition geschrieben und
daraufhin gebootet werden kann.

<li><b>Bootfähiges Band:</b> Einige Systeme können von Band booten.
Diese Bänder können anhand der
INSTALL.<i>Plattform</i>-Anleitung erstellt werden.

</ul>

Nicht jede <a href="../../de/plat.html">Plattform</a> unterstützt alle
Bootmöglichkeiten:

<ul>
<li><a href="../../de/alpha.html"><b>alpha:</b></a> Diskette, CD-ROM,
Netzwerk, Diskettenimages auf Festplatte schreiben.

<li><a href="../../amd64.html"><b>amd64:</b></a> Diskette, CD-ROM,
<a href="faq6.html#PXE">Netzwerk</a>.

<li><a href="../../de/armish.html"><b>armish:</b></a>
Je nach Maschine unterschiedlich.

<li><a href="../../de/hp300.html"><b>hp300:</b></a> CD-ROM, Netzwerk.

<li><a href="../../de/hppa.html"><b>hppa:</b></a> Netzwerk.

<li><a href="../../de/i386.html"><b>i386:</b></a> Diskette, CD-ROM,
<a href="faq6.html#PXE">Netzwerk</a>.

<li><a href="../../landisk.html"><b>landisk:</b></a> Miniroot, das mit
Hilfe eines anderen Rechners installiert wurde.

<li><a href="../../de/mac68k.html"><b>mac68k:</b></a> Mit Anwendungen
unter Mac OS booten. Siehe
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/4.4/mac68k/INSTALL.mac68k">INSTALL.mac68k</a>
für Details.

<li><a href="../../de/macppc.html"><b>macppc:</b></a> CD-ROM, Netzwerk.

<li><a href="../../de/mvme68k.html"><b>mvme68k:</b></a> Netzwerk,
bootbares Band.

<li><a href="../../de/mvme88k.html"><b>mvme88k:</b></a> Netzwerk,
bootbares Band.

<li><a href="../../de/sparc.html"><b>sparc:</b></a> Diskette, CD-ROM,
Netzwerk, Schreiben eines Images auf eine existierende Partition.

<li><a href="../../de/sparc64.html"><b>sparc64:</b></a> Diskette
(nur U1/U2), CD-ROM, Netzwerk, Schreiben eines Images auf eine
existierende Partition.

<li><a href="../../de/vax.html"><b>vax:</b></a> Diskette, Netzwerk.

<li><a href="../../de/zaurus.html"><b>zaurus:</b></a> Boote bsd.rd von
der Linuxpartition. Lies <a
href="ftp://ftp.openbsd.org/pub/OpenBSD/4.4/zaurus/INSTALL.zaurus"
>INSTALL.zaurus</a> für weitere Details.

</ul>

Alle Plattformen können ebenfalls einen
<a href="#bsd.rd">bsd.rd</a> für eine Neuinstallation oder
Aktualisierung verwenden.

<p>
Wenn der Installationskernel erst einmal gebootet ist, kannst du die
<a href="#FilesNeeded">Installationsdateisets</a> von unterschiedlichen
Quellen beziehen. Auch hier bietet nicht jede Plattform alle
Möglichkeiten.

<ul>
<li><b>CD-ROM:</b> Selbstverständlich bevorzugen wir, dass du das
<a href="../../de/orders.html">offizielle CD-ROM-Set</a> verwendest.
Du kannst aber auch <tt>install44.iso</tt> verwenden, um dir dein eigenes
zu erstellen.

<li><b>FTP:</b>
Entweder einen der
OpenBSD-<a href="../../de/ftp.html">FTP-Mirror</a>
oder deinen eigenen FTP-Server, der die Dateisets hält.

<li><b>HTML:</b>
Entweder einen der
OpenBSD-<a href="../../de/ftp.html#http">HTTP-Mirror</a>
oder deinen eigenen Webserver, der die Dateisets hält.

<li><b>Lokale Festplattenpartition:</b>
In vielen Fällen kannst du die Dateisets von einer anderen Partition
einer lokalen Festplatte aus installieren.
Zum Beispiel auf <a href="../../de/i386.html">i386</a> kannst du von
einer FAT-Partition oder einer CD-ROM mit ISO9660-, Rock-Ridge- oder
Joliet-Format aus installieren.
In einigen Fällen musst du das Dateisystem manuell einbinden, bevor
du es verwenden kannst.

<li><b>NFS:</b>
Manche Plattformen unterstützen NFS-Mounts für die Dateisets.

<li><b>Band:</b>
Dateisets können ebenfalls von einem unterstützten Band
gelesen werden. Details darüber, wie ein solches Band erstellt werden
muss, befinden sich im <tt>INSTALL.</tt><i>Plattform</i>-Dokument.
</ul>

<a name="Checklist"></a>
<h2>4.2 - Checkliste für die Installation</h2>

<p>
Bevor du mit der eigentlichen Installation beginnst, solltest du dir im
Klaren sein, was du eigentlich am Ende haben willst.

Mindestens die folgenden Punkte sollten daher vorher geklärt sein:
<ul>
<li>Name der Maschine
<li>Die eingebaute Hardware
  <ul>
  <li>Prüfe die Kompatibilität anhand der
      Kompatibilitätsseite für deine Hardware.
  <li>Wenn du ISA-Komponenten verwendest, musst du die Einstellungen
      kennen und prüfen, ob sie den Anforderungen von OpenBSD
      entsprechen.
  </ul>
<li>Die gewünschte Installationsmethode (CD-ROM, FTP etc.)
<li>Wie soll das System gepatcht werden falls ein wichtiges Problem
    entdeckt wird?
  <ul>
  <li>Wenn es lokal ausgeführt werden soll, musst du
      <a href="#Partitioning">genügend freien Speicher</a> für den
      Source-Tree und dessen Erzeugung haben.
  <li>Ansonsten musst du Zugriff auf eine andere Maschine haben, die ein
      gepatchtes <a href="faq5.html#Release">Release</a>
      zur Verfügung stellt.
  </ul>
<li>Das erwünschte Plattenlayout
  <ul>
  <li>Müssen vorhandene Daten irgendwo gesichert werden?
  <li>Soll OpenBSD neben einem anderen Betriebssystem auf dem Rechner
      existieren? Wenn ja: Wie sollen die beiden Systeme
      gebootet werden, brauchst du vielleicht einen Bootmanager?
  <li>Wird OpenBSD die ganze Festplatte belegen oder möchtest du eine
      existierende Partition oder ein existierendes OS behalten (oder
      Platz für zukünftige Dinge)?
  <li>Wie willst du die OpenBSD-Partition selbst aufteilen?
  </ul>
<li>Netzwerkeinstellungen, falls du nicht DHCP verwendest:
  <ul>
  <li>Domänenname
  <li>Domainnameserveradresse(n) (DNS)
  <li>IP-Adressen und Subnetzmasken für jede Netzwerkkarte
  <li>Gatewayadressen
  </ul>
<li>Wirst du auf diesem System X benutzen?
</ul>


<a name="MkInsMedia"></a>
<h2>4.3 - Bootbare OpenBSD-Installationsmedien erzeugen</h2>

<p>
Als Beispiel werden wir die Installationsmedien betrachten, die für
die <a href="../../de/i386.html">i386</a>- und
<a href="../../de/sparc.html">sparc</a>-Plattformen bereitstehen.

<p>
Die <a href="../../de/i386.html">i386</a>-Plattform besitzt sechs
separate Installationsdiskimages, die ausgewählt werden können:

<ul>
<li><b><tt>floppy44.fs</tt></b> (Desktop-PC) unterstützt viele
  PCI- und ISA-Netzwerkkarten, IDE- und einfache SCSI-Adapter
  und bietet wenig Unterstützung für PCMCIA. Die meisten Benutzer
  werden dieses Image verwenden, wenn sie von einer Diskette aus
  booten.
<li><b><tt>floppyB44.fs</tt></b> (Server) unterstützt viele
  RAID-Controller und einige der selteneren SCSI-Adapter. Viele der
  Standard-SCSI-Adapter und viele EISA- und ISA-Netzwerkkarten werden
  nicht unterstützt.
<li><b><tt>floppyC44.fs</tt></b> (Laptops) unterstützt viele der
  Cardbus- und PCMCIA-Karten, die man in Laptops findet.
<li><b><tt>cd44.iso</tt></b> ist ein ISO9660-Image, das für die
  Erstellung einer bootbaren CD mit den bekanntesten
  CD-ROM-Brennsoftwareprodukten auf den meisten Plattformen verwendet
  werden kann. Dieses Image hat die größte Auswahl an Treibern und ist
  normalerweise die empfohlene Wahl, wenn deine Hardware von CD-ROM
  booten kann.
<li><b><tt>cdemu44.iso</tt></b> ist ein ISO9660-Image, das zum Booten
  eine Diskettenemulation und ein 2,88-M-Diskettenimage benutzt.
  Hoffentlich brauchen nur wenige Leute dieses Image - die meisten
  werden <tt>cd44.iso</tt> benutzen. Verwende <tt>cdemu44.iso</tt> nur,
  wenn <tt>cd44.iso</tt> bei dir nicht funktioniert.
<li><b><tt>install44.iso</tt></b> ist ein ISO9660-Image, das alle
  Standard-Dateisets enthält. Diese Datei kann verwendet werden, um eine
  eigenständige OpenBSD-Installation durchzuführen.
</ul>

Ja, es kann Situationen geben, in denen du eine Diskette für deinen
SCSI-Controller brauchst und eine andere für deine Netzwerkkarte.
Zum Glück geschieht das selten und kann normalerweise vermieden werden.

<p>
Die <a href="../../de/sparc.html">sparc</a>-Plattform besitzt vier
separate Installationsdiskimages, die ausgewählt werden können.

<ul>
<li><b><tt>floppy44.fs</tt></b>: Unterstützt Systeme mit
  Diskettenlaufwerk.
<li><b><tt>cd44.iso</tt></b>: Ein ISO-Image, mit dem eine CD
  gebrannt werden kann, um SPARC-Systeme von einer CD-ROM aus booten
  zu können.
<li><b><tt>miniroot44.fs</tt></b>: Kann auf eine Swappartition
  geschrieben und gebootet werden.
<li><b><tt>install44.iso</tt></b>: ein ISO9660-Image, das alle
  Standard-Dateisets enthält. Diese Datei kann verwendet werden, um eine
  eigenständige OpenBSD-Installation durchzuführen.
</ul>

<a name="MkFlop"></a>
<a name="UnixFlop"></a>
<h3>4.3.1 - Disketten unter Unix erzeugen</h3>

<p>
Um eine formatierte Diskette zu erzeugen, benutze einfach das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdformat&amp;sektion=1&amp;arch=i386">fdformat(1)</a>.
Damit kannst du deine Diskette sowohl formatieren als auch auf defekte
Sektoren prüfen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>fdformat /dev/rfd0c</b>
  Format 1440K floppy `/dev/rfd0c'? (y/n): y
  Processing VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV done.
</pre></td></tr></table>

<p>
Ist deine Ausgabe wie im obigen Beispiel, dann ist deine Diskette in
Ordnung. Wenn du - warum auch immer - nicht ALLE Vs siehst, dann ist
deine Diskette höchstwahrscheinlich fehlerhaft und du solltest eine neue
verwenden.

<p>
Bedenke, dass einige Unix-ähnliche Systeme verschiedene
Formatierungsbefehle für Disketten haben. Konsultiere das Handbuch
deines Systems für den exakten Ablauf.

<p>
Hast du dann eine korrekt formatierte Diskette, ist es an der Zeit, das
Installationsimage auf die Diskette zu schreiben. Wenn du sie auf einer
OpenBSD-Maschine oder auf einem anderen Unix-ähnlichen OS erstellst,
kannst du <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=0">dd(1)</a>
verwenden.
Ein Beispiel für <tt>dd(1)</tt>:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>dd if=floppy44.fs of=/dev/rfd0c bs=32k</b>
</pre></td></tr></table>

<p>
Ist das Image geschrieben, überprüfe es mit dem Befehl <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=cmp&amp;sektion=1">cmp(1)</a>,
um sicherzugehen, dass die Kopie dem Original entspricht. Wenn Diskette
und Image identisch sind, wirst du lediglich einen weiteren Prompt sehen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>cmp /dev/rfd0c floppy44.fs</b>
</pre></td></tr></table>

<a name="DosFlop"></a>
<h3>4.3.2 - Disketten unter Windows oder DOS erzeugen</h3>

<p>
Dieses Kapitel beschreibt, wie man Installationsimages unter Windows
oder DOS auf eine Diskette schreibt.
Du kannst die Anwendungen, die unten erwähnt werden, aus dem
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/4.4/tools/">tools</a>-Verzeichnis
von einem der FTP-Mirror oder aus dem <tt>4.3/tools</tt>-Verzeichnis auf
CD1 des OpenBSD-CD-Sets bekommen.

<p>
Zur Vorbereitung der Diskette unter MS-DOS oder Windows benutzt man
einfach die bereits vorhanden Formatierungsprogramme.

<p>
Das Installationsimage wird mittels
<i>rawrite</i>, <i>fdimage</i> oder <i>ntrw</i> auf die formatierte
Diskette geschrieben. Unter Windows NT, 2000 und XP funktioniert
<i>rawrite</i> nicht.

<p>
Bedenke, dass <tt>FDIMAGE.EXE</tt> und <tt>RAWRITE.EXE</tt>
MS-DOS-Applikationen sind und daher auch den
8.3-Dateinamensbeschränkungen von MS-DOS unterliegen.
Da sowohl <tt>floppyB44.fs</tt> als auch <tt>floppyC44.fs</tt> längere
Dateinamen haben, wirst du überprüfen müssen,
wie dein System die Dateien an sein 8.3-Format angepasst hat,
bevor du <tt>FDIMAGE.EXE</tt> oder <tt>RAWRITE.EXE</tt> benutzen
kannst, um deine Bootdiskette zu schreiben.

<p>
Ein Beispiel für <i>rawrite</i>:
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  C:\> <b>rawrite</b>
  RaWrite 1.2 - Write disk file to raw floppy diskette

  Enter source file name: <b>floppy44.fs</b>
  Enter destination drive: <b>a</b>
  Please insert a formatted diskette into drive A: and press -ENTER- : <i><b>Enter</b></i>
</pre></td></tr></table>

<p>
Ein Beispiel für <i>fdimage</i>:
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  C:\> <strong>fdimage -q floppy44.fs a:</strong>
</pre></td></tr></table>

<p>
Ein Beispiel für <i>ntrw</i>:
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  C:\> <strong>ntrw floppy44.fs a:</strong>
  3.5", 1.44MB, 512 bytes/sector
  bufsize is 9216
  1474560 bytes written
</pre></td></tr></table>

<a name="MkCD-ROM"></a>
<h3>4.3.3 - Eine Boot-CD erzeugen</h3>

<p>
Um eine CD-ROM zu brennen, kannst du die <tt>cd44.iso</tt>-Datei
oder <tt>install44.iso</tt> verwenden. Es sei an dieser Stelle dem
Leser selbst überlassen, die exakten Details mit den zur Verfügung
stehenden Anwendungen herauszufinden.

<p>
Einige der Anwendungen unter OpenBSD sind:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mkhybrid&amp;sektion=8">mkhybrid(8)</a>
<li><a href="http://cdrecord.berlios.de/old/private/cdrecord.html">cdrecord</a>,
Teil der cdrtools-Kollektion im
<a href="faq15.html">Packages- und Portssystem von OpenBSD</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1">cdio(1)</a>s
»track at once«-Schreiboption (tao)
</ul>

<a name="Boot"></a>
<h2>4.4 - OpenBSD-Installationsimages booten</h2>

<h3>i386/amd64 booten</h3>

Das Installationsimage auf den i386- und am64-PC-Architekturen zu booten
ist nichts Neues für die meisten Leute. Wenn du die Diskette verwendest,
dann lege sie einfach in dein Diskettenlaufwerk und schalte den Rechner
ein. Das Installationsimage wird automatisch laden, wenn in deinem BIOS
das Booten von Diskette aktiviert ist. Wenn du von CD starten willst,
dann musst du im System-BIOS das Booten von CD-ROM erlauben. Einige
ältere BIOSe haben diese Option nicht und du musst eine Diskette
für den Start des Installationsimages verwenden. Keine Sorge, du kannst
auch dann von CD installieren, wenn von Diskette gebootet wurde.

<p>
Du kannst ebenfalls installieren, indem du <a href="#bsd.rd">bsd.rd</a>
von einer existierenden OpenBSD-Partition oder vom Netzwerk unter
Verwendung vom <a href="faq6.html#PXE">PXE-Bootprozess</a> aus bootest.

<h3>sparc/sparc64 booten</h3>

<b>HINWEIS:</b>
Auf der <a href="../../de/sparc64.html">sparc64</a>-Plattform können nur
die SBus-Maschinen (Ultra 1, Ultra 2) von einer Diskette aus gebootet
werden.

<p>
Um von Diskette zu booten, lege die OpenBSD-Installationsdiskette in
das Diskettenlaufwerk ein. Verwende dann folgendes Kommando, um von der
Diskette zu booten:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot floppy</b>
</pre></td></tr></table>

<p>
Um von CD-ROM zu starten, lege die OpenBSD-CD-ROM in dein Laufwerk.
Wenn deine Sun nur ein CD-ROM-Laufwerk hat, dann wechsle zum Bootprompt,
an dem du <tt>boot cdrom</tt> ausführen kannst:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot cdrom</b>
</pre></td></tr></table>

<p>
Selbstverständlich wird dies nur im neuen Befehlsmodus funktionieren.
Wenn du im alten Befehlsmodus bist (ein rechter Pfeil), gib »n« ein, um
in den neuen zu gelangen (wenn du eine alte sparc vor sun4c hast, dann
hast du vielleicht keinen neuen Befehlsmodus: Hier hilft dir nur
experimentieren). Wenn du mehrere CD-ROM-Laufwerke hast, dann musst du
vom richtigen starten. Verwende <tt>probe-scsi</tt> im neuen
Befehlsmodus.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>probe-scsi</b>

  Target 0
    Unit 0   Disk     QUANTUM LIGHTNING 365S
  Target 1
    Unit 0   Removable Disk     QUANTUM EMPIRE_1080S
  Target 3
    Unit 0   Removable Disk     Joe's CD ROM
</pre></td></tr></table>

<p>
Suche das richtige CD-ROM und merke dir die Targetnummer.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot /sbus/esp/sd@X,0</b>
</pre></td></tr></table>


<a name="Install"></a>
<h2>4.5 - Eine Installation durchführen</h2>
<a name="Start"></a>
<h3>4.5.1 - Mit der Installation beginnen</h3>
<!-- XXXrelease -->
Was auch immer du für eine Methode zum Booten gewählt hast - nun ist es
an der Zeit, sie zu benutzen. Während des Bootprozesses werden der
Kernel und alle Programme für die OpenBSD-Installation in den
Hauptspeicher geladen. Die größten Probleme entstehen beim Booten von
defekten Disketten oder bei der Zuweisung von Festplatten. Die
Bootdiskette ist ziemlich vollgepackt - jeder defekte Block wird
Probleme verursachen.

<p>
An fast jeder Stelle während des OpenBSD-Installationsprozesses kannst
du den aktuellen Installationsversuch abbrechen, indem du STRG-C
drückst. Du kannst ihn ohne Neustart durch Aufruf von <tt>install</tt>
im Shellprompt wieder beginnen.

<p>
Wenn der Bootvorgang erfolgreich war, wirst du eine Menge Textmeldungen
vorbeiziehen sehen. Dieser Text (bei vielen Plattformen in weißer
Schrift auf blauem Hintergrund) ist die sogenannte <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8"
>Dmesg</a>.
Der Kernel erzählt dir, welche Geräte wo gefunden wurden.
Mach dir nicht die Mühe, den Text zu speichern. Eine Kopie wird
in <tt>/var/run/dmesg.boot</tt> gespeichert.

<p>
Dann wirst du Folgendes sehen:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  root on rd0a swap on rd0b dump on rd0b
  erase ^?, werase ^W, kill ^U, intr ^C, status ^T
  (I)nstall, (U)pgrade or (S)hell? <b>i</b>
</pre></td></tr></table>

<p>
Und damit erreichen wir auch schon die erste Frage. Meistens werden die
drei Möglichkeiten angeboten:
<ul>
<li><b>Install</b>: OpenBSD auf dein System installieren und dabei
alles überschreiben, was dort vorher war. Selbstverständlich kann man
hier auch einige Teile der Festplatte unberührt lassen (z.&nbsp;B.
<tt>/home</tt>), aber ansonsten wird alles andere überschrieben.
<li><b>Upgrade</b>: Installiere neue <a href="#FilesNeeded"
>Installationsdateisets</a> auf dieser Maschine, aber überschreibe keine
Konfigurationsdateien, Benutzerdaten oder zusätzliche Programme.
Es wird keine Festplattenformatierung vorgenommen und auch die
Verzeichnisse <tt>/etc</tt> und <tt>/var</tt> werden nicht
überschrieben. Ein paar wichtige Hinweise:
<ul>
<li>Dir wird nicht die Möglichkeit angeboten, <tt>etc44.tgz</tt> zu
installieren. Nach der Installation musst du die Änderungen von
<tt>etc44.tgz</tt> <a href="upgrade44.html#etcUpdates">selbst in dein
System einbinden</a>, bevor es voraussichtlich voll funktionsfähig sein
wird. Das ist ein sehr wichtiger Schritt, da sonst einige Dienste wie
beispielsweise <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4">pf(4)</a>
möglicherweise nicht starten werden.

<li>Der Upgradeprozess ist nicht dazu da, um ganze Releases
zu überspringen! Obwohl das meist funktioniert, wird es in keinem Fall
unterstützt. Mit OpenBSD 4.4 wird nur das Upgrade von 4.3 auf 4.4
unterstützt. Wenn du von einem älteren Release aus aktualisieren musst,
upgrade erst auf die darauf folgende Version. Sollte dein System sehr
alt sein, ziehe eine vollständige Neuinstallation in Erwägung.

</ul>
<!-- XXXversion -->
Weitere Informationen über Upgrades zwischen den einzelnen Releases
können in der <a href="upgrade44.html">Upgradeanleitung für 4.4</a>
gefunden werden.

<li><b>Shell</b>: Manchmal muss man Reparaturen oder Schritte
unternehmen, da das System sonst nicht mit einem normalen Kernel booten
wird. Dazu ist diese Option gedacht. Einige weitere wichtige
Werkzeuge befinden sich auf dem Bootmedium.
</ul>

In einigen Fällen wirst du die Upgradeoption nicht vorfinden.
Nach einem <i>Flagday</i> ist es zum Beispiel nicht möglich, ein
direktes Upgrade zu machen - daher muss man das System von Grund auf
neuinstallieren.

<p>
In diesem Beispiel machen wir eine Installation. Der Upgradeprozess
ist aber recht ähnlich.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Welcome to the OpenBSD/i386 4.4 install program.

  This program will help you install OpenBSD. At any prompt except password
  prompts you can escape to a shell by typing '!'. Default answers are shown
  in []'s and are selected by pressing RETURN.  At any time you can exit this
  program by pressing Control-C, but exiting during an install can leave your
  system in an inconsistent state.

  Terminal type: [vt220] <b><i>Enter</i></b>
  kbd(8) mapping? ('L' for list) [none] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
In den meisten Fällen ist der vorgeschlagene Terminaltyp passend.
Solltest du allerdings eine
<a href="faq7.html#SerCon">serielle Konsole</a> für die Installation
benutzen, wähle bitte die passende Konsole aus - nicht einfach die
vorgeschlagene.

<p>
Wenn du keine Tastaturbelegung auswählst, wird die
US-Tastaturbelegung benutzt.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  IS YOUR DATA BACKED UP? As with anything that modifies disk contents, this
  program can cause SIGNIFICANT data loss.

  It is often helpful to have the installation notes handy. For complex disk
  configurations, relevant disk hardware manuals and a calculator are useful.

  Proceed with install? [no] <b>y</b>
</pre></td></tr></table>

<p>
Wenn du hier die vorgeschlagene Antwort gibst, landest du in einer Shell
und bekommst einen Prompt, nachdem die Installation sich beendet hat.

<p>
Die Installationshinweise beziehen sich hierbei auf die Installation von
CDs oder FTP-Servern, die dort in der Datei
<tt>INSTALL.<i>&lt;plat&gt;</i></tt> gefunden werden können (wobei
<i>&lt;plat&gt;</i> gegen deine
<a href="../../de/plat.html">Plattform</a> ausgetauscht werden muss
[zum Beispiel <tt>i386</tt>]).

<a name="Disks"></a>
<h3>4.5.2 - Festplatte(n) einrichten</h3>

<i><b>Wichtiger Hinweis:</b>
Benutzer mit einer großen Festplatte (größer als das, was normal war,
als dein Rechner hergestellt wurde) sollten unbedingt
<a href="faq14.html#LargeDrive">diese Sektion</a> lesen, bevor sie
weitermachen.</i>

<p>
Die Laufwerke unter OpenBSD einzurichten ist für alle Plattformen ein
wenig unterschiedlich. Bei <a href="../../de/i386.html">i386</a>,
<a href="../../amd64.html">amd64</a>,
<a href="../../de/macppc.html">macppc</a>,
<a href="../../de/zaurus.html">zaurus</a> und
<a href="../../de/armish.html">cats</a>
geschieht die Einrichtung in zwei Schritten: die eine mit
fdisk(8) und die andere mit disklabel(8).

<p>
Der eine oder andere wird ein wenig verwundert über die hier verwendete
Terminologie sein. Es sieht so aus, als ob wir das Wort Partition
auf zwei verschiedene Weisen benutzen - und das stimmt!
Es gibt zwei Schichten von Partitionierung auf den zuvor genannten
OpenBSD-Plattformen. Die erste könnte man als
Betriebssystempartitionierung bezeichnen: So legen zum Beispiel viele
Betriebssysteme ihre Partitionen an. Die zweite bezieht sich darauf,
wie OpenBSD seine Partition in weitere individuelle Dateisysteme
einteilt. Die erste Schicht ist sichtbar als eine Partition für DOS,
Windows und jedes weitere Betriebssystem, das dieses Plattenlayout
verwendet. Die zweite Schicht dagegen ist nur für OpenBSD und solche
Systeme sichtbar, die OpenBSD-Dateisysteme direkt lesen können.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Cool!  Let's get to it.

  You will now initialize the disk(s) that OpenBSD will use. To enable all
  available security features you should configure the disk(s) to allow the
  creation of separate filesystems for /, /tmp, /var, /usr, and /home.

  Available disks are: wd0.
  Which one is the root disk? (or done) [wd0] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Die Rootdisk ist die Festplatte, von der das System booten soll
und wo sich normalerweise der Swapbereich befindet.
IDE-Festplatten werden als <tt>wd0</tt>, <tt>wd1</tt> etc. angezeigt,
SCSI-Festplatten und RAIDs als <tt>sd0</tt>, <tt>sd1</tt> und so weiter.
Alle Festplatten, die OpenBSD finden kann, sind hier aufgelistet -
wenn du welche hast, die hier nicht auftauchen, dann sind sie vermutlich
falsch konfiguriert oder werden gar nicht unterstützt.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you want to use *all* of wd0 for OpenBSD? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Wenn du diese Frage mit »yes« beantwortest, wird die gesamte Festplatte
für OpenBSD benutzt. Damit werden ein Standard-Masterbootrecord und eine
Standard-Partitionstabelle eingerichtet, die beide auf die
Festplatte geschrieben werden - eine Partition, die die ganze Festplatte
einnimmt, den OpenBSD-Partitionstyp hat und als bootbar gekennzeichnet
ist. Das ist für die meisten Produktionssysteme unter OpenBSD die
brauchbarste Lösung; auf manchen Systemen sollte man das allerdings
nicht so machen. Viele Compaq-Systeme, viele Laptops, einige Dell- und
ein paar andere Systeme benutzen eine Verwaltungspartition, die
unbedingt intakt bleiben muss. Wenn dein System einige Partitionen hat,
die du nicht löschen willst, solltest du auf keinen Fall mit »yes«
antworten. Falls du jedoch eine brandneue Platte hast, die noch
nie zuvor verwendet wurde, solltest du eventuell besser mit »yes«
antworten (oder verwende die »update«-Option von fdisk), sodass du
einen gültigen Masterbootrecord und eine gültige -signatur erhältst.

<p>
Für dieses Beispiel nehmen wir an, dass die Festplatte zwischen OpenBSD
und einer bereits existierenden Installation von Windows 2000 aufgeteilt
werden soll. Wir beantworten also die Frage hier mit »no«, wodurch wir
im <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Programm
landen.  Mehr Informationen über fdisk findest du
<a href="faq14.html#fdisk">hier</a>.

<p>
<b>Hinweis:</b> Wenn du mit »Y« auf die Frage "Do you want to use *all*
of wd0 for OpenBSD?" antwortest oder eine Plattform einsetzt, die kein
fdisk verwendet (zum Beispiel sparc64), dann wird dieser Schritt
übersprungen und stattdessen mit <a href="#disklabel">Ein Disklabel
erzeugen</a> fortgesetzt.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  You will now create a single MBR partition to contain your OpenBSD data. This
  partition must have an id of 'A6'; must *NOT* overlap other partitions; and
  must be marked as the only active partition.

  The 'manual' command describes all the fdisk commands in detail.

  Disk: wd0       geometry: 2434/255/63 [39102336 Sectors]
  Offset: 0       Signature: 0xAA55
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
  *0: 0B      0   1   1 -    195 254  63 [          63:     3148677 ] Win95 FAT-32
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused      
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused      
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused      
  Enter 'help' for information
  fdisk: 1> <b>help</b>
          help            Command help list
          manual          Show entire OpenBSD man page for fdisk
          reinit          Re-initialize loaded MBR (to defaults)
          setpid          Set the identifier of a given table entry
          disk            Edit current drive stats
          edit            Edit given table entry
          flag            Flag given table entry as bootable
          update          Update machine code in loaded MBR
          select          Select extended partition table entry MBR
          swap            Swap two partition entries
          print           Print loaded MBR partition table
          write           Write loaded MBR to disk
          exit            Exit edit of current MBR, without saving changes
          quit            Quit edit of current MBR, saving current changes
          abort           Abort program without saving current changes
  fdisk: 1>
</pre></td></tr></table>

<p>
Ein paar Befehle sollten wir uns näher ansehen:
<ul>
<li><b><tt>r</tt></b> oder <b><tt>reinit</tt></b>: Löscht eine
vorhandene Partitionstabelle und erzeugt eine allumfassende
OpenBSD-Partition. Diese wird als aktiv markiert und installiert den
OpenBSD-MBR-Code. Das ist dasselbe, als ob man mit »yes« auf die Frage
»<tt>use *all* of ...</tt>« geantwortet hätte. Du wirst das mit einer
neuen Festplatte sehr wahrscheinlich machen wollen.
<li><b><tt>p</tt></b> oder <b><tt>print</tt></b>: Zeigt die aktuelle
Partitionstabelle in Sektoren an, wohingegen »<tt>p m</tt>« die
Tabelle in Megabyte anzeigt und »<tt>p g</tt>« in Gigabyte.
<li><b><tt>e</tt></b> oder <b><tt>edit</tt></b>: Editiert oder ändert
einen Tabelleneintrag.
<li><b><tt>f</tt></b> oder <b><tt>flag</tt></b>: Markiert eine Partition
als aktive Partition - diejenige also, von der gebootet wird.
<li><b><tt>u</tt></b> oder <b><tt>update</tt></b>: Aktualisiert den MBR
mit dem OpenBSD-Bootcode. Ähnelt <tt>reinit</tt>, nur dass es die
bestehende Partitionstabelle nicht verändert.
<li><b><tt>exit</tt></b> und <b><tt>quit</tt></b>: Sei hiermit
vorsichtig, da einige Anwender nicht daran gewöhnt sind, dass
exit und quit verschiedene Bedeutungen haben.
</ul>

Es ist nochmals wichtig darauf hinzuweisen, dass ein Fehler hier
durchaus Datenverlust nach sich ziehen kann. Wenn du die Installation
auf einer Platte mit wertvollen Daten machst, solltest du vielleicht
vorher auf einer Testplatte proben - zumal du dann noch eine gute
Datensicherung hast.

<p>
Unsere Festplatte hier hat eine 1,5-G-Partition für Windows 2000
(mit dem FAT-Dateisystem). Die Info oben zeigt, dass die
Windows-Partition bis zum Zylinder 195 reicht. Also werden wir den Rest
(sprich ab Zylinder 196) für OpenBSD reservieren. Du kannst auch den
Startsektor von OpenBSD berechnen (3148740), indem du den Startsektor
(63) und die Größe (3148677) zu der bereits vorhandenen Partition (hier
Windows 2000 mit FAT) addierst.

<p>
Du kannst das Festplattenlayout entweder in Form von
Zylindern/Köpfen/Sektoren oder reiner Sektoren
editieren. Was einfacher ist, hängt davon ab, was du tun willst. In
diesem Fall ist es wahrscheinlich einfacher, das CHS-Format zu benutzen.
Wenn du die erste Partition auf der Festplatte erstellst, ist die
Verwendung reiner Sektoren wahrscheinlich einfacher.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk: 1> <b>e 1</b>
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused      
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>a6</b>
  Do you wish to edit in CHS mode? [n] <b>y</b>
  BIOS Starting cylinder [0 - 2433]: [0] <b>196</b>
  BIOS Starting head [0 - 254]: [0] <b><i>Enter</i></b>
  BIOS Starting sector [1 - 63]: [0] <b>1</b>
  BIOS Ending cylinder [0 - 2433]: [0] <b>2433</b>
  BIOS Ending head [0 - 254]: [0] <b>254</b>
  BIOS Ending sector [1 - 63]: [0] <b>63</b>
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 2434/255/63 [39102336 Sectors]
  Offset: 0       Signature: 0xAA55
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
  *0: 0B      0   1   1 -    195 254  63 [          63:     3148677 ] Win95 FAT-32
   1: A6    196   0   1 -   2433 254  63 [     3148740:    35953470 ] OpenBSD     
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused      
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused      
  fdisk:*1> <b>p m</b>
  Disk: wd0       geometry: 2434/255/63 [19093 Megabytes]
  Offset: 0       Signature: 0xAA55
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
  *0: 0B      0   1   1 -    195 254  63 [          63:        1537M] Win95 FAT-32
   1: A6    196   0   1 -   2433 254  63 [     3148740:       17555M] OpenBSD     
   2: 00      0   0   0 -      0   0   0 [           0:           0M] unused      
   3: 00      0   0   0 -      0   0   0 [           0:           0M] unused      
  fdisk:*1>
</pre></td></tr></table>

<a name="trackoffset"></a>
<p>
Bei Plattformen, die fdisk verwenden, ist es wichtig, dass die erste
Partition die erste Spur der Platte auslässt; <i>in diesem Fall</i> also
mit Sektor <tt>63</tt> beginnt. Dies variiert von Maschine zu Maschine
und Plattensystem zu Plattensystem.
Wenn eine OpenBSD-Partition so erstellt wurde, dass sie mit einen Offset
von <tt>0</tt> beginnt, wird diese Partitionstabelle am Ende von dem
OpenBSD-<a href="faq14.html#Boot386">Partitionbootrecord</a>
überschrieben. Das System könnte zwar weiterhin bootfähig sein, wird
aber sehr schwer verwaltbar sein. Diese Konfiguration
<i>wird weder empfohlen noch ist sie unterstützt</i>.

<p>
Wie du sehen kannst wurde der Prompt um einen Asterisk (<tt>*</tt>)
erweitert, um anzuzeigen, dass du noch nicht gespeicherte Änderungen
gemacht hast. Wie wir an der Ausgabe von <tt>p&nbsp;m</tt> sehen können,
haben wir unsere Windows-Partition nicht geändert: Wir haben den Rest
der Platte erfolgreich an OpenBSD vergeben. Wir sind somit fast fertig.

<p>
Was wir noch nicht gemacht haben, ist die Partition als aktiv zu
markieren, sodass nach dem nächsten Neustart OpenBSD geladen wird:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>f 1</b>
  Partition 1 marked active.
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 2434/255/63 [39102336 Sectors]
  Offset: 0       Signature: 0xAA55
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 0B      0   1   1 -    195 254  63 [          63:     3148677 ] Win95 FAT-32
  *1: A6    196   0   1 -   2433 254  63 [     3148740:    35953470 ] OpenBSD     
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused      
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused      
  fdisk:*1>
</pre></td></tr></table>

<p>
Und nun sind wir so weit, dass wir unsere Änderungen speichern können:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>w</b>
  Writing MBR at offset 0.
  wd0: no disk label
  fdisk: 1> <b>q</b>
</pre></td></tr></table>

<p>

<a name="disklabel"></a>
<h3>Ein Disklabel erzeugen</h3>
Im nächsten Schritt benutzen wir
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>,
um die OpenBSD-Partition aufzuteilen. Mehr Details über Disklabel
finden sich in der
<a href="faq14.html#disklabel">FAQ 14, Disklabel</a>.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Here is the partition information you chose:

  Disk: wd0       geometry: 2586/240/63 [39100320 Sectors]
  Offset: 0       Signature: 0xAA55
           Starting       Ending       LBA Info:
   #: id    C   H  S -    C   H  S [       start:      size   ]
  ------------------------------------------------------------------------
   0: 06    0   1  1 -  202 239 63 [          63:     3069297 ] DOS > 32MB
  *1: A6  203   0  1 - 2585 239 63 [     3069360:    36030960 ] OpenBSD
   2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
   3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused

  You will now create an OpenBSD disklabel inside the OpenBSD MBR
  partition. The disklabel defines how OpenBSD splits up the MBR partition
  into OpenBSD partitions in which filesystems and swap space are created.

  The offsets used in the disklabel are ABSOLUTE, i.e. relative to the
  start of the disk, NOT the start of the OpenBSD MBR partition.

  # Inside MBR partition 1: type A6 start 3148740 size 35953470
  Treating sectors 3148740-39102210 as the OpenBSD portion of the disk.
  You can use the 'b' command to change this.

  Initial label editor (enter '?' for help at any prompt)
  > <b>?</b>
  Available commands:
    ? [command] - show help                  n [part] - set mount point
    a [part]    - add partition              p [unit] - print partitions
    b           - set OpenBSD boundaries     q        - quit & save changes
    c [part]    - change partition size      r        - display free space
    D           - reset label to default     s [path] - save label to file
    d [part]    - delete partition           u        - undo last change
    e           - edit drive parameters      w        - write label to disk
    g [d | u]   - [d]isk or [u]ser geometry  X        - toggle expert mode
    l [unit]    - print disk label header    x        - exit & lose changes
    M           - disklabel(8) man page      z        - delete all partitions
    m [part]    - modify partition

  Suffixes can be used to indicate units other than sectors:
          'b' (bytes), 'k' (kilobytes), 'm' (megabytes), 'g' (gigabytes)
          'c' (cylinders), '%' (% of total disk), '&' (% of free space).
  Values in non-sector units are truncated to the nearest cylinder boundary.
  >
</pre></td></tr></table>

<p>
Wieder sollten wir uns einige Kommandos näher ansehen:
<ul>
<li><b><tt>p</tt></b> - Zeigt das aktuelle Disklabel. Du kannst
<tt>k, m</tt> oder <tt>g</tt> für Kilobytes, Megabytes oder Gigabytes
benutzen.

<li><b><tt>D</tt></b> - Löscht jegliches existierende Disklabel und
erzeugt ein neues Disklabel, das nur die aktuelle OpenBSD-Partition
beinhaltet. Das kann nützlich sein, wenn die Festplatte vorher ein
Disklabel hatte und die OpenBSD-Partition mit einer anderen
Größe erneut erzeugt wurde - das alte Disklabel wird vielleicht
nicht gelöscht und könnte Verwirrung stiften.

<li><b><tt>m</tt></b> - Modifiziert einen existierenden Eintrag in
einem Disklabel. Überschätze nicht, was das hier bedeutet. Obwohl es
die Größe einer Disklabelpartition ändern kann, ändert es das
Dateisystem auf der Festplatte NICHT. Diese Option zu benutzen und zu
erwarten, dass damit bereits existierende Partitionen in der Größe
verändern werden, ist ein guter Weg, große Datenmengen zu verlieren.
Jedoch kann diese Option zusammen mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=growfs&amp;sektion=8"
>growfs(8)</a> verwendet werden, um eine Partition zu vergrößern.

</ul>

<p>
Es ist wichtig, deine Festplatte gut aufzuteilen. Die Antwort auf die
Frage »Wie soll ich mein System partitionieren?« ist »Genauso,
wie du es benötigst«. Das ist nun mal von Fall zu Fall verschieden.
Es gibt keine universelle Antwort. Wenn du nicht sicher bist, wie du
dein System partitionieren sollst, sieh dir
<a href="#Partitioning">diesen Abschnitt</a> an.

<p>
In diesem System haben wir für OpenBSD über 17 G verfügbar. Das ist eine
Menge Platz und wir werden wahrscheinlich nie den ganzen Platz brauchen.
Wir werden also mit der Platzverteilung etwas großzügig sein. Es ist
besser, ein paar hundert Megabytes zu viel und unbenutzt zu haben als
auch nur ein Kilobyte zu wenig.

<p>
Auf der Rootdisk <b>muss</b> die Partition a für das Rootdateisystem
angelegt werden. Normalerweise wirst du ebenfalls die Swappartition b
anlegen wollen, wobei du auch auf sie verzichten kannst, wenn du dir
wirklich sicher bist, dass dein System niemals den physischen Speicher
voll ausreizen wird. Wenn eine Partition b auf der Rootdisk vorhanden
ist, dann wird sie automatisch als Swappartition verwendet.
Swappartitionen auf anderen Platten können manuell in <i>/etc/fstab</i>
eingetragen werden.

<p>
Nach einer kleinen Denkpause haben wir uns entschieden, die Menge
der Partitionen zu erzeugen, die wir für die empfohlenen
separaten Dateisysteme brauchen (<tt>/, /tmp, /var, /usr, /home</tt>,
zusätzlich zu einer Swappartition):
<ul>
<li><i><b>wd0a: /</b></i> (Root) - 150 M.  Sollte mehr als genug sein.
<li><i><b>wd0b: </b></i>(Swap) - 300 M.
<li><i><b>wd0d: /tmp</b></i> - 120 M.  <tt>/tmp</tt> wird für die
  Übersetzung von Software gebraucht, 120&nbsp;M wird für die meisten
  Anwendungen genug sein.
<li><i><b>wd0e: /var</b></i> - 80 M.  Wenn das ein Web- oder Mail-Server
  wäre, müsste diese Partition viel größer sein - aber das machen wir
  hier ja nicht.
<li><i><b>wd0g: /usr</b></i> - 6 G.  Wir brauchen den Platz hier für
  viele Benutzeranwendungen und außerdem wollen wir das System
  aktualisieren und neu erzeugen können, wenn es notwendig wird. Der
  <a href="faq15.html#Ports">Ports-Tree</a> wird sich hier auch
  befinden und schon vor der Installation von Ports bereits 250 Megabyte
  Platz brauchen. Wenn du viele Applikationen aus den
  <a href="faq15.html#Ports">Ports</a> bauen willst, statt dich der
  fertig kompilierten <a href="faq15.html#PkgMgmt">Packages</a> zu
  bedienen, benötigst du hier sehr viel mehr Platz.
<li><i><b>wd0h: /home</b></i> - 4 G.  Das lässt jede Menge Platz
  für Benutzerdateien.
</ul>

Wenn du das alles zusammenzählst, wirst du bemerken, dass über
6 G Plattenplatz ungenutzt ist! Ungenutzter Platz tut uns nicht weh
und gibt uns die Flexibilität, die Dinge in Zukunft zu vergrößern. Du
brauchst mehr <i>/tmp</i>? Erstelle eine neue Partition im ungenutzten
Bereich, formatiere diese mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8"
>newfs(8)</a> und ändere
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5"
><i>/etc/fstab</i></a> so ab, dass die neue Partition unter <i>/tmp</i>
gemountet wird - Problem gelöst.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>p m</b>
  #             size        offset  fstype [fsize bsize  cpg]
  OpenBSD area: 1537.5M-19092.9M; size: 17555.4M; free: 17555.4M
    c:      19092.9M          0.0M  unused      0     0
    i:       1498.7M          0.0M  MSDOS
  > <b>a a</b>
  offset: [3148740] <b><i>Enter</i></b>
  size: [35953470] <b>150m</b>
  Rounding to cylinder: 321300
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/</b>
  > <b>a b</b>
  offset: [3470040] <b><i>Enter</i></b>
  size: [35632170] <b>300m</b>
  Rounding to cylinder: 626535
  FS type: [swap] <b><i>Enter</i></b>
  > <b>a d</b>
  offset: [4096575] <b><i>Enter</i></b>
  size: [35005635] <b>120m</b>
  Rounding to cylinder: 257040
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/tmp</b>
  > <b>a e</b>
  offset: [4353615] <b><i>Enter</i></b>
  size: [34748595] <b>80m</b>
  Rounding to cylinder: 176715
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/var</b>
  > <b>a g</b>
  offset: [4530330] <b><i>Enter</i></b>
  size: [34571880] <b>6g</b>
  Rounding to cylinder: 12594960
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr</b>
  > <b>a h</b>
  offset: [17125290] <b><i>Enter</i></b>
  size: [21976920] <b>4g</b>
  Rounding to nearest cylinder: 8401995
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/home</b>
  > <b>p m</b>
  OpenBSD area: 1537.5M-19092.9M; size: 17555.4M; free: 6628.4M
  #             size        offset  fstype [fsize bsize  cpg]
    a:           156.9M          1537.5M  4.2BSD   2048 16384    1 # /
    b:           305.9M          1694.4M    swap                   
    c:         19092.9M             0.0M  unused      0     0      
    d:           125.5M          2000.3M  4.2BSD   2048 16384    1 # /tmp
    e:            86.3M          2125.8M  4.2BSD   2048 16384    1 # /var
    g:          6149.9M          2212.1M  4.2BSD   2048 16384    1 # /usr
    h:          4102.5M          8362.0M  4.2BSD   2048 16384    1 # /home
    i:          1537.4M             0.0M   MSDOS                   
  > <b>q</b>
  Write new label?: [y] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Du wirst bemerken, dass wir die <i>c</i>-Partition scheinbar komplett
ignoriert haben. Diese Partition ist deine gesamte Festplatte - versuche
sie nicht zu verändern. Du wirst außerdem bemerkt haben, dass wir
die <i>i</i>-Partition nicht angelegt haben, denn das ist die bereits
existierende Windows-2000-Partition. Partitionen werden hier mit
Ausnahme von <i>a</i> (Root), <i>b</i> (Swap) und <i>c</i> (gesamte
Festplatte) keinem vorbestimmten Buchstaben zugewiesen: Der Rest der
Partitionen (über den Buchstaben <i>p</i>) kann verwendet werden, wie
man will.

<h3>Deine Mountpunkte konfigurieren und deine Dateisysteme
formatieren</h3>

Jetzt kommt die finale Konfiguration deiner Mountpunkte. Wenn du deine
Mountpunkte mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
konfiguriert hast, reicht es in diesem Schritt aus, deine Auswahl zu
bestätigen. Falls du das noch nicht getan hast, kannst du sie hier nun
angeben.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Mount point for wd0d (131584 KBytes)? (or 'none' or 'done') [/tmp] <b><i>Enter</i></b>
  Mount point for wd0e (90624 KBytes)? (or 'none' or 'done') [/var] <b><i>Enter</i></b>
  Mount point for wd0g (6656 MBytes)? (or 'none' or 'done') [/usr] <b><i>Enter</i></b>
  Mount point for wd0h (4096 MBytes)? (or 'none' or 'done') [/home] <b><i>Enter</i></b>
  Mount point for wd0d (131584 KBytes)? (or 'none' or 'done') [/tmp] <b>done</b>
  No more disks to initialize.

  OpenBSD filesystems:
  wd0a /
  wd0d /tmp
  wd0e /var
  wd0g /usr
  wd0h /home

  The next step *DESTROYS* all existing data on these partitions!
  Are you really sure that you're ready to proceed? [no] <b>y</b>
  newfs: reduced number of fragments per cylinder group from 20080 to 19992 to enl
  arge last cylinder group
  /dev/rwd0a: 156.9MB in 321300 sectors of 512 bytes
  5 cylinder groups of 39.05MB, 2499 blocks, 5120 inodes each
  newfs: reduced number of fragments per cylinder group from 16064 to 15992 to enl
  arge last cylinder group
  /dev/rwd0d: 125.5MB in 257040 sectors of 512 bytes
  5 cylinder groups of 31.23MB, 1999 blocks, 4096 inodes each
  newfs: reduced number of fragments per cylinder group from 11040 to 10992 to enl
  arge last cylinder group
  /dev/rwd0e: 86.3MB in 176712 sectors of 512 bytes
  5 cylinder groups of 21.47MB, 1374 blocks, 2816 inodes each
  /dev/rwd0g: 6149.9MB in 12594960 sectors of 512 bytes
  31 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0h: 4102.5MB in 8401992 sectors of 512 bytes
  21 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/wd0a on /mnt type ffs (rw, asynchronous, local, ctime=Tue Oct 21 00:36:28 2
  008)
  /dev/wd0h on /mnt/home type ffs (rw, asynchronous, local, nodev, nosuid, ctime=T
  ue Oct 21 00:36:28 2008)
  /dev/wd0d on /mnt/tmp type ffs (rw, asynchronous, local, nodev, nosuid, ctime=Tu
  e Oct 21 00:36:28 2008)
  /dev/wd0g on /mnt/usr type ffs (rw, asynchronous, local, nodev, ctime=Tue Oct 21
   00:36:28 2008)
  /dev/wd0e on /mnt/var type ffs (rw, asynchronous, local, nodev, nosuid, ctime=Tu
  e Oct 21 00:36:28 2008)
</pre></td></tr></table>

<p>
Du fragst dich wahrscheinlich, wieso dich das Installationsprogramm
schon wieder nach den Mountpunkten fragt. Damit ist es möglich, Fehler
oder Probleme mit der bisherigen Auswahl einfach auszuräumen. Der
Installationsprozess wird zum Beispiel doppelte Mountpunkte einfach
löschen. Im Programm disklabel kannst du solche Doppeleingaben
machen - daher muss das überprüft werden. Eine solche
doppelte Nennung wird zu Partitionen ohne Mountpunkt führen, denen
du dann neue Mountpunkte zuweisen musst, wenn du den Platz darin
benutzen willst.

<p>
Wie du sehen kannst, lautet die vorgegebene Antwort auf die Frage
"Are you really sure that you are ready to proceed?" »no«: Du
musst also ausdrücklich »yes« antworten, damit das Programm weitermacht
und deine Partitionen formatiert. Wenn du das nicht tust, landest du
wieder in der Shell und könntest die Installation erneut starten, indem
du »install« eingibst oder einfach erneut mit deiner Bootdisk
hochfährst.

<p>
An diesem Punkt werden nun alle deine Dateisysteme formatiert. Wie lange
das dauert hängt von der Größe der Partitionen und der Geschwindigkeit
deiner Festplatte ab.

<a name="Hostname"></a>
<h3>4.5.3 - Den Hostnamen des Systems setzen</h3>
<p>
Du musst dem System nun seinen Hostnamen geben. Dieser Wert - neben dem
DNS-Domänennamen (<a href="#Network">weiter unten</a> angegeben) - wird
in der Datei <tt>/etc/myname</tt> gespeichert, die beim normalen Booten
des Systems ausgelesen wird. Wenn du den FQDN des Systems nicht setzt,
wird der vorgeschlagene Wert my.domain benutzt.

<p>
Es ist wichtig, diesen Namen jetzt zu setzen, da er beim ersten Booten
des Systems nach der Installation dabei benutzt wird, die
kryptographischen Schlüssel zu erzeugen. Diese Erzeugung geschieht
unabhängig davon, ob das Netzwerk konfiguriert ist oder nicht.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  System hostname (short form, e.g. 'foo'): <b>puffy</b>
</pre></td></tr></table>

<a name="Network"></a>
<h3>4.5.4 - Das Netzwerk konfigurieren</h3>

<p>
Jetzt ist es an der Zeit, dein Netzwerk zu konfigurieren. Das muss
unbedingt geschehen, wenn du eine FTP- oder NFS-basierte Installation
durchführen willst, da die Daten dafür notwendig sind. Hier
ein Beispieldurchlauf für die Netzwerkkonfiguration.
In diesem Beispiel hängt an einem über DHCP zu konfigurierendes
Interface (fxp0) ein Kabelmodem. Das andere Interface führt zu unserem
internen Netzwerk und wird statisch konfiguriert.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Configure the network? [yes] <b><i>Enter</i></b>
  Available interfaces are: fxp0 xl0.
  Which one do you wish to initialize? (or 'done') [fxp0] <b>xl0</b>
  Symbolic (host) name for xl0? [puffy] <b><i>Enter</i></b>
  The media options for xl0 are currently
          media: Ethernet autoselect (100baseTX full-duplex)
  Do you want to change the media options? [no] <b><i>Enter</i></b>
  IPv4 address for xl0 (or 'dhcp')? <b>199.185.137.55</b>
  Netmask? [255.255.255.0] <b><i>Enter</i></b>
  IPv6 address for xl0? (or 'rtsol' or 'none') [none] <b><i>Enter</i></b>
  Available interfaces are: fxp0.
  Which one do you wish to initialize? (or 'done') [fxp0] <b><i>Enter</i></b>
  Symbolic (host) name for fxp0? [puffy] <b><i>Enter</i></b>
  The media options for fxp0 are currently
          media: Ethernet autoselect (10baseT half-duplex)
  Do you want to change the media options? [no] <b><i>Enter</i></b>
  IPv4 address for fxp0? (or 'none' or 'dhcp') <b>dhcp</b>
  Issuing hostname-associated DHCP request for fxp0.
  DHCPDISCOVER on fxp0 to 255.255.255.255 port 67 interval 1
  DHCPOFFER from 73.34.136.1
  DHCPREQUEST on fxp0 to 255.255.255.255 port 67
  DHCPACK from 73.34.136.1
  bound to 69.241.244.76 -- renewal in 1800 seconds.
  IPv6 address for fxp0? (or 'rtsol' or 'none') [none] <b><i>Enter</i></b>
  No more interfaces to initialize.
  DNS domain name? (e.g. 'bar.com') [my.domain] <b>example.com</b>
  DNS nameserver? (IP address or 'none') [68.87.77.130 68.87.72.130 68.87.75.194] <b><i>Enter</i></b>
  Use the nameserver now? [yes] <b><i>Enter</i></b>
  Default route? (IP address, 'dhcp' or 'none') [dhcp] <b><i>Enter</i></b>
  Edit hosts with ed? [no] <b><i>Enter</i></b>
  Do you want to do any manual network configuration? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
<b>HINWEIS: </b>Nur <b>ein</b> Interface kann während der
Installation einfach mit DHCP konfiguriert werden. Es wird Fehler geben,
wenn du das mehrmals versuchst. Die anderen Interfaces musst du dann
nach der Installation per Hand konfigurieren.

<p>
Nun setzen wir das Passwort für root:
<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
Password for root account? (will not echo) <b><i>pAssWOrd</i></b>
Password for root account? (again) <b><i>pAssWOrd</i></b>
</pre></td></tr></table>
<p>
Verwende ein sicheres Passwort für das Root-Benutzerkonto. Du wirst
weitere Benutzerkonten anlegen, wenn das System gebootet wurde. Aus
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=passwd&amp;sektion=1">passwd(1)</a>:
<pre>
    The new password should be at least six characters long and not purely
    alphabetic.  Its total length must be less than _PASSWORD_LEN (currently
    128 characters).  A mixture of both lower and uppercase letters, numbers,
    and meta-characters is encouraged.
</pre>

<a name="InstMedia"></a>
<h3>4.5.5 - Das Installationsmedium auswählen</h3>

<p>
Nachdem dein Netzwerk eingerichtet ist, hast du die Chance, deine
Einstellungen per Hand zu justieren.

<p>
Danach bekommst du die Chance, dein Installationsmedium auszuwählen.
Die Optionen sind unten aufgelistet.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Let's install the sets!
  Location of sets? (cd disk ftp http or 'done') [cd] <b><i>Enter</i></b>
  Available CD-ROMs are: cd0.
</pre></td></tr></table>

<p>
In diesem Beispiel installierst du von CD-ROM. Dazu wird eine Liste der
Geräte erzeugt, die auf deiner Maschine als CD-ROM identifiziert
wurden. Die meisten Leute haben aber nur eins. Wähle einfach
das Gerät aus, von dem aus du OpenBSD installieren willst.

<p>
<b>HINWEIS: </b>Nicht alle Plattformen bieten alle
Installationsmöglichkeiten an. In diesem Fall unterstützt die
OpenBSD/i386-Plattform keine NFS-Installation, sodass diese nicht in
der Liste mit aufgeführt wird.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available CD-ROMs are: cd0.
  Which one contains the install media? (or 'done') [cd0] <b><i>Enter</i></b>
  Pathname to the sets?  (or 'done') [4.4/i386] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Hier wirst du gefragt, in welchem Verzeichnis sich die Dateisets
befinden - auf der offiziellen CD-ROM oder einer mit
<tt>install44.iso</tt> selbst erstellten CD ist das <tt>4.4/i386/</tt>.

<a name="Filesets"></a>
<h3>4.5.6 - Dateisets auswählen</h3>

<p>
Nun ist es an der Zeit auszuwählen, welche Dateisets du haben willst.
Eine Beschreibung dieser Pakete findest du im <a href="#FilesNeeded"
>nächsten Abschnitt</a>. Die Dateien, die das Installationsprogramm
findet, werden auf dem Bildschirm angezeigt.
Deine Aufgabe ist es anzugeben, welche Dateien du haben willst.
Standardmäßig sind bis auf die X-Dateisets alle markiert - manche
fortgeschrittene Anwender wollen aber wirklich nur das absolute Minimum
haben, mit dem OpenBSD noch funktioniert: <tt>base44.tgz</tt>,
<tt>etc44.tgz</tt> und <tt>bsd</tt>. Die meisten Anwender wollen
entweder die standardmäßig ausgewählten Dateisets oder alle
Dateisets haben. Das Beispiel unten zeigt eine komplette Installation
mit allen Paketen.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Select sets by entering a set name, a file name pattern or 'all'. De-select
  sets by prepending a '-' to the set name, file name pattern or 'all'. Selected
  sets are labeled '[x]'.

          [X] bsd
          [X] bsd.rd
          [ ] bsd.mp
          [X] base44.tgz
          [X] etc44.tgz
          [X] misc44.tgz
          [X] comp44.tgz
          [X] man44.tgz
          [X] game44.tgz
          [ ] xbase44.tgz
          [ ] xetc44.tgz
          [ ] xshare44.tgz
          [ ] xfont44.tgz
          [ ] xserv44.tgz
  Set name? (or 'done') [bsd.mp] <b>all</b>

          [X] bsd
          [X] bsd.rd
          [X] bsd.mp
          [X] base44.tgz
          [X] etc44.tgz
          [X] misc44.tgz
          [X] comp44.tgz
          [X] man44.tgz
          [X] game44.tgz
          [X] xbase44.tgz
          [X] xetc44.tgz
          [X] xshare44.tgz
          [X] xfont44.tgz
          [X] xserv44.tgz
</pre></td></tr></table>

<p>
Du kannst hier alle möglichen Sachen machen. <tt>-x*</tt> zum
Beispiel würde alle X-Komponenten entfernen, falls du es dir nochmal
anders überlegst. In diesem Fall wollen wir aber alle Sets. Wenn das
System auch mit viel weniger Sets läuft, wird empfohlen, entweder die
standardmäßigen Vorgaben oder alles zu installieren.
Weitere Details über die Auswahl der Sets befinden sich
<a href="#FilesNeeded">hier</a>.

<p>
Nachdem du deine gewünschten Dateisets ausgewählt hast, wirst du noch
einmal gefragt, ob du die gewählten Dateisets wirklich entpacken willst
- dann werden sie installiert. Es wird ein Fortschrittsbalken
angezeigt, der dir zeigt, wie lange das Ganze noch etwa dauert. Die
Dauer hängt selbstverständlich stark von der Geschwindigkeit deines
Systems ab, den Dateisets, die du installieren willst, und der
Geschwindigkeit des Installationsmediums. Somit liegt die Dauer je
nachdem irgendwo zwischen ein paar Minuten und ein paar Stunden.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Set Name? (or 'done') [done] <b><i>Enter</i></b>
  Ready to install sets? [yes] <b><i>Enter</i></b>

  Getting bsd ...
  100% |**************************************************|  6700 KB    00:03    
  Getting bsd.rd ...
  100% |**************************************************|  5404 KB    00:01    
  Getting bsd.mp ...
  100% |**************************************************|  6750 KB    00:02    
  Getting base44.tgz ...
  100% |**************************************************| 42904 KB    00:27    
  Getting etc44.tgz ...
  100% |**************************************************|   631 KB    00:00    
  Getting misc44.tgz ...
  100% |**************************************************|  2866 KB    00:02    
  Getting comp44.tgz ...
  100% |**************************************************| 78575 KB    00:43    
  Getting man44.tgz ...
  100% |**************************************************|  7552 KB    00:07    
  Getting game44.tgz ...
  100% |**************************************************|  2552 KB    00:01    
  Getting xbase44.tgz ...
  100% |**************************************************|  9486 KB    00:05    
  Getting xetc44.tgz ...
  100% |**************************************************| 75434       00:00    
  Getting xshare44.tgz ...
  100% |**************************************************|  2672 KB    00:05    
  Getting xfont44.tgz ...
  100% |**************************************************| 34747 KB    00:16    
  Getting xserv44.tgz ...
  100% |**************************************************| 19816 KB    00:10    
  Location of sets? (cd disk ftp http or 'done') [done] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
An dieser Stelle hast du die Möglichkeit, weitere Dateien von anderen
Quellen zu installieren (einschließlich <a href="#site">individuellen
Dateisets</a>). Gib <tt>done</tt> ein, wenn du alle benötigten Dateisets
installiert hast.

<a name="Finish"></a>
<h3>4.5.7 - Zum Ende kommen</h3>

Als nächstes werden dir einige Fragen bezüglich der Einstellungen
deines installierten Systems gestellt. Die erste ist, ob
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a>
beim Hochfahren gestartet werden soll. Üblicherweise möchtest du, dass
sshd(8) läuft - gelegentlich vielleicht auch nicht. Wenn deine
Verwendung von OpenBSD keinen Gebrauch für sshd(8) hat, liegt ein
kleiner theoretischer Sicherheitsvorteil vor, wenn er nicht läuft.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Start sshd(8) by default? [yes] <b>y</b>
</pre></td></tr></table>

<p>
(Falls du deine Meinung später änderst, passe deine
<a href="faq10.html"><tt>/etc/rc.conf.local</tt></a> oder
<tt>/etc/rc.conf</tt> an.)

<p>
Dir wird nun die Möglichkeit gegeben,
<a href="faq6.html#OpenNTPD">OpenNTPD</a> beim Booten zu starten.
OpenNTPD ermöglicht es, mit geringen Auswirkungen die Uhr deines
Computers genau synchron zu halten, und hat eine standardmäßige
Konfiguration, die für die Verwendung von vielen Benutzern ausreicht.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Start ntpd(8) by default? [no] <b>yes</b>
  NTP server? (hostname or 'default') [default] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Solltest du einen lokalen Timeserver haben, kannst du ihn an dieser
Stelle angeben. Wenn du »default« ausgewählt hast, dann wird OpenNTPD
<tt>pool.ntp.org</tt> verwenden. Hierbei handelt es sich um eine
riesige Sammlung kostenlos erreichbarer Timeserver.
(Falls du deine Meinung später änderst, passe deine
<a href="faq10.html"><tt>/etc/rc.conf.local</tt></a> und/oder
<tt>/etc/ntpd.conf</tt> an.)

<p>
Auf einigen Systemen wirst du nun gefragt, ob du auf dem
System X laufen lassen willst. Wenn du mit »Y« antwortest, wird die
Datei <tt>/etc/sysctl.conf</tt> so modifiziert, dass abhängig von deiner
Plattform <tt>machdep.allowaperture=1</tt> oder
<tt>machdep.allowaperture=2</tt> darinsteht. Einige Plattformen werden
diese Frage überhaupt nicht stellen. Wenn du nicht vorhast, X auf
diesem System zu verwenden oder du dir noch unsicher bist, solltest du
mit N antworten, da du die benötigte Änderung später immer noch ganz
einfach machen kannst, indem du <tt>/etc/sysctl.conf</tt> änderst.
Es liegt ein potenzieller Sicherheitsvorteil vor, wenn der
Aperturetreiber
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xf86&amp;sektion=4">xf86(4)</a>
deaktiviert bleibt, da die Grafikengine moderner Grafikkarten
verwenden werden könnten, um den Speicher zu modifizieren, ohne dass
der Prozessor etwas dagegen unternehmen könnte.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you expect to run the X Window System? [no] <b>y</b>
</pre></td></tr></table>

<p>
Als nächstes wirst du gefragt, ob du eine
<a href="faq7.html#SerCons">serielle Konsole</a> an diesem Computer
anstatt von einer Standardtastatur und einem -monitor betreiben willst.
Wenn du »<tt>yes</tt>« auswählst und ein paar weitere einfache Fragen
beantwortest, werden
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8">/etc/boot.conf</a></tt>
und
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5">/etc/ttys</a></tt>
automatisch für dich angepasst.
Die meisten Benutzer werden hier jedoch die Voreinstellung
<b><tt>no</tt></b> verwenden.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Change the default console to com0? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Deine letzte Aufgabe ist es, deine entsprechende Zeitzone einzustellen.
Abhängig davon, wo deine Maschine steht, kann es mehrere richtige
Antworten geben. Im folgenden Beispiel benutzen wir <tt>US/Eastern</tt>,
könnten aber auch <tt>EST5EDT</tt> oder <tt>US/Michigan</tt> benutzen
und zum selben Ergebnis kommen. Wenn man <tt>?</tt> drückt, bekommt
man eine Liste der Auswahlmöglichkeiten.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Saving configuration files......done.
  Generating initial host.random file ......done.
  What timezone are you in? ('?' for list) [Canada/Mountain] <b>?</b>
  Africa/      Chile/       GB-Eire      Israel       NZ-CHAT      UCT
  America/     Cuba         GMT          Jamaica      Navajo       US/
  Antarctica/  EET          GMT+0        Japan        PRC          UTC
  Arctic/      EST          GMT-0        Kwajalein    PST8PDT      Universal
  Asia/        EST5EDT      GMT0         Libya        Pacific/     W-SU
  Atlantic/    Egypt        Greenwich    MET          Poland       WET
  Australia/   Eire         HST          MST          Portugal     Zulu
  Brazil/      Etc/         Hongkong     MST7MDT      ROC          posix/
  CET          Europe/      Iceland      Mexico/      ROK          posixrules
  CST6CDT      Factory      Indian/      Mideast/     Singapore    right/
  Canada/      GB           Iran         NZ           Turkey       zone.tab
  What timezone are you in? ('?' for list) [Canada/Mountain] <b>US</b>
  What sub-timezone of 'US' are you in? ('?' for list) <b>?</b>
  Alaska          Central         Hawaii          Mountain        Samoa
  Aleutian        East-Indiana    Indiana-Starke  Pacific
  Arizona         Eastern         Michigan        Pacific-New
  Select a sub-timezone of 'US' ('?' for list): <b>Eastern</b>
  Setting local timezone to 'US/Eastern'...done
</pre></td></tr></table>

<p>
Wenn du auf besonders genaue Zeitangaben aus bist, möchtest du
vielleicht <a href="faq8.html#NTPerror">das hier</a> lesen.

<p>
Die letzten Schritte für das System sind die Erzeugung des
<tt>/dev</tt>-Verzeichnisses (was auf manchen Maschinen ganz schön lange
dauert - insbesondere, wenn du nur wenig RAM besitzt) und die
Installation des Bootblocks.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Making all device nodes...done.
  Installing boot block...
  boot: /mnt/boot
  proto: /usr/mdec/biosboot
  device: /dev/rwd0c
  /usr/mdec/biosboot: entry point 0
  proto bootblock size 512
  /mnt/boot is 3 blocks x 16384 bytes
  fs block shift 2; part offset 3148740; inode block 24, offset 1832
  using MBR partition 1: type 166 (0xa6) offset 3148740 (0x300bc4)
  done.

  CONGRATULATIONS! Your OpenBSD install has been successfully completed!
  To boot the new system, enter halt at the command prompt. Once the
  system has halted, reset the machine and boot from the disk.
  # <b>halt</b>
  syncing disks... done

  The operating system has halted.
  Please press any key to reboot.
</pre></td></tr></table>

<p>
OpenBSD ist jetzt auf deinem System installiert und bereit für den
ersten Boot, aber vorher ...

<p>

<h4>Bevor du neustartest</h4>
Nun ist dein System also installiert und fertig zum ersten Booten,
um danach noch konfiguriert zu werden. Zuvor wäre es allerdings
ratsam, die <a href="../../de/errata.html">Errataseite</a> zu
überprüfen, ob es nicht irgendwelche Bugs gibt, die dich sofort
betreffen könnten.

<p>
Ein Trick, um eine Konfiguration vor dem ersten Start durchführen
zu können, ist
<pre>
    # <b>/mnt/usr/sbin/chroot /mnt</b>
</pre>
beim Shellprompt einzugeben.
Dies setzt deine Mountpunkte so, wie sie nach einem normalen Neustart
deines frisch installierten Systems sein werden.
Du kannst grundlegende Systemkonfiguration durchführen, z.&nbsp;B.
Benutzer hinzufügen, Mountpunkte ändern etc.

<h4>Nach dem Neustart</h4>

<p>
Eines der ersten Dinge, die du nach der Installation lesen solltest, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=afterboot&amp;sektion=8">afterboot(8)</a>.

<p>
Die folgenden Links könnten ebenfalls recht nützlich sein:
<ul>
<li><a href="faq10.html#AddDelUser">Benutzer unter OpenBSD
  hinzufügen</a>
<li><a href="faq6.html#Setup">Erste Netzwerkkonfiguration</a>
<li><a href="faq2.html#ManPages">Manualseiten von nützlichen/häufigen
  Befehlen</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD-Manualseiten
  im Web</a>
<li><a href="faq15.html">Das OpenBSD-Packages- und -Ports-System, um
  Software zu installieren</a>
</ul>

<h4>Noch eine Sache ...</h4>
Die OpenBSD-Entwickler bitten dich darum,
<a href="#SendDmesg">eine Kopie deiner Dmesg einzuschicken</a>. Das
hilft den Entwicklern und schlussendlich auch den Anwendern.

<p>
<a name= "FilesNeeded"></a>
<h2>4.6 - Welche Dateien werden zur Installation benötigt?</h2>
<!-- XXXrelease -->

<p>
Die komplette OpenBSD-Installation ist in eine Vielzahl einzelner
<i>Dateisets</i> aufgeteilt. Nicht jede Verwendung verlangt nach jedem
Dateiset.  Hier ist eine Übersicht:
<p>
<ul>
  <li><b><i>bsd</i></b>          - Dies ist der Kernel. <b>Zwingend
    notwendig</b>
  <li><b><i>bsd.mp</i></b> - Multi-Prozessor-Kernel (SMP) (nur auf
     einigen Plattformen)
  <li><b><i>bsd.rd</i></b> - <a href="#bsd.rd">RAM-Disk-Kernel</a>
  <li><b><i>base44.tgz</i></b>   - Enthält das Basissystem von OpenBSD.
    <b>Zwingend notwendig</b>
  <li><b><i>etc44.tgz</i></b>    - Enthält alle Dateien in /etc.
    <b>Zwingend notwendig</b>
  <li><b><i>comp44.tgz</i></b>    - Enthält den Compiler und alle seine
    Anwendungen, Headers und Bibliotheken. <b>Empfohlen</b>
  <li><b><i>man44.tgz</i></b>    - Enthält alle Manualseiten.
    <b>Empfohlen</b>
  <li><b><i>misc44.tgz</i></b>   - Enthält alle misc-, info- und
    setup-Dokumentationen.
  <li><b><i>game44.tgz</i></b>   - Enthält die Spiele für OpenBSD.
  <li><b><i>xbase44.tgz</i></b>  - Enthält die Basisdateien für X11.
  <li><b><i>xetc44.tgz</i></b>   - Enthält die /etc/X11- und
    /etc/fonts-Konfigurationsdateien.
  <li><b><i>xfont44.tgz</i></b>  - Enthält den X11-Fontserver und
    Schriftarten.
  <li><b><i>xserv44.tgz</i></b>  - Enthält die X11-X-Server.
  <li><b><i>xshare44.tgz</i></b> - Enthält Manualseiten, lokale
    Einstellungen, Includes etc. für X.
</ul>

Das <b>etc44.tgz</b>- und das <b>xetc44.tgz</b>-Set werden nicht als
Teil eines Upgrades installiert, sondern nur als Teil einer kompletten
Installation, sodass jegliche Änderungen, die du vorgenommen hast,
nicht verloren gehen.
Du musst deine Verzeichnisse <tt>/etc</tt>, <tt>/dev</tt> und
<tt>/var</tt> manuell aktualisieren.

<p>
Selbst wenn du nicht vorhast, X auf deinem System zu benutzen, kann es
sein, dass <a href="faq15.html">Packages</a> von Drittanbietern die
Grafikbibliotheken aus <b>xbase44.tgz</b> voraussetzen. Solche
Anwendungen können normalerweise zufrieden gestellt werden, indem
<b>xbase44.tgz</b> installiert wird - die restlichen X-Komponenten
werden nicht benötigt.


<p>
<a name="Partitioning"></a>
<a name= "SpaceNeeded"></a>  <!-- XXXobsolete tag -->
<h2> 4.7 - Wie viel Platz brauche ich für eine
OpenBSD-Installation?</h2>
<!-- XXXrelease -->

<p>
Es ist offensichtlich, dass die Antwort auf diese Frage gewaltig von
deiner Verwendung des Systems abhängig ist.
Jedoch können diese Werte als ein <i>Start</i>-Punkt angesehen werden:

<blockquote><pre>
(root)             60 MB
/usr               500 MB (kein X) oder 660 MB (mit X)
/var               25 MB
/tmp               50 MB
swap               32 MB
</pre></blockquote>

Dies sind die minimal empfohlenen Dateisystemgrößen für eine gesamte
Systeminstallation.
Die Werte beinhalten zusätzlichen Platz um dir zu ermöglichen, ein
typisches Heimsystem zu nutzen, das eine Internetverbindung hat - aber
nicht sehr viel mehr.

<p>
Behalte die folgenden Fakten jedoch im Hinterkopf:
<ul>
<li>Dies sind Minimalwerte.
Plattenspeicher ist zurzeit recht günstig. Der Versuch, das System auf
die kleinstmögliche Platte zu quetschen, ist normalerweise den Aufwand
nicht wert. Für bestimmte Einsatzgebiete können diese Werte kleiner
gemacht werden. Du musst aber experimentieren.
<li>Diese Angaben enthalten NICHT den Ports-Tree.
<li>Wenn du planst, eine Menge Software von Drittanbietern zu
installieren, wähle deine <tt>/usr</tt>-Partition groß!
Wie groß hängt selbstverständlich von deiner Verwendung ab.
<li>Für ein System, das eine Menge E-Mails oder Webseiten handhabt (die
in <tt>/var/mail</tt> und <tt>/var/www</tt> gespeichert werden),
solltest du deine <tt>/var</tt>-Partition bedeutend vergrößern oder lege
sie auf separate Partitionen.
<li>Für ein Mehrbenutzersystem, das eine Menge Aufzeichnungen erzeugt,
solltest du deine <tt>/var</tt>-Partition noch größer wählen oder
eine separate Logpartition (<tt>/var/log</tt>) einrichten.
<li>Wenn du planst, <a href="faq5.html">den Kernel oder das ganze System
aus dem Quelltext neu zu erzeugen</a>, sollte deine
<tt>/usr</tt>-Partition deutlich größer ausfallen - 4 G ist keine
schlechte Idee.
<li>Das Kompilieren von einigen <a href="faq15.html#Ports">Ports</a> vom
Quelltext aus kann gewaltig viel Speicher auf deinen <tt>/usr</tt>-
und <tt>/tmp</tt>-Partitionen in Anspruch nehmen. Dies ist ein weiterer
Grund, warum wir empfehlen, stattdessen
<a href="faq15.html#PkgMgmt">vorkompilierte Packages</a> zu
nutzen.
<li>Die <tt>/tmp</tt>-Partition wird während des Kompilierens von Ports
und anderen Dingen benutzt. Die Größe hängt also davon ab, was du damit
machen willst. 50 MB mag für viele Leute viel sein, aber einige
große Applikationen brauchen 100 MB und mehr <tt>/tmp</tt>-Platz.

<li>Die b-Partition deines ersten Laufwerks wird automatisch deine
System-Swappartition. Viele Leute folgen einer alten Bauernregel, die
besagt, dass deine Swappartition doppelt so viel Speicher haben sollte
wie dein RAM. Diese Regel ist Unsinn. Auf modernen Systemen wäre das
SEHR VIEL Swap. Die meisten Leute bevorzugen eher, dass ihre Systeme
niemals swappen. Du möchtest sicher nicht erleben, dass dein System
jemals weder freien RAM noch freien Speicher im Swap hat; normalerweise
hast du aber ohnehin genügend RAM im System, so dass es ohnehin nicht
auslagern muss. Falls du einen Flashspeicher als Disk verwendest, wirst
du ohnehin auf eine Swappartition verzichten wollen. Setze ein, was für
deine Ansprüche am besten ist. Falls du dich verkalkuliert hast, kannst
du nachträglich eine weitere Swappartition in <i>/etc/fstab</i>
eintragen oder <a href="faq14.html#SwapFile">in eine Datei
auslagern</a>.
<li>Swap- und <tt>/var</tt>-Speicher werden genutzt, um
Coredumps des Systems im Fall eines
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crash&amp;sektion=8">crash(8)</a>
zu speichern.
Falls dies eine Überlegung von dir ist, sollte dein Swapbereich ein
wenig größer sein als der Speicherplatz des Hauptspeichers, den du
jemals in deinem System verwenden wirst.
Beim Neustart versucht
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=savecore&amp;sektion=8">savecore(8)</a>,
den Inhalt der Swappartition in eine Datei unter
<tt>/var/crash</tt> zu speichern. Also wieder einmal: Wenn dies wichtig
für dich ist, sollte deine <tt>/var</tt>-Partition über genug
<i>freien Speicher</i> verfügen, um diese Dumpdateien halten zu
können.
Sei realistisch - nur wenige Entwickler möchten sich deine
1-GB-Dumpdatei ansehen. Solltest du also nicht vorhaben, einen
Absturz lokal zu überprüfen, ist dies vermutlich nicht wichtig für dich.
<li>Zumindest ein paar Editoren verwenden <tt>/var/tmp</tt>, um
ungespeicherte Änderungen an Dateien zu hinterlegen. Meist wird der
benötigte Platz größer sein als die größte Datei, die du editieren
möchtest. Solltest du also vorhaben, 500 MB große Dateien zu editieren,
dann musst du die <tt>/var</tt>- oder <tt>/var/tmp</tt>-Partition
deutlich größer ausfallen lassen, als du anfänglich geplant hattest.
</ul>

<p>
Es gibt mehrere Hauptgründe, anstelle von nur ein oder zwei
Dateisystemen mehrere separate Dateisysteme zu benutzen:

<ul>
<li><b>Sicherheit</b>: Du kannst einige Dateisysteme als nosuid,
  nodev, noexec, readonly etc. markieren. Das wird vom
  Installationsprozess erledigt, wenn du die oben beschriebenen
  Partitionen benutzt.
<li><b>Stabilität</b>: Ein Anwender oder ein Amok laufendes Programm kann
  ein Dateisystem zumüllen, wenn sie darauf Schreibrechte haben. Deine
  kritischen Programme - dann selbstverständlich auf einem anderen
  Dateisystem laufend - werden nicht unterbrochen.
<li><b>Geschwindigkeit</b>: Ein Dateisystem, in das dauernd
  hineingeschrieben wird, kann schnell fragmentieren (glücklicherweise
  ist das FFS-Dateisystem, das von OpenBSD benutzt wird, nicht für
  so was anfällig).
<li><b>Integrität</b>: Wenn ein Dateisystem aus irgendeinem Grund defekt
  ist, sind deine anderen Dateisysteme immer noch in Ordnung.
<li><b>Größe</b>: Viele Maschinen haben Grenzen im Bezug auf den
  Ort, von dem aus das ROM den Kernel laden kann. In einigen Fällen
  kann die Grenze sehr niedrig sein (504 M für ältere 486), in
  anderen Fällen ist die Grenze recht hoch (zum Beispiel 2 G, 8 G
  oder 128 G auf i386-Systemen). Da sich der Kernel irgendwo in der
  Rootpartition befinden kann, muss die gesamte Rootpartition
  innerhalb dieser Grenze liegen. Mehr Details gibt es in
  <a href="faq14.html#LargeDrive">diesem Kapitel</a>. Eine gute
  Richtlinie ist, deine /-Partition einfach komplett unterhalb der
  ersten 2 GB zu lassen - es sei denn du weißt, dass deine Plattform
  (und besonders deine Maschine) damit umgehen kann.
</ul>

<p>
Noch ein paar Gedanken zur Partitionierung:
<ul>
 <li>Bei deinem ersten Versuch und einem experimentellen System ist eine
   große <tt>/</tt>-Partition und Swap das Einfachste, bis du
   weißt, wie viel Platz du brauchst. Dadurch wirst du einige der
   Standardsicherheitsmechanismen opfern, die OpenBSD bietet, die
   separate Dateisysteme für <tt>/, /tmp, /var, /usr</tt> und
   <tt>/home</tt> benötigen. Du solltest mit deiner ersten
   OpenBSD-Installation jedoch nicht in produktiven Einsatz gehen.
 <li>Ein sich im Internet befindliches oder anderweitig angreifbares
   System sollte eine separate Partition für <tt>/var</tt> haben (und
   vielleicht sogar eine separate für <tt>/var/log</tt>) für die
   Logdateien.
 <li>Eine <tt>/home</tt>-Partition ist durchaus nützlich. Neue Version
   des OS? Alles andere löschen und neu machen, aber die
   <tt>/home</tt>-Partition einfach unberührt lassen. Denke aber
   trotzdem daran, eine Sicherungskopie deiner Konfigurationsdateien
   anzulegen!
 <li>Eine separate Partition für alles, was eine Menge
   Dateien erzeugen kann, kann man gegebenenfalls schneller formatieren
   und neu anlegen, als alle Dateien zu löschen. Siehe auch die
   FAQ zum Thema <a href="faq5.html#ProbObjPt">Vom Quelltext aus
   erzeugen</a> für ein Beispiel (<tt>/usr/obj</tt>).
 <li>Wenn du dein System aus irgendeinem Grund vom Quelltext aus neu
   erzeugen willst, sollte der Quelltext sich in <tt>/usr/src</tt>
   befinden. Wenn du kein separates Dateisystem für <tt>/usr/src</tt>
   hast, dann sorge unbedingt dafür, dass du in <tt>/usr</tt> genug
   Platz hast.
 <li>Ein oftmals vergessener Punkt: Du musst auf deinem System
   <b>nicht</b> allen Platz sofort vergeben! Da du jetzt vermutlich kaum
   noch eine Festplatte unter 20 GB finden wirst, kann es durchaus Sinn
   machen, einfach ein bisschen Platz zu lassen. Wenn dir dann eine
   Partition zu klein wird, kannst du dann einfach aus deinem
   ungenutzten Platz eine neue Partition erstellen, deine existierende
   Partition auf die neue
   <a href="faq10.html#DupFS">duplizieren</a>, die
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab</a>
   ändern und auf die neue Partition verweisen lassen. Nach dem erneuten
   Mounten hast du bereits mehr Platz.
 <li>Wenn du deine Partitionen zu klein wählst, wirst du das
   vermutlich später bereuen, wenn es an der Zeit ist, dein System
   auf den neuesten Stand zu bringen.
<li>Wenn du sehr große Partitionen anlegst, solltest du im Hinterkopf
   behalten, dass die Dateisystemüberprüfung mittels
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
   ungefähr 1 M RAM für jedes Gigabyte der Dateisystemgröße benötigt
   und zudem sehr zeitaufwendig ist; oder sogar nicht ausführbar auf
   älteren, langsameren Systemen (greife bitte auf
   <a href="faq14.html#LargeDrive">diese Sektion</a> zurück).
 <li>Wenn du deinen Benutzern erlaubst, auf <tt>/var/www</tt> zu
   schreiben (z.&nbsp;B. persönliche Webseiten), möchtest du es
   vielleicht auf eine separate Partition legen, sodass du
   <a href="faq10.html#Quotas">Quotas</a> verwenden kannst, um den
   verwendbaren Speicher zu begrenzen. Wenn sie die Partition füllen,
   sind keine anderen Teile des Systems betroffen.
 <li>Wenn du möchtest, dann kannst du auch wie in <a
   href="http://www.openbsd.org/cgi-bin/man.cgi?query=daily&amp;sektion=8"
   >daily(8)</a> beschrieben eine <tt>/altroot</tt>-Partition anlegen.
   Mit dieser kannst du eine tägliche Kopie deiner <tt>/</tt>-Partition
   anlegen, wodurch du eine zusätzliche Sicherung deines Kernels und
   deiner Konfigurationsdateien in <tt>/etc</tt> hast, falls irgendwann
   einmal etwas mit deiner Rootpartition passieren sollte.
   Selbstverständlich muss die <tt>/altroot</tt>-Partition mindestens so
   groß sein wie <tt>/</tt>. Solltest du eine zweite Festplatte haben und
   auch den Rest der Platte duplizieren (entweder Software-<a
   href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4"
   >raid(4)</a> oder eine kontinuierliche Sicherung mit <a
   href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8"
   >dump(8)</a>/<a
   href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8"
   >restore(8)</a>), könntest du einfach von dieser Platte booten,
   nachdem du die erste ausgebaut hast.
</ul>


<p>
<a name= "Multibooting"></a>
<h2>4.8 - Multibooting OpenBSD/i386</h2>

Multibooting bedeutet, dass man mehrere Betriebssysteme auf einem
Computer hat und auf irgendeine Art und Weise auswählen kann, welches OS
gebootet werden soll. Das ist <i>keine</i> unbedeutende Aufgabe! Wenn du
nicht verstehst, was du da machst, könntest du am Ende große
Datenmengen von deinem Computer gelöscht haben. Neuen OpenBSD-Benutzern
wird <i>dringend</i> dazu geraten, mit einer leeren Festplatte auf einer
extra hierfür freigestellten Maschine anzufangen und dann mit der
gewünschten Konfiguration auf einer nicht im Einsatz befindlichen
Maschine zu üben, bevor eine Multiboot-Konfiguration auf einer
wichtigen Maschine versucht wird. <a href="faq14.html">FAQ
14</a> hat weitere Informationen über den OpenBSD-Bootprozess.

<p>
Es kann nur eine der vier möglichen <i>primären</i> MBR-Partitionen zum
Booten von OpenBSD genutzt werden (das heißt, dass erweiterte
Partitionen nicht unterstützt werden).

<p>
Hier sind einige Multibootmöglichkeiten:

<h3>Aktive Partitionen markieren</h3>
Dies ist die wahrscheinlich am häufigsten übersehende und
doch ab und zu beste Lösung für das Multibooting. Markiere einfach
die aktive Partition in welchem OS auch immer du dich befindest so, dass
sie diejenige ist, die beim nächsten Booten standardmäßig
gebootet wird. So gut wie jedes OS bietet ein Programm, mit dem das
bewerkstelligt werden kann; OpenBSDs ist <a
href="faq14.html#fdisk">fdisk(8)</a> - ähnlich genannte Programme gibt
es unter Windows 9x und DOS sowie unter vielen anderen
Betriebssystemen. Dies kann sehr wünschenswert für Betriebssysteme oder
Systeme sein, die sehr lange zum Herunterfahren und Neustarten brauchen
- du kannst sie markieren und das System neustarten, dann weggehen,
eine Tasse Kaffee holen und dann zum System wiederkehren, das so
hochgefahren ist, wie du es wolltest - kein Warten auf den magischen
Moment, in dem du das nächste OS auswählen musst.

<h3>Bootdiskette</h3>
Wenn du ein System hast, das nicht häufig zum Booten von OpenBSD
verwendet wird (oder nicht möchtest, dass andere Benutzer des Computers
mitbekommen, dass sich irgendwas geändert hat), ziehe die Verwendung
einer Bootdiskette in Betracht. Verwende einfach eine der <a
href="#MkFlop">normalen OpenBSD-Installationsdisketten</a> und erstelle
eine <tt>/etc/boot.conf</tt>-Datei (ja, du musst außerdem ein
<tt>/etc</tt>-Verzeichnis auf der Diskette anlegen) mit folgendem
Inhalt:

<pre>
     boot hd0a:/bsd
</pre>

Hiermit wird das System veranlasst, von Festplatte 0, OpenBSD-Partition
a mit Kerneldatei <tt>/bsd</tt> zu booten. Denke daran, dass du mit
einer Zeile wie dieser auch von anderen Laufwerken booten kannst:
<tt>boot hd2a:/bsd</tt> zum Beispiel bootet von der dritten Festplatte
deines Systems. Um OpenBSD zu booten, lege die Diskette ein und starte
neu. Um das andere OS zu booten, nehme die Diskette aus dem Laufwerk und
starte neu.

<p>
In diesem Fall wird das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>-Programm
geladen - es sucht nach <tt>/etc/boot.conf</tt> und liest sie
aus. Die Zeile <tt>boot hd0a:/bsd</tt> weist boot(8) zu, von wo aus
der Kernel geladen werden soll - in diesem Fall von der ersten
Festplatte, die das BIOS sieht. Behalte im Hinterkopf, dass nur eine
kleine Datei (<tt>/boot</tt>) von der Diskette geladen wird - das System
lädt den gesamten Kernel von der Festplatte, sodass ungefähr nur fünf
Sekunden zum Bootprozess hinzugefügt werden.

<h3>Windows NT/2000/XP NTLDR</h3>

Um OpenBSD und Windows NT/2000/XP starten zu können, kannst du den
NTLDR benutzen: den Bootloader von NT. Um mit NT einen Multiboot
durchführen zu können, benötigst du
eine Kopie des OpenBSD-Partitionbootrecords (PBR).
Nachdem installboot ausgeführt wurde, kannst du ihn mit einem Aufruf
wie dem folgenden unter Verwendung von <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1"
>dd(1)</a> in eine Datei kopieren:

<pre>
	# <strong>dd if=/dev/rsd0a of=openbsd.pbr bs=512 count=1</strong>
</pre>

Hinweis: Jetzt ist ein guter Zeitpunkt, dich daran zu erinnern,
dass es eine wirklich schlechte Idee ist, Befehle einzutippen, die du
nicht verstehst. Dieser Aufruf wird auf den meisten Computern nicht
direkt verwendet werden können. Es bleibt nun dem Leser überlassen,
ihn an seine Maschine anzupassen.

<p>
Starte nun NT und platziere <tt>openbsd.pbr</tt> auf C:. Füge eine
Zeile wie die folgende am Ende von <tt>C:\BOOT.INI</tt> hinzu:

<pre>
	c:\openbsd.pbr="OpenBSD"
</pre>

<p>
Nach einem Neustart solltest du OpenBSD im NT-Loadermenü
auswählen können. Zum NTLDR gibt es im
<a href="http://www.tburke.net/info/ntldr/ntldr_hacking_guide.htm">NTLDR
Hacking Guide</a> mehr Informationen.

<p>
Auf Windows XP kannst du die Bootinformationen auch mit Hilfe der GUI
editieren; siehe auch das
<a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;289022">XP Boot.ini HOWTO</a>.

<p>
Programme stehen zur Verfügung, die dir viele von diesen Tätigkeiten
abnehmen - zum Beispiel <a
href="http://www.winimage.com/bootpart.htm">BootPart</a>.
Dieses Programm kann unter Windows NT/2000/XP ausgeführt werden und
lädt den OpenBSD-PBR, platziert ihn auf deine NT/2000/XP-Partition und
fügt ihn zur <tt>C:\BOOT.INI</tt> hinzu.

<p>
Hinweis: Der Windows-NT/2000/XP-Bootloader ist nur in der Lage,
Betriebssysteme von der primären Festplatte zu booten.
Du kannst ihn nicht verwenden, um OpenBSD von der zweiten Festplatte zu
laden.

<p>
<h3>Andere Bootloader</h3>

<p>
Zu einigen anderen Bootloadern, die von OpenBSD-Anwendern erfolgreich
eingesetzt worden sind, gehören
<a href="http://gag.sourceforge.net/">GAG</a>,
OS-BS,
<a href="http://www.ranish.com/part/">The Ranish Partition Manager</a>
und <a href="http://www.gnu.org/software/grub/">GRUB</a>.

<p>
<h3>OpenBSD und Linux (i386)</h3>
<!-- XXXversion -->

<p>
Bitte lies dir <a
href="ftp://ftp.openbsd.org/pub/OpenBSD/4.4/i386/INSTALL.linux"
>INSTALL.linux</a> durch, um genaue Informationen über die
Zusammenarbeit zwischen OpenBSD und Linux zu bekommen.

<h3>Probleme mit Zeitzonen</h3>
OpenBSD erwartet, dass die Echtzeituhr des Rechners auf UTC
(Universal Coordinated Time) gestellt ist.
Einige andere Betriebssysteme erwarten, dass die Echtzeituhr auf Ortszeit
gestellt ist.  Offensichtlich können Probleme entstehen, wenn du
beide Betriebssysteme auf dem selben Computer verwendest, da eines
von beiden sehr wahrscheinlich angepasst werden muss.
Mehr Informationen wie man dies tut gibt es unter
<a href="faq8.html#TimeZone">FAQ 8 - Warum geht meine Uhr um mehrere
Stunden falsch?</a>.

<a name= "SendDmesg"></a>
<h2>4.9 - Nach der Installation deine Dmesg an dmesg@openbsd.org
schicken</h2>

<p>
Um es nochmal allen ins Gedächtnis zu rufen: Es ist wichtig für
die OpenBSD-Entwickler, im Auge zu behalten, welche Art von Hardware
funktioniert und welche eben nicht perfekt funktioniert.

<p>
Ein Zitat aus /usr/src/etc/root/root.mail
<blockquote><pre>
If you wish to ensure that OpenBSD runs better on your machines, please do us
a favor (after you have your mail system configured!) and type something like:
 # dmesg | mail -s "Sony VAIO 505R laptop, apm works OK" dmesg@openbsd.org
so that we can see what kinds of configurations people are running.  As shown,
including a bit of information about your machine in the subject or the body
can help us even further.  We will use this information to improve device driver
support in future releases.  (Please do this using the supplied GENERIC kernel,
not for a custom compiled kernel, unless you're unable to boot the GENERIC
kernel.  If you have a multi-processor machine, dmesg results of both GENERIC.MP
and GENERIC kernels are appreciated.)  The device driver information we get from
this helps us fix existing drivers. Thank you!
</pre></blockquote>

<p>
Stelle sicher, dass du nicht nur E-Mails von deinem Konto senden sondern
auch empfangen kannst - für den Fall, dass dich ein Entwickler
kontaktieren will, um etwas zu testen oder um deine Konfiguration zum
Laufen zu bringen. Es ist nicht wichtig, dass du die E-Mail von einem
Rechner mit OpenBSD verschickst. Wenn der Rechner also keine E-Mail
empfangen kann, dann gib einfach

<pre>
$ dmesg | mail your-account@yourmail.dom
</pre>
ein und leite dann diese Nachricht weiter an
<pre>
 dmesg@openbsd.org
</pre>
wobei <tt>your-account@yourmail.dom</tt> dein reguläres E-Mail-Konto
ist.

<p>
<b>ANMERKUNGEN</b>

<ul>
<li>Bitte schicke nur Dmesgs des GENERIC-Kernels. Selbst kompilierte
Kernel sind nicht hilfreich, wenn Gerätetreiber fehlen.
<li>Wenn du ein Multiprozessorsystem hast und den GENERIC.MP-Kernel
einsetzt, so sind die dmesg-Ausgaben sowohl des GENERIC-Kernels als
auch des GENERIC.MP-Kernels für die Entwickler hilfreich. Sende also
bitte beide in getrennten E-Mails.
<li>Die Dmesgs landen auf einem Computer, der das Spamblocksystem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=spamd&amp;sektion=8">spamd</a>
einsetzt. Dies könnte dazu führen, dass deine Dmesg vom Mailserver für
eine gewisse Zeit nicht angenommen wird. Habe Geduld - nach einer
halben Stunde, Stunde oder so wird sie durchkommen.
</ul>

<p>
Der hier beschriebene Weg ist einfach umzusetzen. Falls du aber nicht
vorhast, E-Mailverkehr auf deinem OpenBSD-System einzurichten, solltest
du dennoch die Dmesg an die Entwickler senden. Speicher die Ausgabe
von dmesg als Textdatei.

<pre>
$ dmesg > ~/dmesg.txt
</pre>

Übertrage diese Datei (per FTP/scp/Disketten/Carrier-Pigeon/...) auf
das System, mit dem du E-Mails versendest. Die Ausgabe von dmesg wird
automatisch verarbeitet. Sei also sicher, dass du auf folgende Punkte
achtest, wenn du andere E-Mail-Clients/Systeme verwendest:
<ul>
<li>Stelle deinen E-Mail-Client auf »nur Text« ein; versende keine
    HTML-formatierten E-Mails.
<li>Stelle erzwungene Zeilenumbrüche aus. Viele E-Mail-Clients sind
    so eingerichtet, dass alle 72 Zeichen ein Zeilenumbruch erfolgt
    (die Norm für Mailinglisten).
<li>Achte darauf, dass dein E-Mail-Client die Nachrichten nicht
    für diesen Fließtext-Unsinn formatiert.
<li>Sende die Ausgabe von dmesg nicht als Dateianhang. Schreib die
    Ausgabe von dmesg stattdessen direkt in die E-Mail.
</ul>


<a name="AddFileSet"></a>
<h2>4.10 - Ein Dateiset nach der Installation hinzufügen</h2>
<!-- XXXversion -->
»Oh nein! Ich habe bei der Installation eines der Dateisets vergessen!«
<p>
Manchmal merkt man erst nach Abschluss der Installation, dass man
<tt>comp44.tgz</tt> (oder irgendeine andere Systemkomponente) DOCH
benötigt. Kein Problem: Es gibt zwei einfache Wege, diese Komponenten
aus der Installation noch nachträglich einzuspielen:

<h3>Indem man den Upgradeprozess benutzt</h3>
Boote einfach von deinem Installationsmedium (CD-ROM oder Diskette) und
wähle Upgrade (und nicht Install). Wenn du zur Liste mit den
Dateisets kommst, wähle die Sets, die du beim ersten Mal vergessen
hast. Wähle deine Quelle aus und lass die Installation beginnen.

<h3>Indem man tar(1) benutzt</h3>
Die Installationsdateien sind lediglich komprimierte tar-Dateien. Du
kannst sie dementsprechend am Root (/) des Dateisystems auspacken:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # cd /
  # tar xzvphf comp44.tgz
</pre></td></tr></table>

<p>
Du darfst NICHT die Option <tt>p</tt> im oben genannten Kommando
vergessen: Die Dateirechte werden sonst nicht richtig gesetzt!
<p>
Ein häufig gemachter Fehler ist, zu denken, man könne
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_add&amp;sektion=1">pkg_add(1)</a>
benutzen, um fehlende Dateisets einzuspielen. Das funktioniert aber
nicht. pkg_add(1) ist das <a href="faq15.html#PkgMgmt">Werkzeug für die
Packagesverwaltung</a>, um Software von Drittanbietern zu installieren.
Es verarbeitet Packagedateien, jedoch keine normalen Tardateien wie
zum Beispiel die Installationssets.

<p>
Wenn du das <tt>xbase</tt>-Dateiset das erste Mal auf deinem System mit
tar(1) installierst und das System nicht neustartest, musst du den Cache
für die Shared Librarys nach der Installation mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ldconfig&amp;sektion=8"
>ldconfig(8)</a> aktualisieren. Um die X-Bibliotheken zum Cache
hinzuzufügen:

<blockquote><pre>
# <b>ldconfig -m /usr/X11R6/lib</b>
</pre></blockquote>

Alternativ dazu kannst du auch einfach das System neustarten, da dies
automatisch vom <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8"
>rc(8)</a>-Startskript erledigt wird.


<a name="bsd.rd"></a>
<h2>4.11 - Was ist bsd.rd?</h2>

<b><tt>bsd.rd</tt></b> ist ein RAM-Disk-Kernel. Diese Datei kann sehr
nützlich sein; viele Entwickler lassen sie mit Absicht immer im
Quellverzeichnis ihres Dateisystems.

<p>
Ihn einen RAM-Disk-Kernel zu nennen, beschreibt das Rootdateisystem
des Kernels - es ist kein physikalisches Laufwerk. Die Werkzeuge,
die nach dem Booten von <tt>bsd.rd</tt> genutzt werden können, befinden
sich im Kernel und werden aus einem RAM-basierten Dateisystem geladen.
<tt>bsd.rd</tt> enthält auch ein brauchbares Set an Werkzeugen für
Systemwartung und -installation.

<p>
Auf manchen Plattformen ist <tt>bsd.rd</tt> sogar die bevorzugte
Installationstechnik. Du platzierst diesen Kernel in ein vorhandenes
Dateisystem, bootest ihn und führst daraus die Installation aus. Auf den
meisten Plattformen kannst du, falls du eine ältere Version von OpenBSD
hast, eine neue Version von <tt>bsd.rd</tt> per FTP holen, damit booten
und eine neue Version von OpenBSD installieren - ohne eine Diskette oder
CD-ROM zu benutzen.

<p>
Hier zum Beispiel das Booten von <tt>bsd.rd</tt> auf einem i386-System:

<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Using Drive: 0 Partition: 3
  reading boot.....
  probing: pc0 com0 com1 apm mem[639k 255M a20=on]
  disk: fd0 hd0+
  &gt;&gt; OpenBSD/i386 BOOT 3.02
  boot&gt; <b>boot hd0a:/bsd.rd</b>
<i>. . . normal boot to install . . .</i>
</pre></td></tr></table>

Wie schon gesagt wirst du in das Installationsprogramm geführt. Du
kannst selbstverständlich auch auf die Shell gehen, um dein System zu
pflegen oder zu administrieren.
<p>
Die einfache Regel, um <tt>bsd.rd</tt> booten zu können, lautet:
Tausche <tt>/bsd</tt> durch <tt>bsd.rd</tt> aus - was auch immer das auf
deiner Plattform heißen mag.


<a name="InstProb"></a>
<h2>4.12 - Allgemeine Installationsprobleme</h2>

<a name="cpq16m"></a>
<h3>4.12.1 - Mein Compaq erkennt nur 16 M RAM</h3>
<i>Einige</i> Compaq-Systeme haben das Problem, dass der gesamte
Hauptspeicher von <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>OpenBSDs Secondstage-Bootloader</a> nicht ordentlich erkannt wird und
nur 16 M erkannt und von OpenBSD verwendet werden. Du kannst dieses
Problem beheben, indem du entweder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"><tt>/etc/boot.conf</tt></a>
erstellst/editierst oder Befehle am <tt>boot></tt>-Prompt eingibst,
bevor OpenBSD lädt. Falls du eine Maschine mit 64 M RAM hast,
aber OpenBSD nur die ersten 16 M erkennt, wird der Befehl

<pre>
     machine mem +0x3000000@0x1000000
</pre>
48 M (<tt>0x3000000</tt>) nach den ersten 16 M (<tt>0x1000000</tt>)
hinzufügen. Typischerweise würdest du den oben angegeben
Befehl am Installationsprompt <tt>boot></tt> der Diskette/CD-ROM eingeben,
neustarten und eine <tt>/etc/boot.conf</tt>-Datei anlegen, die den oben
angegebenen Befehl beinhaltet, sodass alle zukünftigen Starts des
Systems den ganzen verfügbaren Speicher erkennen können, wenn du
ein System mit diesem Problem hättest.

<p>
Es wurde ebenfalls berichtet, dass ein ROM-Update dieses Problem auf
<i>einigen</i> Systemen löst.

<a name="noboot"></a>
<h3>4.12.2 - Mein i386 bootet nach der Installation nicht</h3>
Deine Installation verlief gut, doch beim ersten Hochfahren erkennst du
keine Anzeichen dafür, dass OpenBSD versucht zu starten. Es existieren
einige bekannte Gründe für dieses Problem:

<ul>
<li><b>Keine Partition wurde in fdisk(8) als aktiv markiert.</b> Um dies
zu beheben, starte das System unter Verwendung der Bootdiskette oder
anderer Medien neu und markiere eine Partition als aktiv
(bootbar). Siehe <a href="faq14.html#fdisk">hier</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">hier</a>.

<li><b>Kein gültiger Bootloader wurde jemals auf die Platte
geschrieben.</b>
Falls du mit »Y« auf die Frage "Use entire disk for OpenBSD?" während
der Installation geantwortet hast oder die <tt>reinit</tt>-Option von
fdisk(8) verwendet hast, wurde der OpenBSD-Bootrecord im
Masterbootrecord der Platte installiert; ansonsten wurde der
existierende Masterbootrecord-Code nicht berührt. Dies wird ein
Problem sein, wenn kein anderer Bootrecord existierte.
Eine Lösung ist, das Installationsmedium wieder zu booten, auf die
Shell zurückzugreifen und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
aufzurufen, um den MBR-Code von der Befehlszeile aus zu aktualisieren:
<pre>
    # fdisk -u wd0
</pre>
Hinweis: Die Updateoption im interaktiven Modus (-e) von fdisk
wird keine Signaturbytes schreiben, die benötigt sind, um die
Platte bootbar zu machen.

<li><b>In einigen wenigen Fällen kann etwas mit der
Secondstage-Bootloaderinstallation schief gelaufen sein.</b> Die
Neuinstallation des Secondstage-Bootloaders wird
<a href="faq14.html#InstBoot">hier</a> besprochen.

</ul>

<a name="sshhang"></a>
<h3>4.12.3 - Meine (ältere, langsamere) Maschine bootet, aber hing
bei der ssh-Schlüsselgenerierung</h3>
Es ist sehr wahrscheinlich, dass dein System einwandfrei funktioniert,
nur dass die ssh-Schlüsselgenerierung eine Weile dauert. Eine
SPARCStation2 oder ein Macintosh Quadra können <i>mehrere Stunden</i>
oder länger in Anspruch nehmen, um die drei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a>-Schritte
auszuführen.
Lass es einfach abschließen - es wird nur ein einziges Mal pro
Installation gemacht.

<p>
Beachte, dass die Standardschlüsselgröße mit 3.8 vergrößert wurde,
sodass die benötigte Zeit für die Generation noch länger geworden
ist als sie bisher schon war. Benutzer von sehr langsamen Maschinen
sollten daher in Betracht ziehen, ihre Schlüssel auf einem anderen
Computer zu erzeugen, diese dann in einer
<a href="#site">site44.tgz</a>-Datei abzulegen und sie mit dem Rest
der Dateisets zu installieren.


<a name="noftplist"></a>
<h3>4.12.4 - Ich bekam die Meldung »Failed to change
directory« als ich die Installation durchführte</h3>

Wenn du eine FTP-Installation eines
<a href="faq5.html#Flavors">Flavors</a> während der
<i>-beta</i>-Phase des OpenBSD-Entwicklungszyklus durchführst, könntest
du dies lesen:

<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>

  Display the list of known ftp servers? [no] <b>yes</b>
  Getting the list from 192.128.5.191 (ftp.openbsd.org)... FAILED
  Failed to change directory.
  Server IP address or hostname?
</pre></td></tr></table>

Dies ist normal und ein erwartetes Verhalten während der
Prerelease-Phase des Zyklus. Das Installationsprogramm sucht nach
der FTP-Liste auf dem primären FTP-Server in einem Verzeichnis, das bis
zum <a href="faq1.html#Next">Releasedatum</a> nicht verfügbar ist, so
dass du die oben genannte Meldung bekommst.

<p>
Verwende einfach eine
<a href="../../de/ftp.html">FTP-Mirrorliste</a>, um deinen
favorisierten FTP-Mirror zu finden, und gib ihn manuell ein, wenn du
gefragt wirst.

<p>
<b>Hinweis: Du solltest die Meldung nicht sehen, wenn du <i>-release</i>
oder von einer CD-ROM installierst.</b>

<a name="blankfdisk"></a>
<h3>4.12.5 - Meine fdisk-Partitionstabelle ist kaputt oder leer!</h3>
Gelegentlich finden Benutzer ein funktionsfähiges System vor,
das aber bei Verwendung von <tt>fdisk wd0</tt> eine vollständig
leere (oder ab und zu vermüllte) Partitionstabelle aufweist.
Dies ist normalerweise verursacht, wenn eine Partition in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
erstellt wurde, die ein Offset von Sektor 0 hat, anstatt dem
<a href="#trackoffset">Offset von einer Spur</a>, den sie haben
sollte (Hinweis: Dies nimmt an, dass es sich um die
<a href="../../de/i386.html">i386</a>- oder
<a href="../../amd64.html">amd64</a>-Plattform handelt. Andere
Plattformen benötigen andere Offsets, einige sogar GAR KEINEN
Offset).
Das System <a href="faq14.html#Boot386">bootet</a> dann unter Verwendung
des PBR und nicht des MBR.

<p>
Obwohl diese Konfiguration funktioniert, kann es ein Wartungsproblem
sein und sollte korrigiert werden.
Um dies zu korrigieren, muss das Dateisystem der Platte normalerweise
von Grund auf neu erstellt werden (obwohl, wenn du WIRKLICH weißt
was du tust, kannst du in der Lage sein, nur dein Disklabel und den
MBR neu zu erstellen und musst nur die erste OpenBSD-Partition der
Festplatte neu errichten).

<a name="site"></a>
<h2>4.13 - Anpassen des Installationsprozesses</h2>
<!-- XXXversion -->

<h3><tt>siteXX.tgz</tt>-Datei</h3>
Mit den OpenBSD-Installationsskripten kann ein benutzererstelltes Set
ausgewählt werden. Dieses Set wird <tt>siteXX.tgz</tt> genannt,
wobei XX für die Releaseversion (z.&nbsp;B. 44) steht. Das
<tt>siteXX.tgz</tt>-Dateiset ist wie die anderen
<a href="#FilesNeeded">Dateisets</a> ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gzip&amp;sektion=1">gzip(1)</a>-komprimiertes
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>-Archiv,
das auf / basiert und wird wie die anderen Sets mit den
Optionen <tt>xzphf</tt> enttart. Dieses Set wird zuletzt nach allen
anderen Dateisets installiert.

<p>
Dieses Dateiset erlaubt es dem Benutzer, Dateien hinzuzufügen oder
Dateien zu überschreiben, die von den normalen Sets installiert
worden sind, um so die Installation oder das Upgrade anpassen zu können.

<p>
Du kannst ebenfalls hostnamenspezifische Installationssets erstellen und
einsetzen. Der Name dieser Installationssets ist wie folgt aufgebaut:
<tt>siteXX-<i>&lt;hostname&gt;.tgz</i></tt> (zum Beispiel
»<tt>site44-puffy.tgz</tt>«).
Hiermit sollte es dir möglich sein, Installationen, Upgrades und
Wiederherstellungen besser an Hosts anzupassen.

<p>
Einige Beispielverwendungen einer <tt>siteXX.tgz</tt>-Datei:
<ul>
<li>Erstelle eine siteXX.tgz-Datei, die alle Änderungen beinhaltet,
die du seit der ersten Installation von OpenBSD gemacht hast. Wenn
du dann das System neu erstellen musst, wählst du einfach siteXX.tgz
während der Neuinstallation aus und alle Änderungen von dir
werden auf dem neuen System nachgebildet.

<li>Erstelle eine Serie maschinenspezifischer Verzeichnisse, die
jeweils eine siteXX.tgz-Datei beinhalten, die wiederum spezifische
Dateien für diese Maschine beinhalten. Installationen von Maschinen
(z.&nbsp;B. Systeme mit unterschiedlichen Grafikkarten) einer bestimmten
Kategorie können durch die Auswahl der passenden siteXX.tgz-Datei
abgeschlossen werden.

<li>Stecke die Dateien, die du routinemäßig auf einen gleichen
oder ähnlichen Weg anpasst, in eine siteXX.tgz-Datei:
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8"><tt>/etc/skel</tt></a>-Dateien,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5"><tt>/etc/pf.conf</tt></a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8"><tt>/var/www/conf/httpd.conf</tt></a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"><tt>/etc/rc.conf.local</tt></a>
etc.
</ul>

<h3><tt>install.site</tt>/<tt>upgrade.site</tt>-Skripte</h3>
Als letzten Schritt im Installations/Upgrade-Prozess wird im
Wurzelverzeichnis des neu installierten/aktualisierten Systems je nach
aktuellem Prozess nach <tt>install.site</tt> oder <tt>upgrade.site</tt>
gesucht und das Skript in einer Umgebung ausgeführt, die auf das
Wurzelverzeichnis des installierten/aktualisierten System
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=8">chroot</a>et
ist. Denke daran, dass das Upgrade von einem gebooteten Dateisystem
aus ausgeführt wird, sodass dein Ziel tatsächlich auf <tt>/mnt</tt>
gemountet ist. Trotzdem kann dein Skript aufgrund des Chroots so
geschrieben werden, als ob es im normalen Wurzelverzeichnis deines
Dateisystems ausgeführt wird. Da das Skript ausgeführt wird, wenn alle
Dateien bereits installiert worden sind, hast du fast volle
Funktionalität deines Systems (allerdings im Singleuser-Modus), wenn
dein Skript läuft.

<p>
Bedenke, dass das <tt>install.site</tt>-Skript in der
<tt>siteXX.tgz</tt>-Datei liegen sollte, während das
<tt>upgrade.site</tt>-Skript vor dem Upgrade in das Wurzelverzeichnis
gelegt werden kann - oder in eine <tt>siteXX.tgz</tt>-Datei.

<p>
Die Skripte können für viele Dinge verwendet werden:
<ul>
<li>Entferne Dateien, die installiert/aktualisiert worden sind, die du
auf dem System aber nicht haben möchtest.
<li>Entferne/aktualisiere/installiere die
<a href="faq15.html#PkgMgmt">Packages</a>, die du auf dem installierten
System haben möchtest.
<li>Erstelle ein <a href="faq14.html#Backup">sofortiges Backup/Archiv</a>
des neuen Systems, bevor du es dem Rest der Welt aussetzt.
<li>Verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rdate&amp;sektion=8">rdate(8)</a>,
um die Systemzeit einzustellen.
</ul>

<p>
Die Kombination von <tt>siteXX.tgz</tt>- und
<tt>install.site/upgrade.site</tt>-Dateien sollen den Benutzern eine
breite Palette von Fähigkeiten bieten, ohne dass sie selbst eigene
Installationssets erstellen müssen.

<p>
Hinweis: Wenn du über einen HTTP-Server installierst, so musst du die
<tt>site*.tgz</tt>-Datei (oder Dateien) in der Datei <tt>index.txt</tt>
im Quellverzeichnis auflisten, damit sie während der Installation als
Option angezeigt wird. Dies gilt nicht für FTP- oder andere
Installationsmethoden.


<a name="Multiple"></a>
<h2>4.14 - Wie kann ich eine Anzahl gleichartiger Systeme
installieren?</h2>
Hier sind einige Anwendungen aufgelistet, die du verwenden kannst, wenn
du mehrere ähnliche OpenBSD-Systemen installieren musst.

<h3><tt>siteXX.tgz</tt>- und <tt>install/upgrade.site</tt>-Dateien</h3>
Siehe den <a href="#site">vorherigen</a> Artikel.

<h3>Von dump(8) wiederherstellen</h3>
Auf den meisten Plattformen beinhaltet das Bootmedium das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>-Programm,
welches verwendet werden kann, um ein Backup zu extrahieren, das mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
erstellt wurde. Du kannst daher von
<a href="#MkFlop">Diskette</a>,
<a href="../../de/orders.html">CD</a> oder
<a href="#bsd.rd">bsd.rd</a>-Datei booten, dann
<a href="faq14.html#fdisk">fdisk</a> und
<a href="faq14.html#disklabel">disklabel</a> ausführen und mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore</a>
die gewünschte Konfiguration von Band oder einem anderen Medium
wiederherstellen und die <a href="faq14.html#InstBoot">Bootblöcke</a>
installieren. Weitere Details gibt es
<a href="faq14.html#Backup">hier</a>.

<h3>Plattenimaging</h3>
Leider existiert kein bekanntes Plattenimaging-Programm, das FFS
unterstützt und so nur den aktiv genutzten Dateispeicher nutzen
könnte. Die meisten der bekannteren Plattenimaging-Lösungen
behandeln OpenBSD-Partitionen als allgemeine Partition und können ein
Image der gesamten Platte erzeugen. Damit erreichst du zwar dein Ziel,
aber verbrauchst für gewöhnlich viel Speicher - eine leere, 10 G große
<tt>/home</tt>-Partition wird 10 G Speicher im Image verbrauchen, selbst
wenn sich dort keine einzige Datei befindet. Während du normalerweise
ein Laufwerksimage auf ein größeres Laufwerk installieren kannst, wirst
du nicht in der Lage sein, den zusätzlichen Speicher direkt zu nutzen.
Du wirst auch nicht in der Lage sein, ein Image auf ein kleineres
Laufwerk zu installieren.

<p>
Falls das eine akzeptable Situation für dich ist, könnte der <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1"
>dd</a>-Befehl deinen Ansprüchen genügen, wenn es darum geht, eine
Platte Sektor für Sektor auf eine andere zu kopieren. Dies bietet dir
die gleiche Funktionalität wie die der kommerziellen Produkte ohne
zusätzliche Kosten.

<a name="getdmesg"></a>
<h2>4.15 - Woher bekomme ich eine dmesg(8), damit ich ein Problem mit
der Installation melden kann?</h2>
Wenn man <a href="../../de/report.html">ein Problem meldet</a>, ist es
entscheidend, eine komplette
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
des Systems einzufügen.
Wie auch immer - oft ist es so, dass du dies machen musst, wenn das
System nicht ordnungsgemäß funktioniert oder nicht installieren
will, sodass du weder Platten-, Netzwerk- oder andere Ressourcen zur
Verfügung hast, um deine Dmesg an die passende
<a href="../../de/mail.html">Mailingliste</a> zu senden. Es gibt aber
andere Wege:

<ul>
<li><b>Diskette:</b> Die Bootdisketten und die CD-ROM haben
genügend Anwendungen, um deine Dmesg auf eine MSDOS-Diskette
zu schreiben, damit eine andere Maschine sie lesen kann. Lege eine
MSDOS-formatierte Diskette in dein Diskettenlaufwerk und führe
folgende Befehle aus:

<pre>
     mount -t msdos /dev/fd0a /mnt
     dmesg > /mnt/dmesg.txt
     umount /mnt
</pre>
Falls du ein anderes OpenBSD-System besitzt, kannst du es ebenfalls
auf eine OpenBSD-kompatible Diskette schreiben - oftmals hat die
Bootdiskette genügend freien Raum, um die Dmesg zu halten. In
dem Fall lasse das <tt>-t msdos</tt> oben weg.

<p>
<li><b>Serielle Konsole:</b>
Eine serielle Konsole verwenden und die Ausgabe auf einer anderen
Maschine abzufangen ist oftmals der beste Weg, um Diagnoseinformationen
erhalten zu können - insbesondere, wenn der Computer direkt nach dem
Hochfahren in einer Panic endet. Neben einem weiteren Computer
benötigst du ebenfalls ein passendes serielles Kabel (oft ein
Nullmodemkabel) und ein Terminalemulator-Programm, das die
Bildschirmausgabe in eine Datei schreiben kann.

<p>
Generelle Informationen über die Einrichtung eines seriellen Terminals
sind <a href="faq7.html#SerCon">an einer anderen Stelle der FAQ</a>
verfügbar; um eine Aufzeichnung der Installation abfangen zu können,
sind in der Regel folgende Befehle ausreichend.

<p><b>i386</b>

<p>
Gib am Bootloaderprompt Folgendes ein:

<p>
<blockquote>
<pre>
boot> <b>set tty com0</b>
</pre>
</blockquote>

<p>
Dies teilt OpenBSD mit, dass die erste serielle Schnittstelle
(in PC-Dokumentationen oft COM1 oder COMA genannt) als serielle Konsole
verwendet werden soll.  Die Standardbaudrate ist 9600.

<p><b>Sparc/Sparc64</b>

<p>
Diese Maschinen starten automatisch mit einer seriellen Konsole, wenn
sie ohne angeschlossene Tastatur gestartet wurden. Falls du Tastatur
und Monitor angeschlossen hast, kannst du das System trotzdem dazu
bringen, eine serielle Konsole zu verwenden, indem du folgende Befehle
am <tt>ok</tt>-Prompt aufrufst.

<p>
<blockquote>
<pre>
ok <b>setenv input-device ttya</b>
ok <b>setenv output-device ttya</b>
ok <b>reset</b>
</pre>
</blockquote>

<p>
<li><b>FTP:</b> Unter bestimmten Umständen und der Voraussetzung,
dass du zuerst dein Netzwerk richtig eingerichtet hast, kann es dir
möglich sein, mit Hilfe des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>-Clients
der Bootdiskette oder CD-ROM, die Dmesg zu einem lokalen
FTP-Server zu senden, von wo aus du sie später wiederholen kannst.
</ul>
<p>

<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq3.html">[Zum Kapitel 3 - Wo man OpenBSD herbekommt]</a>
<a href= "faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[back]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq4.html,v 1.271 ]<br>
$Translation: faq4.html,v 1.151 2008/11/30 11:02:30 paldium Exp $<br>
-->
$OpenBSD: faq4.html,v 1.125 2008/12/01 07:52:51 tobias Exp $
</small>
</body>
</html>

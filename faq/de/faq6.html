<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Netzwerk</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2008 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color="#0000e0">
<a href="index.html">[FAQ-Index]</a>
<a href="faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
<a href="faq7.html">[Zum Kapitel 7 - Tastatur- und Bildschirmkontrollen]</a>
</font>

<h1><font color="#e00000">6 - Netzwerk</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href= "#Intro" >6.1 - Bevor wir weitermachen</a>
<li><a href= "#Setup" >6.2 - Netzwerkkonfiguration</a>
<ul>
  <li><a href="#Setup.if"      >6.2.1 - Netzwerkinterfaces finden und
    einrichten</a>
  <li><a href="#Setup.gateway" >6.2.2 - Standardgateway</a>
  <li><a href="#Setup.resolver">6.2.3 - DNS-Auflösung</a>
  <li><a href="#Setup.myname"  >6.2.4 - Hostname</a>
  <li><a href="#Setup.activate">6.2.5 - Änderungen übernehmen</a>
  <li><a href="#Setup.chkroute">6.2.6 - Routen überprüfen</a>
  <li><a href="#Setup.forward" >6.2.7 - Dein OpenBSD-System als Gateway
    konfigurieren</a>
  <li><a href="#Setup.aliases" >6.2.8 - Interface-Aliases einrichten</a>
</ul>
<li><a href= "#PF"    >6.3 - Wie kann ich mit OpenBSD filtern und eine
    Firewall aufsetzen?</a>
<li><a href= "#DHCP"  >6.4 - Dynamic-Host-Configuration-Protokoll (DHCP)</a>
<ul>
  <li><a href="#DHCPclient">6.4.1 - DHCP-Client</a>
  <li><a href="#DHCPserver">6.4.2 - DHCP-Server</a>
</ul>
<li><a href= "#PPP"   >6.5 - Point-to-Point-Protokoll (PPP)</a>
<li><a href= "#Tuning">6.6 - Tunen von Netzwerkparametern</a>
<li><a href= "#NFS"   >6.7 - NFS benutzen</a>
<li><a href= "#Bridge">6.9 - Aufsetzen einer Bridge mit OpenBSD</a>
<li><a href= "#PXE"   >6.10 - Wie boote ich mit PXE?</a>
<li><a href= "#CARP">6.11 - Das Common-Address-Redundancy-Protokoll (CARP)</a>
<li><a href="#OpenNTPD">6.12 - OpenNTPD verwenden</a>
<li><a href="#Wireless">6.13 - Welche Möglichkeiten stehen mir für
    Drahtlosnetzwerk zur Verfügung?</a>
<li><a href="#Multipath">6.14 - Wie kann ich »equal-cost multipath routing«
    durchführen?</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>6.1 - Bevor wir weitermachen</h2>

<p>
Für den Rest dieses Dokumentes sei gesagt, dass es hilfreich
ist, das Kapitel <a href="faq5.html">Kernelkonfiguration und
Einstellungen</a> der FAQ gelesen und zumindest teilweise verstanden zu
haben. Weiterhin helfen die
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>- und
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1"
>netstat(1)</a>-Manualseiten.

<p>
Wenn du ein Netzwerkadministrator bist, Routingprotokolle aufsetzt
und dein OpenBSD-Rechner dein Router wird, dann solltest du dein Wissen
über IP-Netzwerke mit
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf"
>Understanding
IP addressing</a> vertiefen.
Dies ist wirklich ein exzellentes Dokument. »Understanding IP
addressing« beinhaltet grundlegendes Wissen, auf dem man bei der Arbeit
mit IP-Netzwerken aufbauen kann; insbesondere wenn man es mit mehreren
Netzwerken zu tun hat oder für sie verantwortlich ist.

<p>
Wenn du mit Anwendungen wie Web-, FTP- oder Mailservern arbeitest, dann
könntest du viel <a href="http://www.rfc-editor.org/rfc.html">vom
Lesen der entsprechenden RFCs</a> profitieren.
Selbstverständlich kannst du nicht alle lesen. Aber dennoch: Lies jene,
die dich interessieren oder die du bei deiner Arbeit brauchen könntest.
Lies nach, wie alles funktionieren sollte. Die RFCs definieren mehrere
(tausend) Standards für Protokolle im Internet und wie sie arbeiten
sollten.

<p>
<a name="Setup"></a>
<h2>6.2 - Netzwerkkonfiguration</h2>

Normalerweise wird OpenBSD während der
<a href="faq4.html">Installation</a> das erste Mal konfiguriert. Es ist
jedoch von Vorteil, wenn man genau versteht, was während des Vorgangs
passiert und wie genau das alles funktioniert. Die gesamte
Netzwerkkonfiguration wird mit einfachen Textdateien im
<i>/etc</i>-Verzeichnis abgehandelt.

<p>
<a name="Setup.if"></a>
<h3>6.2.1 - Identifizieren und Einstellen deiner Netzwerkkarten</h3>

<p>
Unter OpenBSD werden Netzwerkkarten nach ihrem Typ, nicht nach
Verbindungsart benannt. Du kannst entweder schon beim Booten oder auch
später mit Hilfe des Befehls <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8"
>dmesg(8)</a> sehen, ob deine Netzwerkkarte initialisiert wurde.
Weiterhin kannst du mit dem Befehl
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> deine Karte überprüfen. Als Beispiel hier die Ausgabe
von dmesg für eine Intel-Fast-Ethernet-Netzwerkkarte, die als
Gerätenamen fxp hat.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
Wenn du deinen Gerätenamen nicht kennst, sieh bitte in der
<a href="../../de/plat.html">Liste der unterstützten Hardware</a>
für deine Plattform nach. Du wirst eine Liste vieler bekannter Karten
mit ihren OpenBSD-Gerätenamen finden (wie etwa fxp). Kombiniere den
alphabetischen Gerätenamen (zum Beispiel fxp) mit einer vom Kernel
zugewiesenen Nummer und du hast den sogenannten Interfacenamen (wie
z.&nbsp;B. fxp0).
Die Nummer wird nach bestimmten Kriterien zugewiesen: Diese
unterscheiden sich je nach Karte und weiteren Details deines Systems.
Einige Karten werden in der Reihenfolge nummeriert, in der sie während
des Bus-Probings gefunden werden. Bei anderen entscheidet die
Einstellung der Hardwareressourcen oder die MAC-Adresse.

<p>
Du kannst herausfinden, ob deine Netzwerkkarte(n) erkannt wurde(n), indem
du das Kommando <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> benutzt. Das folgende Kommando zeigt uns alle
Netzwerkinterfaces im System an. Diese Beispielausgabe zeigt ein
physikalisches Netzwerkinterface an (ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"
>fxp(4)</a>).

<blockquote><pre>
$ <b>ifconfig</b>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet 127.0.0.1 netmask 0xff000000
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
pfsync0: flags=0&lt;&gt; mtu 2020
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010&lt;POINTOPOINT,LINK0,MULTICAST&gt; mtu 1450
carp0: flags=0&lt;&gt; mtu 1500
carp1: flags=0&lt;&gt; mtu 1500
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></blockquote>

<p>
Wie du hier sehen kannst, gibt <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> mehr Informationen aus, als wir zu diesem Zeitpunkt
benötigen. Selbstverständlich sehen wir trotzdem unser Interface. Im
obigen Beispiel ist die Netzwerkkarte bereits konfiguriert. Das ist
offensichtlich, da auf fxp0 bereits ein IP-Netzwerk konfiguriert wurde,
sprich die Werte »inet 10.0.0.38 netmask 0xffffff00 broadcast
10.0.0.255«. Außerdem sind die Flags <b>UP</b> und
<b>RUNNING</b> gesetzt.

<p>
Schlussendlich fällt auf, dass standardmäßig noch viele weitere
Interfaces aktiviert sind. Dies sind virtuelle Interfaces, die
verschiedene Funktionen haben. Informationen dazu findest du in den
folgenden Manualseiten:

<ul>
<!-- XXXrelease -->
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4"
>lo</a> - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4"
>pflog</a> - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4"
>sl</a> - SLIP-Netzwerkinterface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4"
>ppp</a> - Point-to-Point-Protokoll
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4"
>tun</a> - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4"
>enc</a> - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>bridge</a> - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4"
>vlan</a> - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4"
>gre</a> - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4"
>gif</a> - Generic IPv4/IPv6 Tunnel Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4"
>carp</a> - Common Address Redundancy Protocol Interface
</ul>

<p>
Das Interface wird während des Bootvorgangs über die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">/etc/hostname.<i>if</i>(5)</a>-Dateien
konfiguriert, wobei <i>if</i> für den vollständigen Namen deines
Interfaces steht (für das vorherige Beispiel wäre es also
<i>/etc/hostname.fxp0</i>).

<p>
Der Aufbau dieser Datei ist simpel:

<blockquote><pre>
address_family address netmask broadcast [weitere Optionen]
</pre></blockquote>

Weitere Details über dieser Datei findest du in der Manualseite für <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
>hostname.if(5)</a>. In ihr finden sich vor allem Informationen für
nicht ganz so einfache Konfigurationen.

<p>
Eine typische Interface-Konfigurationsdatei für eine IPv4-Adresse
würde so aussehen:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
In diesem Fall haben wir eine IPv4-Adresse (inet) mit der IP-Adresse
10.0.0.38, einer Subnetmask von 255.255.255.0 und ohne bestimmter
Broadcastadresse definiert (die in diesem Fall standardmäßig 10.0.0.255
ist).

<p>
Du solltest auch den Medientypen für Ethernet angeben, wenn du
z.&nbsp;B. den 100baseTX-Fullduplex-Modus erzwingen willst.

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
(Auf keinen Fall solltest du das tun, wenn nicht beide Seiten der
Verbindungen auf Vollduplex gestellt sind! Wenn du keine besonderen
Anforderungen hast, kannst du diese Medieneinstellungen einfach
ignorieren. Ein viel wahrscheinlicheres Beispiel wäre eine Einstellung
auf 10base-T oder Halbduplex, wenn das Netzwerk dies erfordert.)

<p>
Oder vielleicht willst du auch spezielle Flags für ein einzelnes
Interface benutzen. Das Format der Datei ändert sich dabei nicht
besonders!

<blockquote><pre>
$ <b>cat /etc/hostname.vlan0</b>
inet 172.21.0.31 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>


<a name="Setup.gateway"></a>
<h3>6.2.2 - Standardgateway</h3>
Schreib die IP-Adresse deines Standardgateways in die Datei <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate&amp;sektion=5"
>/etc/mygate</a></i>. Damit wird dein Gateway während des Bootvorgangs
eingestellt. Die Datei besteht nur aus einer einzigen Zeile, in der die
Adresse deines Gateways steht:

<blockquote><pre>
10.0.0.1
</pre></blockquote>

Du kannst auch einen Hostnamen verwenden, doch sei vorsichtig: Du
kannst während des Bootvorgangs nicht davon ausgehen, dass die
Namensauflösung bereits funktioniert oder der Nameserver überhaupt
erreichbar ist BIS das Standardgateway definiert wurde. Mit anderen
Worten: Es ist besser eine IP-Adresse oder etwas in
<i>/etc/hosts</i> fest definiertes in diese Datei zu schreiben.

<a name="Setup.resolver"></a>
<h3>6.2.3 - DNS-Auflösung</h3>
Die DNS-Auflösung wird über die Datei <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5"
><i>/etc/resolv.conf</i></a> verwaltet. Hier ist ein Beispiel einer
<i>/etc/resolv.conf</i>-Datei:

<blockquote><pre>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

In diesem Fall wird der Standarddomainname auf <tt>example.com</tt>
gesetzt, zwei DNS-Resolver (<tt>125.2.3.4</tt> und <tt>125.2.3.5</tt>)
definiert und vorgegeben, dass die Datei <i>/etc/hosts</i> durchsucht
werden soll bevor eine Anfrage an die DNS-Resolver gesendet wird.

<p>
Wie in fast jedem anderen Unix-System (und vielen Nicht-Unix-Systemen)
gibt es eine <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5"
><i>/etc/hosts</i></a>-Datei, in die alle Systeme eingetragen werden
können, die sich nicht in einem formalen DNS-System befinden (falls sie
dort anders angegeben sind als gewünscht, kann man die
»lookup«-Reihenfolge wie im vorherigen Beispiel anpassen).

<p>
Wenn du DHCP einsetzt, lies <a href="#DHCP">6.4 - DHCP</a> und
achte auf den Einsatz von <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5"
>resolv.conf.tail(5)</a>.

<a name="Setup.myname"></a>
<h3>6.2.4 - Hostname</h3>
Jede Unix-Maschine hat einen Namen. Unter OpenBSD wird der Name als
»Fully Qualified Domain Name« (FQDN) in einer einzelnen Zeile in der
Datei <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=myname&amp;sektion=5"
><i>/etc/myname</i></a> angegeben. Falls die Maschine »puffy« heißt und
sich in der Domain »example.com« befindet, würde folgende Zeile in der
Datei stehen:

<blockquote><pre>
puffy.example.com
</pre></blockquote>

<a name="Setup.activate"></a>
<h3>6.2.5 - Änderungen übernehmen</h3>
Jetzt kannst du entweder neustarten oder das Skript
<b>/etc/netstart</b> ausführen, indem du (als root) Folgendes
eingibst:

<blockquote><pre>
# <b>sh /etc/netstart</b>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Dabei werden ein paar Fehlermeldungen ausgegeben. Indem du dieses Skript
ausführst, versuchst du ein paar Sachen zu konfigurieren, die bereits
konfiguriert sind. Daher existieren bereits einige der Routen in der
Routingtabelle des Kernels. Von hier an sollte dein System laufen und
online sein. Du kannst hier erneut mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> prüfen, ob deine Interfaces richtig konfiguriert
wurden.

<p>
Obwohl du dein Netzwerk unter OpenBSD ohne Neustart vollständig
neukonfigurieren kannst, wird dir DRINGEND dazu geraten, wenn
grundlegende Einstellungen geändert wurden. Der Grund hierfür ist, dass
die Umgebung während des Bootvorgangs etwas anders ist als wenn das
System bereits vollständig hochgefahren wurde. Wenn du zum Beispiel
einen über DNS auflösbaren Namen in eine der Dateien geschrieben hast,
wirst du diesen im laufenden Betrieb sicherlich auflösen können. Während
des Bootvorgangs aber kann es sein, dass der externe Resolver noch nicht
verfügbar ist und die Konfiguration somit fehlschlägt.

<a name="Setup.chkroute"></a>
<h3>6.2.6 - Routen überprüfen</h3>
Deine Routen kannst du mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1"
>netstat(1)</a> oder <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8"
>route(8)</a> überprüfen. Wenn du Probleme mit dem Routing hast,
möchtest du vielleicht die Option -n mit route(8) benutzen, das die
IP-Adressen ausgibt, statt eine DNS-Auflösung durchzuführen, und um den
Hostnamen anzuzeigen. Hier ist ein Beispiel mit beiden Kommandos, um die
Routingtabelle anzeigen zu lassen:

<blockquote><pre>
$ <b>netstat -rn</b>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <b>route show</b>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.forward"></a>
<h3>6.2.2 - Deinen OpenBSD-Rechner als Gateway einrichten</h3>

<p>
Dies sind nur die grundlegenden Informationen, um deinen OpenBSD-Rechner
als Gateway (auch Router genannt) einzurichten. Wenn du OpenBSD als
Router im Internet verwenden willst, solltest du auch die unten
folgenden Packet-Filter-Instruktionen beachten, um potenziell schädliche
IP-Daten zu blockieren. Auch solltest du wegen der Knappheit an <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4"
>IPv4</a>-Adressen die Informationen bezüglich Network Address
Translation beachten, um deinen IP-Adressbereich zu schonen.

<p>
Der GENERIC-Kernel kann bereits IP-Forwarding, muss aber erst
eingeschaltet werden. Du solltest dies mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8"
>sysctl(8)</a> tun. Um diese Änderung permanent einzutragen, musst du
die Datei <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5"
>/etc/sysctl.conf</a> editieren. Füge einfach folgende Zeile in diese
Konfigurationsdatei ein.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Ohne Neustart kannst du dies auch direkt mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8"
>sysctl(8)</a> durchführen. Beachte aber, dass diese Änderung nach einem
Neustart weg ist und dass der folgende Befehl als root ausgeführt werden
muss.

<blockquote><pre>
# <b>sysctl net.inet.ip.forwarding=1</b>
net.inet.ip.forwarding: 0  -&gt; 1
</pre></blockquote>

<p>
Nun modifiziere die Routen der anderen Hosts. Es gibt viele verschiedene
Möglichkeiten, OpenBSD als Router einzusetzen, z.&nbsp;B. mittels
Software wie das OpenBSD-eigene <a
href="http://www.openbgpd.org/de/">OpenBGPD</a>, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8"
>routed(8)</a>, <a href="http://www.mrtd.net">mrtd</a>, <a
href="http://www.zebra.org">zebra</a> und <a
href="http://www.quagga.net">quagga</a>. OpenBSD hat Unterstützung im
Portstree sowohl für zebra als auch für quagga und mrtd. OpenBGPD und
routed werden als Teil des Basissystems installiert. OpenBSD unterstützt
mehrere T1-, HSSI-, ATM-, FDDI-, Ethernet- und serielle Schnittstellen
(PPP/SLIP).

<p>
<a name="Setup.aliases"></a>
<h3>6.2.8 - Einrichten von Aliases auf deiner Netzwerkkarte</h3>

<p>
OpenBSD hat einen einfachen Mechanismus, um IP-Aliase für deine
Netzwerkkarten zu setzen. Dazu musst du einfach die Datei <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
><i>/etc/hostname.&lt;if&gt;</i></a> editieren. Sie wird beim Booten vom
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstart&amp;sektion=8"
>/etc/netstart(8)</a>-Skript gelesen, das ein Teil der
<a href="faq10.html#rc">rc-Starthierarchie</a> ist. Für dieses Beispiel
nehmen wir an, dass der Benutzer ein Interface <b>dc0</b> hat und sich
im Netzwerk 192.168.0.0 befindet. Weitere wichtige Informationen:

<ul>
<li>IP für dc0 ist 192.168.0.2
<li>NETMASK ist 255.255.255.0
</ul>

<p>
Ein paar Bemerkungen zu Aliasen: In OpenBSD verwendet man nur den
Adapternamen. Es gibt keine Unterschiede zwischen dem ersten und dem
zweiten Alias. Daher muss man sie nicht - wie in einigen anderen
Betriebssystemen - als dc0:0, dc0:1 bezeichnen. Wenn du dich auf einen
speziellen IP-Alias beziehst oder einen hinzufügst, dann nimm
»<tt>ifconfig int alias</tt>« statt nur »<tt>ifconfig int</tt>«
auf der Befehlszeile. Du kannst Aliase mit »<tt>ifconfig int
delete</tt>« löschen.

<p>
Angenommen du verwendest mehrere IP-Adressen im selben IP-Subnetz mit
Aliases, dann ist die Netzmaskeneinstellung für jeden Alias
255.255.255.255. Sie müssen nicht der Netzmaske der ersten IP der
Netzwerkkarte folgen. In dieser <i>/etc/hostname.dc0</i>-Beispieldatei
werden zwei Aliase zur Netzwerkkarte dc0 hinzugefügt, die als
192.168.0.2 mit Netzmaske 255.255.255.0 konfiguriert wurde.

<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 NONE media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

<p>
Wenn du einmal diese Datei erstellt hast, benötigst du einen Neustart,
um die Änderung automatisch durchzuführen. Du kannst aber auch
die Aliase manuell mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> hochbringen. Für den ersten Alias geht das so:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

(Und wieder ist ein Neustart empfehlenswert um sicherzustellen, dass
alles wie erwartet konfiguriert wird!)

<p>
Um die Aliases zu sehen:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="PF"></a>
<h2>6.3 - Wie kann ich mit OpenBSD filtern und eine Firewall aufsetzen?</h2>
Packet Filter (ab hier nur noch als PF bezeichnet) ist OpenBSDs System
zum Filtern von IP-Verkehr und zum Ausführen von Network Address
Translation. PF ist außerdem in der Lage, IP-Verkehr zu normalisieren
und zu konditionieren, eine Priorisierung von Paketen durchzuführen und
eine mächtige und flexible Firewall zu erzeugen. Er wird im <a
href="../pf/de/index.html"><b>PF-Benutzerhandbuch</b></a> beschrieben.

<p>
<a name= "DHCP"></a>
<h2>6.4 - Dynamic-Host-Configuration-Protokoll (DHCP)</h2>

Das Dynamic-Host-Configuration-Protokoll ist ein Weg, um die
Netzwerkkarten »automatisch« zu konfigurieren. OpenBSD kann als
DHCP-Server (der andere Maschine konfiguriert), als ein DHCP-Client (der
von einer anderen Maschine konfiguriert wird) und in einigen Fällen auch
als beides eingesetzt werden.

<p>
<a name="DHCPclient"></a>
<h3>6.4.1 - DHCP-Client</h3>

<p>
Um den im OpenBSD integrierten DHCP-Client <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8"
>dhclient(8)</a> zu benutzen, editiere <tt>/etc/hostname.xl0</tt> (wenn
deine Hauptnetzwerkkarte xl0 ist. Deine könnte auch ep0 oder fxp0 oder
irgendeine andere sein). Alles was du in diese Datei zu schreiben hast ist
»<tt>dhcp</tt>«.

<blockquote><pre>
# <b>echo dhcp &gt; /etc/hostname.xl0</b>
</pre></blockquote>

<p>
Dies wird OpenBSD veranlassen, den DHCP-Client automatisch beim Booten
zu starten. OpenBSD wird sich seine IP-Adresse, sein Standardgateway und
seine DNS-Server vom DHCP-Server besorgen.

<p>
Wenn du den DHCP-Client von der Befehlszeile aus starten willst, stelle
sicher, dass <tt>/etc/dhclient.conf</tt> existiert, dann versuche:

<blockquote><pre>
# <b>dhclient fxp0</b>
</pre></blockquote>

<p>
Wobei <tt>fxp0</tt> die Netzwerkkarte ist, auf der du dhcp empfangen
willst.

<p>
Wie auch immer du den DHCP-Client startest, kannst du die
<tt>/etc/dhclient.conf</tt>-Datei so editieren, dass dein DNS
<b>nicht</b> mit den neuen DNS-Informationen aktualisiert wird:
kommentiere zuerst die »request«-Zeilen aus (Es gibt Beispiele in den
Standardeinstellungen, aber du musst die Standardeinstellungen vom
dhclient überschreiben).

<blockquote><pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre></blockquote>

<p>
und dann <tt>domain-name-servers</tt>. Natürlich möchtest du vermutlich
auch Einstellungen wie <tt>hostname</tt> entfernen.

<p>
Durch das Ändern der Optionen in deiner <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5"
>dhclient.conf(5)</a>-Datei teilst du dem DHCP-Client mit, wie deine <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5"
>resolv.conf(5)</a>-Datei erzeugt werden soll. Der DHCP-Client
überschreibt jegliche Informationen, die du bereits in der
resolv.conf(5) hast, mit jenen, die er vom DHCP-Server erhält. Daher
wirst du alle Änderungen verlieren, die du manuell an der resolv.conf
vorgenommen hast.

<p>
Zwei Mechanismen stehen zur Verfügung, um das zu verhindern:

<ul>
<li>
<tt><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5#OPTION+MODIFIERS"
>OPTION MODIFIERS</a></tt> (<b>default</b>, <b>supersede</b>,
<b>prepend</b> und <b>append</b>) erlauben dir, jegliche Optionen in
dhclient.conf(5) zu überschreiben.

<li>
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5"
><tt>resolv.conf.tail(5)</tt></a> ermöglicht dir alle Informationen, die
du haben möchtest, an die resolv.conf(5)-Datei anzuhängen, die durch
dhclient(8) erstellt wurde.
</ul>

<p>
Ein Beispielfall wäre, wenn du DHCP verwendest, aber <tt>lookup file
bind</tt> an die von dhclient(8) erstellte resolv.conf(5) hängen möchtest.
Hierfür gibt es keine Option in <tt>dhclient.conf</tt>, daher musst du
<tt>resolv.conf.tail</tt> benutzen, um dieses Ziel zu erreichen.

<blockquote><pre>
# <b>echo "lookup file bind" &gt /etc/resolv.conf.tail</b>
</pre></blockquote>

Nun sollte deine resolv.conf(5) »lookup file bind« am Ende stehen haben.
<blockquote><pre>
nameserver 192.168.1.1
nameserver 192.168.1.2
lookup file bind
</pre></blockquote>

<p>
<a name="DHCPserver"></a>
<h3>6.4.2 - DHCP-Server</h3>

<p>
Wenn du OpenBSD als DHCP-Server
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)</a>
einsetzen willst, editiere <tt>/etc/rc.conf.local</tt> so,
dass sie die Zeile <tt>dhcpd_flags="<i>Interface</i>"</tt> beinhaltet
und ersetze <tt><i>Interface</i></tt> durch eine Liste von Interfaces
auf die dhcpd(8) hören soll. Zum Beispiel so:

<pre>
     # <b>echo 'dhcpd_flags="xl1 xl2 xl3"' &gt;&gt;/etc/rc.conf.local</b>
</pre>

<p>
Dann editiere <tt>/etc/dhcpd.conf</tt>. Die Optionen sind
selbsterklärend.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Dies teilt deinen DHCP-Clients mit, dass die an DNS-Anfragen
anzuhängende Domäne example.com ist (d.&nbsp;h. wenn der Benutzer
»telnet joe« schreibt, dann wird an joe.example.com gesendet). Es wird
auf die DNS-Server 192.168.1.3 und 192.168.1.5 verwiesen. Für Hosts, die
sich im selben Netzwerk wie die Netzwerkkarte des OpenBSD-Rechners
befinden, welche im 192.168.1.0/24 Adressbereich liegt, wird der
DHCP-Server ihnen eine IP-Adresse zwischen 192.168.1.32 und
192.168.1.127 und als Standardgateway 192.168.1.1 zuweisen.

<p>
Wenn du den dhcpd(8) von der Befehlszeile aus starten willst, nachdem du
<tt>/etc/dhcpd.conf</tt> editiert hast, versuche:

<pre>
     # <b>touch /var/db/dhcpd.leases</b>
     # <b>dhcpd fxp0</b>
</pre>

<p>
Die <tt>touch</tt>-Zeile ist notwendig, um eine leere
<tt>dhcpd.leases</tt>-Datei zu erzeugen, bevor dhcpd(8) starten kann.
Die OpenBSD-<a href="faq10.html#rc">Startskripte</a> erstellen diese
Datei beim Hochfahren, wenn es notwendig ist. Wenn du aber dhcpd(8)
manuell startest, musst du sie zuerst erstellen.
<tt>fxp0</tt> ist ein Interface, auf dem du beginnen möchtest, DHCP
anzubieten.

<p>
Wenn du DHCP-Dienste für einen Windows-Rechner bereitstellst, dann
willst du vielleicht auch eine WINS-Serveradresse liefern. Dafür füge
einfach die folgenden Zeilen zu deiner <tt>/etc/dhcpd.conf</tt>:

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(wobei <tt>192.168.92.55</tt> die IP deines Windows- oder Samba-Servers
ist.) Siehe auch <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5"
>dhcp-options(5)</a> für weitere Optionen, die deine DHCP-Clients
wünschen.


<p>
<a name="PPP"></a>
<h2>6.5 - PPP</h2>

<p>
Das Point-to-Point-Protokoll wird verwendet, um eine Verbindung zu
deinem ISP mit deinem Einwahlmodem herzustellen. OpenBSD bietet dafür
zwei Möglichkeiten:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
- der Kernel-PPP-Daemon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
- der Userland-PPP-Daemon.
</ul>

<p>
Sowohl ppp als auch pppd führen zwar die gleichen Funktionen aus, dieses
jedoch auf unterschiedliche Wege. pppd arbeitet mit dem <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4"
>ppp(4)</a>-Treiber des Kernels, während ppp mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4"
>tun(4)</a> im Userland arbeitet. Dieses Dokument wird sich nur mit dem
PPP-Daemon des Userlands beschäftigen, da es mit ihm einfacher ist,
Fehlfunktionen zu korrigieren sowie mit ihm zu interagieren. Um zu
beginnen, benötigen wir einige einfache Informationen über deinen ISP.
Hier eine Liste hilfreicher Informationen, die du brauchen wirst.

<ul>
<li>Die Einwahlnummer deines ISPs
<li>Deinen Nameserver
<li>Deinen Benutzernamen und dein Passwort
<li>Dein Gateway
</ul>

<p>
Einige von diesen benötigst du nicht unbedingt, aber sie wären
beim Aufsetzen des ppp hilfreich. Der Userland-PPP-Daemon benutzt die
Datei <a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample"
>/etc/ppp/ppp.conf</a> als seine Konfigurationsdatei. Es gibt viele
hilfreiche Dateien in <i>/etc/ppp</i>, die verschiedene Einstellungen
für verschiedene Situationen zeigen. Du solltest dir dieses Verzeichnis
ansehen und es durchforsten.

<p>
<h3>Erste Einstellungen - für PPP(8)</h3>

<p>
Die ersten Einstellungen für den Userland-PPP-Daemon bestehen im
Erstellen deiner <i>/etc/ppp/ppp.conf</i>-Datei. Diese Datei existiert
nicht standardmäßig, aber du kannst einfach
<i>/etc/ppp/ppp.conf.sample</i> editieren, um deine eigene
 <i>ppp.conf</i>-Datei zu erstellen. Hier werde ich mit den einfachsten
und gebräuchlichsten Einstellungen beginnen. Hier eine kurze
<i>ppp.conf</i>-Datei, die einfach einige Standardwerte setzt:

<blockquote><pre>
default:
set log Phase Chat LCP IPCP CCP tun command
set device /dev/cua01
set speed 115200
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
</pre></blockquote>

<p>
Der Absatz unter der <tt>default:</tt>-Bezeichnung wird jedes Mal
ausgeführt. Hier stehen alle wichtigen Informationen. Mit »set
log« stellen wir unsere Loglevel ein. Um dies zu ändern, lies <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8"
>ppp(8)</a> für weitere Informationen. Unsere Schnittstelle wird mit
»set device« eingestellt. Dies ist die Schnittstelle, mit der das
Modem verbunden ist. In diesem Beispiel hängt das Modem auf COM-Port 2.
Daher wird COM-Port 1 auf <i>/dev/cua00</i> gesetzt. Mit »set speed«
setzen wir die Geschwindigkeit unserer Einwahlverbindung und mit »set
dail« setzen wir unsere Dialup-Parameter, mit denen wir den Timeout
usw. setzen können. Diese Zeile sollte eigentlich ziemlich genau so
bleiben, wie sie jetzt ist.

<p>
Nun können wir die spezifischen Informationen von unserem ISP eintragen.
Wir tun dies, indem wir unter <tt>default:</tt> einen weiteren Absatz
hinzufügen. Dieser kann benannt werden, wie du willst - am einfachsten
nimmst du den Namen deines ISPs. Hier werde ich <tt>myisp:</tt> als
Verweis auf unseren ISP nehmen. Hier ist ein einfaches Beispiel, das
alles beinhaltet, um uns zu verbinden:

<blockquote><pre>
myisp:
set phone 1234567
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR
enable dns
</pre></blockquote>

<p>
Hier stehen alle wichtigen Informationen für unseren spezifischen ISP.
Die erste Option »set phone« setzt die Einwahlnummer deines ISPs.
»set login« setzt unsere login-Optionen. Hier haben wir den Timeout
auf 5 gesetzt, was bedeutet, dass wir unseren Loginversuch nach 5
Sekunden abbrechen, wenn wir kein Trägersignal bekommen. Ansonsten wird
er auf »login:« warten und dann deinen Benutzernamen und dein Passwort
senden.

<p>
In diesem Beispiel ist unser Benutzername ppp und das Passwort ppp.
Diese Werte müssen geändert werden. Die Zeile »set timeout« setzt den
Idle Timeout für die gesamte Verbindungsdauer auf 120 Sekunden. Die
»set ifaddr«-Zeile ist ein bisschen schwieriger. Hier ist eine genauere
Erklärung.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
Die obige Zeile folgt dem Format »<b>set ifaddr [meineAdr[/nn]
[seineAdr[/nn] [netzmaske [startAdr]]]]</b>«. Daher ist die erste
spezifizierte IP diejenige, die wir als unsere IP wollen. Wenn du eine
statische IP-Adresse hast, dann kannst du sie hier einsetzen. In unserem
Beispiel benutzen wir /0, was besagt, dass keine Bits von dieser
IP-Adresse übereinstimmen müssen und der gesamte Ausdruck ersetzt werden
kann. Die zweite IP behandelt die von uns erwartete IP unserer
Gegenstelle. Wenn du sie weißt, dann kannst du sie hier angeben.
Wiederum wissen wir nicht in unserer Zeile, welche IP dies wird, also
lassen wir sie uns wieder mitteilen. Die dritte Option ist unsere
Netzmaske, hier auf 255.255.255.0 gesetzt. Wenn startAdr angegeben ist,
dann wird diese anstelle von meineAdr während der initialen
IPCP-Verhandlung; aber es wird nur eine Adresse aus dem
meineAdr-Adressbereich akzeptiert. Dies ist nützlich, wenn Verhandlungen
mit einigen PPP-Implementationen durchgeführt werden, die keine
IP-Nummer vergeben, es sei denn, ihr Peer fordert »0.0.0.0« an.

<p>
Die nächste Option »add default HISADDR« setzt unsere Standardroute zu
deren IP. Dies ist »klebrig«, d.&nbsp;h. falls deren IP sich ändern
sollte, dann wird unsere Route auch automatisch aktualisiert. Mit
»enable dns« teilen wir unserem ISP mit, unsere Nameserveradresse zu
authentifizieren. Tu dies NICHT, wenn du deinen eigenen lokalen DNS
laufen hast, da PPP dies umgehen wird, indem es einige Zeilen in
<i>/etc/resolv.conf</i> schreibt.

<p>
Gegenüber den herkömmlichen Loginmethoden verwenden viele IPS nun
entweder CHAP- oder PAP-Authentifizierung. Wenn das der Fall ist, wird
unsere Konfiguration etwas anders aussehen:

<blockquote><pre>
myisp:
set phone 1234567
set authname ppp
set authkey ppp
set login
set timeout 120
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR
enable dns
</pre></blockquote>

<p>
In dem oben genannten Beispiel geben wir unseren Benutzernamen (ppp) und
das Passwort (ppp) unter jeweiliger Verwendung von authname und authkey
an.  Es ist nicht notwendig anzugeben, ob CHAP- oder
PAP-Authentifizierung genutzt wird: Es wird automatisch ermittelt. »set
login« gibt lediglich an, dass versucht wird, sich mit dem zuvor
genannten Benutzernamen und dem Passwort anzumelden.

<p>
<h3>PPP(8) verwenden</h3>

<p>
Nun, da wir unsere <i>ppp.conf</i>-Datei fertig eingerichtet haben,
können wir beginnen, eine Verbindung zu unserem ISP aufzubauen. Hier
einige Details über häufig verwendete Parameter mit ppp:

<ul>
<li><tt>ppp -auto myisp</tt> - Startet PPP, konfiguriert deine
Schnittstellen und wird dich mit deinem ISP verbinden und dann in den
Hintergrund verschwinden.
<li><tt>ppp -ddial myisp</tt> - Ähnlich wie -auto, aber wenn deine
Verbindung abbricht, wird PPP versuchen, sich erneut zu verbinden.
</ul>

<p>
Wenn die gerade genannten Aufrufe fehlschlagen, kannst du versuchen,
<i>/usr/sbin/ppp</i> ohne Optionen zu starten - somit wird ppp im
interaktiven Modus ausgeführt. Die Optionen können nach und nach
angegeben werden, um so nach Fehlern oder anderen Problemen zu suchen.
Unter Verwendung der zuvor beschriebenen Einrichtung wird ppp in
/var/log/ppp.log aufzeichnen. Diese Aufzeichnung, sowie die Manualseite,
enthalten hilfreiche Informationen.

<p>
<h3>ppp(8)-Extras</h3>

<p>
In einigen Situationen möchtest du Befehle ausführen, wenn die
Verbindung gerade errichtet oder beendet wurde. Für diese Fälle
gibt es zwei Dateien, die du erstellen kannst:
<i>/etc/ppp/ppp.linkup</i> und <i>/etc/ppp/ppp.linkdown</i>.
Beispielkonfigurationen kannst du hier finden:

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample"
>ppp.linkup</a>
<li><a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample"
>ppp.linkdown</a>
</ul>

<p>
<h3>ppp(8)-Varianten</h3>

<p>
Viele ISPs bieten nun xDSL-Dienste an, welche schneller als die
herkömmlichen Einwählmethoden sind. Dies beinhaltet Varianten wie
zum Beispiel ADSL und SDSL. Obwohl kein physikalisches Einwählen
stattfindet, basiert die Verbindung weiterhin auf dem
Point-to-Point-Protokoll. Beispiele beinhalten:

<ul>
<li>PPPoE
<li>PPPoA
<li>PPTP
</ul>

<p>
<h3>PPPoE/PPPoA</h3>

<p>
Das »Point to Point Protocol over Ethernet« (PPPoE) ist eine Methode,
um PPP-Pakete in Ethernetframes zu versenden.
Das »Point to Point Protocol over ATM« (PPPoA) läuft typischerweise
in ATM-Netzwerken, wie sie in Großbritannien oder Belgien gefunden
werden können.

<p>
Typischerweise bedeutet das, dass du eine Verbindung mit deinem ISP
über eine normale Ethernetkarte und ethernetbasiertes DSL-Modem
herstellen kannst (im Gegensatz zu einem Nur-USB-Modem).

<p>
Wenn du ein Modem hast, das PPPoE/PPPoA versteht, ist es möglich,
das Modem so zu konfigurieren, dass es selbst die Verbindung aufbaut.
Wenn das Modem einen Bridgemodus hat, ist es alternativ möglich,
diesen zu aktivieren und so das Modem die Pakete einfach zu einer
Maschine durchleiten zu lassen, welche PPPoE-Software einsetzt (siehe
unten).

<p>
Das Haupt-Softwareinterface für PPPoE/PPPoA unter OpenBSD ist <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8"
>pppoe(8)</a>, welches die Userland-Implementation ist (auf fast die
gleiche Art und Weise, wie wir <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8"
>ppp(8)</a> weiter oben beschrieben haben).
Eine Kernel-PPPoE-Implementation namens <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=4"
>pppoe(4)</a> wurde in OpenBSD eingebunden.

<p>
<h3>PPTP</h3>

<p>
Das Point-to-Point-Tunneling-Protokoll (PPTP) ist ein proprietäres
Microsoft-Protokoll.  Ein pptp-Client ist verfügbar, der mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8"
>pppd(8)</a> kommuniziert. Er ist in der Lage, sich zu PPTP-basierten
virtuellen privaten Netzwerken (VPN) zu verbinden, die von einigen
Kabel- und xDSL-Anbietern verwendet werden. pptp selbst muss als
<a href="faq15.html#PkgMgmt">Package</a> oder
<a href="faq15.html#Ports">Port</a> installiert werden. Weitere
Anleitungen, wie man pptp einrichtet und verwendet, befinden
sich in der Manualseite, die mit dem pptp-Package installiert wird.

<p>
<a name="Tuning"></a>
<h2>6.6 - Netzwerkparameter tunen</h2>
<!-- XXXrelease -->

Eines der Ziele von OpenBSD ist, dass das System für einen Großteil
unserer Nutzer <i>einfach läuft</i>. An Einstellungen rumspielen, deren
Funktion du nicht verstehst, wird das System eher beeinträchtigen und
nicht dessen Geschwindigkeit erhöhen. Fang immer mit den Standardwerten
an und ändere <i>nur</i> Einstellungen, die tatsächlich ein Problem
darstellen.

<p>
<i>SEHR WENIGE Personen werden sich hierum kümmern müssen!</i>

<p>
<h3>6.6.1 - Wie kann ich meinen Kernel optimieren, sodass er eine
größere Anzahl Neuversuche und längere Timeouts für
TCP-Sitzungen hat?</h3>

<p>
Normalerweise möchtest du das entweder für Routing oder wegen
Verbindungsproblemen. Selbstverständlich müssen beide Seiten der
Verbindung ähnliche Werte verwenden, damit es am effektivsten ist.

<p>
Um dies zu tunen, verwende <tt>sysctl</tt> und erhöhe die Werte von:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Mittels sysctl -a kannst du die derzeitigen Werte dieser (und vieler
anderer) Parameter sehen. Um einen Wert zu verändern, verwende etwas
wie <tt>sysctl net.inet.tcp.keepidle=28800</tt>.

<p>
<h3>6.6.2 - Wie kann ich »directed broadcasts« aktivieren?</h3>

<p>
Normalerweise willst du dies nicht tun. Dies erlaubt jemandem,
Datenverkehr zu der Broadcastadresse deines verbundenen Netzwerkes zu
schicken, wenn du deinen OpenBSD-Rechner als Router verwendest.

<p>
Aber manchmal kann dies in geschlossenen Netzwerken nützlich sein;
vor allem wenn man ältere Implementationen des NetBIOS-Protokolles
verwendet. Mit
<tt>sysctl net.inet.ip.directed-broadcast=1</tt> wird dies aktiviert
Beachte aber <a href="http://www.netscan.org">Smurfangriffe</a>,
wenn du wissen willst, warum dies standardmäßig nicht aktiviert ist.

<p>
<h3>6.6.3 - Der Kernel soll bestimmte Ports nicht dynamisch allozieren</h3>

<p>
Auch dafür gibt es einen eigenen sysctl-Befehl. Siehe <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8"
>sysctl(8)</a>:

<pre>
Setze die Liste der reservierten TCP-Ports, die nicht dynamisch vom
Kernel vergeben werden sollen. Das kann man benutzen, um Daemons davon
abzuhalten, einen speziellen Port zu benutzen, den ein anderes Programm
braucht, damit es funktionieren kann. Listen-Elemente können
mit Kommas und/oder Leerzeichen getrennt werden.

#  <b>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</b>

Es ist ebenso möglich, Ports aus der aktuellen Liste hinzuzufügen
oder zu entfernen.

 #  <b>sysctl net.inet.tcp.baddynamic=+748</b>
 #  <b>sysctl net.inet.tcp.baddynamic=-871</b>
</pre>

<p>
<h3>6.6.4 - Wie kann ich die Leistung einer sehr schnellen und
ausgelasteten Verbindung erhöhen?</h3>

Wenn du bei der Verwendung einer Hochgeschwindigkeits-WAN-Verbindung
Leistungsbegrenzungen feststellst, kannst du eventuell einen
Leistungsgewinn feststellen, wenn du die folgenden Sysctls änderst:
<blockquote><pre>
net.inet.tcp.recvspace
net.inet.tcp.sendspace
</pre></blockquote>

Probier einen Wert wie zum Beispiel 65536 statt den standardmäßigen
16384. Beachte, dass nur wenige einen echten Nutzen hieraus ziehen
können. Verändere diese Werte nicht, wenn du nicht tatsächlich weniger
Leistung hast, als du erwartet hättest.

<p>
<a name="NFS"></a>
<h2>6.7 - Einfache NFS-Anleitung</h2>

<p>NFS, oder Network File System (Netzwerkdateisystem), wird verwendet,
um ein Dateisystem über das Netzwerk zu verwenden. Du solltest vorher
noch folgende Manualseiten lesen, bevor du versuchst, einen eigenen
NFS-Server aufzusetzen:

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8"
>nfsd(8)</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8"
>mountd(8)</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5"
>exports(5)</a>
</ul>

<p>
Dieses Kapitel zeigt die Schritte, um ein einfaches NFS-System
aufzusetzen: Einen Server im LAN und Clients im LAN, die NFS verwenden.
Es behandelt nicht, wie man NFS sicher macht. Wir nehmen an, dass du
bereits Paketfilterung oder irgendeinen anderen Firewallschutz
eingerichtet hast, damit von außerhalb nicht auf NFS zugegriffen werden
kann.  Wenn du Zugriff via NFS von außerhalb erlauben willst und
sensible Daten dort gespeichert hast, dann empfehlen wir dir wärmstens
den Gebrauch von IPsec. Ansonsten können andere Leute möglicherweise
deinen NFS-Datenverkehr sehen. Jemand könnte auch vortäuschen, die
IP-Adresse zu haben, der du Zugriff auf den NFS-Server zulässt. Es gibt
mehrere Angriffe, die möglich sind. Wenn IPsec richtig konfiguriert
wurde, dann schützt es gegen die Art von Angriffen.

<h3>Einen NFS-Server einrichten</h3>

<p>
Folgende Dienste müssen auf dem Server aktiviert sein und laufen:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8"
>portmap(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8"
>mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8"
>nfsd(8)</a>
</ul>

<p>
Unter OpenBSD sind diese standardmäßig deaktiviert.
Füge die folgenden Zeilen deiner <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"
>rc.conf.local(8)</a> hinzu, um sie zu aktivieren:

<blockquote><pre>
portmap=YES
nfs_server=YES
</pre></blockquote>

<p>
Im nächsten Schritt wird die Liste der Dateisysteme konfiguriert, die
den Clients für Mountoperationen bereitgestellt werden sollen.

<p>
In diesem Beispiel haben wir einen Server mit der IP-Adresse 10.0.0.1.
Der Server wird NFS nur den Clients anbieten, die sich im gleichen
Subnet befinden. Dies wird alles in der /etc/exports-Datei konfiguriert.
In dieser Datei werden für alle Dateisysteme, auf die über
NFS zugegriffen werden kann, auch die jeweiligen Zugriffsrechte aufgeführt.
Es gibt sehr viele Optionen, die du in /etc/exports verwenden kannst;
es wäre daher am besten, wenn du die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5"
>exports(5)</a>-Manualseite lesen würdest. Für dieses Beispiel haben wir
eine exports-Datei angelegt, die wie folgt aussieht:

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network=10.0.0 -mask=255.255.255.0
</pre></blockquote>

<p>
Das heißt, dass das lokale Dateisystem <tt>/work</tt> via NFS zugänglich
gemacht wird. Die <tt>-alldirs</tt>-Option bedeutet, dass Clients jedes
Verzeichnis unter dem <tt>/work</tt>-Mountpunkt (und auch <tt>/work</tt>
selbst) mounten können. Wenn beispielsweise ein Verzeichnis namens
<tt>/work/monday</tt> vorhanden ist, können Clients <tt>/work</tt>
mounten (und damit auf alle folgenden Dateien/Verzeichnisse zugreifen
können) oder <tt>/work/monday</tt> mounten und nur auf
Dateien/Verzeichnisse zugreifen können, die sich dort befinden.
Die <tt>-ro</tt>-Option gibt an, dass nur Leseberechtigung gestattet
wird. Die letzten zwei Argumente bedeuten, dass nur Clients innerhalb
des 10.0.0.0-Netzwerkes mit einer Netzmaske von 255.255.255.0 dieses
Dateisystem mounten dürfen. Dies ist wichtig für einige Server, die von
verschiedenen Netzwerken aus zugänglich sind.

<p>
Ein weiterer wichtiger Sicherheitshinweis: Füge nicht einfach ein
Dateisystem in /etc/exports ein, ohne eine Liste zulässiger Hosts (oder
einen einzelnen Host) anzugeben. Ohne Angabe einer Liste für
erlaubte Zugriffe kann jeder, der den Server ansprechen kann, deine
über NFS bereitgestellten Verzeichnisse mounten.

<p>
Nun kannst du die Serverdienste starten.
Entweder startest du neu (nachdem du sie mit den oben angegebenen
Schritten aktiviert hast) oder du startest sie manuell.

<blockquote><pre>
# <b>/usr/sbin/portmap</b>
# <b>echo -n &gt;/var/db/mountdtab</b>
# <b>/sbin/mountd</b>
# <b>/sbin/nfsd -tun 4</b>
</pre></blockquote>

<p>
Die an nfsd übergebenen Argumente ermöglichen Verbindungen über TCP (-t)
und UDP (-u) und starten vier nfsd-Instanzen (-n). Du solltest eine
entsprechende Anzahl NFS-Serverinstanzen setzen, um die von dir
gewünschte maximale Anzahl gleichzeitiger Clientzugriffe verarbeiten zu
können.

<p>
Nun kannst du die exportierten Dateisysteme von den Clients (oder dem
Client) aus mounten.

<p>
Bedenke: Wenn du Änderungen an /etc/exports gemacht hast während NFS
bereits lief, musst du mountd über diese Änderungen informieren!
Sende einfach ein HUP an mountd und die Änderungen werden übernommen.

<blockquote><pre>
# <b>kill -HUP `cat /var/run/mountd.pid`</b>
</pre></blockquote>
<h3>NFS-Dateisysteme mounten</h3>

<p>
NFS-Dateisysteme können vom Client gemountet werden, ohne dass
zusätzliche Dienste oder Daemons gestartet werden müssen; sie können
wie jedes andere Dateisystem gemountet werden.

<p>
NFS-Dateisysteme sollten mit mount(8) gemountet werden - genauer
gesagt mit <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8"
>mount_nfs(8)</a>.
Um ein Dateisystem namens <tt>/work</tt> des Hosts 10.0.0.1 auf das
lokale Dateisystem <tt>/mnt</tt> zu mounten, führe Folgendes aus
(beachte, dass du nicht auf eine IP-Adresse angewiesen bist; mount
löst auch Hostnamen auf):

<blockquote><pre>
# <b>mount -t nfs 10.0.0.1:/work /mnt</b>
</pre></blockquote>

<p>
Damit das Dateisystem während des Bootvorgangs gemountet wird, füge
eine Zeile wie diese in /etc/fstab ein:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<p>
Es ist wichtig, dass du <tt>0 0</tt> am Ende der Zeile angibst, damit
dein Computer während des Bootvorgangs nicht versucht, fsck für das
NFS-Dateisystem aufzurufen. Die anderen Standardsicherheitsoptionen
wie <tt>noexec</tt>, <tt>nodev</tt> und <tt>nosuid</tt> sollten je nach
Anwendungszweck ebenfalls gesetzt werden. Ein Beispiel:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<p>
Auf diese Weise können keine Devices oder setuid-Programme auf dem
NFS-Server die Sicherheitsmaßnahmen des NFS-Clients unterwandern. Wenn
du keine auf dem gemounteten Dateisystem befindlichen Programme auf
dem NFS-Client starten willst, füge dieser Liste noexec hinzu.

<p>
Wenn mit Rootrechten auf einen NFS-Mount zugegriffen wird, setzt der
Server automatisch die Berechtigung auf Benutzername »nobody« und Gruppe
»nobody«. Es ist sehr wichtig, diese Eigenschaft zu berücksichtigen,
wenn Dateiberechtigungen gesetzt werden. Die Berechtigungen dieser Datei
soll als Beispiel dienen:

<blockquote><pre>
-rw-------    1 root     wheel           0 Dec 31 03:00 _daily.B20143
</pre></blockquote>

<p>
Wenn diese Datei sich auf einem NFS-Share befindet und der Benutzer
root versucht, über einen NFS-Client auf sie zuzugreifen, wird ihm
der Zugriff verwehrt bleiben. Dies liegt daran, dass der Server die
Kennung des Benutzers »nobody« verwendet, wenn root auf die Datei
zugreifen möchte. Da der Benutzer nobody aber keine Zugriffsberechtigung
auf diese Datei hat, bleibt sie ihm verwehrt.

<p>
Der Benutzer und die Gruppe, die bei Rootzugriffen genutzt werden,
können über die <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5"
>exports(5)</a>-Datei auf dem NFS-Server eingestellt werden.

<h3>NFS-Status überprüfen</h3>

<p>
Um sicherzustellen, dass der NFS-Betrieb reibungslos verlaufen kann,
überprüfe, ob alle Daemons über RPC erfolgreich registriert wurden.
Verwende hier für rpcinfo(8).

<blockquote><pre>
$ <b>rpcinfo -p 10.0.0.1</b>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
Für den Normalgebrauch gibt es ein paar Hilfsprogramme, mit denen
du den Status von NFS überprüfen kannst. Eines ist <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8"
>showmount(8)</a> das dir anzeigt, wer was gerade mountet. Dann gibt es
auch noch <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsstat&amp;sektion=1"
>nfsstat(1)</a>, das genauere Statistiken anzeigt. Für
showmount(8) versuche
<tt>/usr/bin/showmount -a host</tt>. Zum Beispiel:

<blockquote><pre>
$ <b>/usr/bin/showmount -a 10.0.0.1</b>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
Diese Ausgabe zeigt, dass der Client 10.0.0.37 den vom Server
10.0.0.1 bereitgestellten Export <tt>/work</tt> gemountet hat.


<a name="Bridge"></a>
<h2>6.9 - Aufsetzen einer Bridge mit OpenBSD</h2>

<p>
Eine <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4"
>Bridge</a> ist ein Link zwischen zwei oder noch mehr separaten
Netzwerken. Anders als ein Router reisen Pakete durch die Bridge
»unsichtbar« - logisch erscheinen die beiden Netzwerksegmente wie eines
für Rechner auf beiden Seiten der Bridge. Die Bridge wird nur Pakete
weiterleiten, die auch von einem Segment in das andere müssen, sie
bieten also auch einen einfachen Weg den Verkehr in einem komplexen
Netzwerk zu reduzieren und erlauben trotzdem den Zugriff jedes Rechners
zu jedem anderen, falls nötig.

<p>
Denk daran, dass aufgrund dieser »unsichtbaren« Natur ein Interface in
einer Bridge eine IP-Adresse haben kann, aber nicht muss. Wenn sie eine
hat, hat die Karte effektiv zwei Betriebsmodi: eine als Teil der Bridge,
die andere als normale eigenständige Netzwerkkarte. Wenn keine der Karten
eine IP-Adresse hat, wird die Bridge einfach Netzdaten verschieben, aber
nicht extern administrierbar oder wartbar sein (was auch ein Feature sein
kann).

<p>
<h3>Ein Beispiel einer Bridgeanwendung</h3>

<p>
Eines meiner Computerracks hat eine Anzahl alter Systeme, von denen
keines eine eingebaute 10BASE-TX-Netzwerkkarte hat. Während sie alle
einen AUI- oder AAUI-Stecker haben, sind die Empfänger auf Koax
beschränkt. Eine der Maschinen in diesem Rack ist ein OpenBSD-basierter
Terminalserver, der dauerhaft eingeschaltet und immer mit einem
Highspeed-Netzwerk verbunden ist. Das Hinzufügen einer zweiten
Netzwerkkarte mit einem Koax-Port erlaubt mir, diese Maschine als Bridge
zum Koax-Netzwerk zu benutzen.

<p>
Dieses System hat jetzt zwei Netzwerkkarten (NICs), eine Intel
EtherExpress/100 (<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"
><tt>fxp0</tt></a>) und eine 3c590-Combokarte (<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"
><tt>ep0</tt></a>) für den Koax-Port. <tt>fxp0</tt> ist der Link zu
meinem restliches Netzwerk und wird daher eine IP-Adresse haben,
<tt>ep0</tt> macht nur Bridging und hat daher keine. Maschinen, die an
das Koax-Segment angeschlossen sind, sollen genau so kommunizieren, als
wenn sie im Rest meines Netzwerkes wären. Wie also bewerkstelligen wir
das?

<p>
Die Datei <tt>hostname.fxp0</tt> enthält die Konfigurationsdaten
für die <tt>fxp0</tt>-Karte.  Diese Maschine soll DHCP machen,
also sieht die Datei etwa so aus:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE
</pre></blockquote>

<p>
Noch keinerlei Überraschungen.

<p>
Die <tt>ep0</tt>-Karte ist ein wenig anders, wie du dir denken kannst:

<blockquote><pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre></blockquote>

<p>
Hier sagen wir dem System, es möge das Interface mittels <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> aktivieren und auf 10BASE-2 (Koax) setzen. Keine
IP-Adresse oder ähnliche Information muss für dieses Interface
spezifiziert werden. Die Optionen, die von der <tt>ep</tt>-Karte
akzeptiert werden, sind detailliert in der <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"
>Manualseite</a> aufgeführt.

<p>
Jetzt müssen wir die Bridge aufsetzen. Bridges werden durch die Existenz
einer Datei namens <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"
><tt>bridgename.bridge0</tt></a>. initialisiert. Hier ist zum Beispiel
eine Datei für meine Situation:

<blockquote><pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre></blockquote>

<p>
Das sagt aus, es soll eine Bridge aus zwei NICs aufgesetzt und aktiviert
werden: fxp0 und ep0. Es ist egal, in welcher Reihenfolge die Karten
aufgeführt werden. Denke daran, dass die Bridge symmetrisch ist - Pakete
fließen ja in beide Richtungen.

<p>
Das war es! Starte neu und du wirst eine funktionierende Bridge haben.

<p>
<h3>Filtern auf der Bridge</h3>

Während es sicher auch eine Menge Anwendungen für eine solch einfache
Bridge gibt, ist es doch wahrscheinlich, dass du etwas mit den ganzen
Paketen TUN willst, während sie durch deine Bridge laufen. Wie zu
erwarten, kann man <a href="#PF">Packet Filter</a> dazu benutzen, den
Traffic einzuschränken, der durch deine Bridge fließt.

<p>
Denke daran, dass wegen der Natur der Bridge die gleichen Daten
über beide Interfaces fließen, aber du nur auf einem Interface
filtern brauchst. Deine »pass all«-Statements würden dann
wie folgt aussehen:

<blockquote><pre>
pass in  on ep0  any
pass out on ep0  any
pass in  on fxp0 any
pass out on fxp0 any
</pre></blockquote>

<p>
Sagen wir nun, ich wolle den Traffic filtern, der auf diese alten
Maschinen trifft. Ich möchte, dass nur Web- und SSH-Verkehr zu ihnen
durchkommt. In diesem Fall lassen wir jeglichen Verkehr durch das
<tt>ep0</tt>-Interface zu (sowohl rein als auch raus) aber filtern auf
dem <tt>fxp0</tt>-Interface, indem wir <tt>keep state</tt> für die
Antwortdaten benutzen:

<blockquote><pre>
# Pass all traffic through ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre></blockquote>

<p>
Denke daran, dass dieses Regelwerk jeglichen Netzwerkverkehr
mit Ausnahme von hereinkommendem HTTP- und SSH-Verkehr zur Bridge selbst
und den Maschinen »dahinter« verhindert. Andere Resultate werden erzielt,
wenn man auf dem anderen Interface filtert.

<p>
Um die Bridge zu überwachen und zu kontrollieren, benutze das <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8"
>brconfig(8)</a>-Kommando, mit dem man eine Bridge auch nach dem Booten
erzeugen kann.

<p>
<h3>Tipps zum Bridging</h3>

<ul>
<li>Es wird WÄRMSTENS empfohlen, nur auf einem Interface zu filtern.
Wenn es auch möglich ist, auf beiden zu filtern, muss man das vorher
jedoch sehr gut verstanden haben.

<li>Durch die Benutzung der <i>blocknonip</i>-Option von <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8"
>brconfig(8)</a> oder in <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"
>bridgename.bridge0</a> kannst du jeglichen Datenverkehr, der nicht
zum IP-Traffic gehört (wie etwa IPX oder NETBEUI), davon abhalten, sich
um deine Filter herumzustehlen. Das kann in einigen Situationen sehr
wichtig sein, aber du solltest wissen, dass Bridges für jeglichen
Datenverkehr funktionieren, nicht nur für IP.

<li>Für Bridging müssen die NICs im »promiscuous mode« sein - sie
lauschen einfach am GESAMTEN Netzwerkverkehr, nicht nur an dem, der
an das Interface gerichtet ist. Das hat einen höheren Load für
CPU und Bus zur Folge, als man denkt. Einige NICs funktionieren leider
nicht sauber in diesem Modus, der TI-ThunderLAN-Chip (<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4"
>tl(4)</a>) ist leider so ein Beispiel, der nicht als Teil einer Bridge
funktioniert.
</ul>

<a name="PXE"></a>
<h2>6.10 - Wie boote ich mit PXE? (i386, amd64)</h2>
Das »Preboot Execution Environment« (oder kurz PXE) ist ein Weg, um
einen Computer statt von Festplatte, Diskette oder CD-ROM vom Netzwerk
zu booten. Diese Technologie wurde zuerst von Intel entwickelt, doch
wird nun von den meisten führenden Netzwerkkarten- und
Computerherstellern unterstützt. Bedenke, dass es viele verschiedene
Netzwerkbootprotokolle gibt: PXE ist relativ neu. Traditionellerweise
wird das PXE-Booting unter Verwendung von ROMs auf dem NIC oder dem
Mainboard ausgeführt, doch sind ebenfalls Bootdisketten von etlichen
Quellen verfügbar, die ebenfalls das PXE-Booting zulassen. Viele ROMs
auf älteren NICs unterstützen zwar das Booten vom Netzwerk, allerdings
NICHT PXE; OpenBSD/i386 oder am64 können mit diesen zurzeit nicht über
das Netzwerk gebootet werden.



<p>
<h3>Wie funktioniert das PXE-Booting?</h3>
Zuerst sollte die Funktionsweise des
<a href="faq14.html#Boot386">OpenBSD-Bootprozesses</a> auf i386- und
am64-Plattformen verstanden werden. Auf den Bootprozess folgend sendet
die PXE-fähige NIC eine DHCP-Anfrage über das Netzwerk. Der DHCP-Server
wird dem Adapter eine IP zuweisen und gibt ihm den Namen einer Datei,
die von einem <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a>-Server bezogen und ausgeführt werden muss. Diese Datei
leitet dann den Rest des Bootprozesses ein. Für OpenBSD ist es die <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot</a>-Datei, die den Platz der standardmäßigen <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>boot(8)</a>-Datei einnimmt. pxeboot(8) ist dann in der Lage, einen
Kernel wie zum Beispiel <tt>bsd</tt> oder <a
href="faq4.html#bsd.rd"><tt>bsd.rd</tt></a> vom gleichen tftp(1)-Server
zu laden und auszuführen.

<h3>Wie mache ich das?</h3>
Der erste und offensichtlichste Schritt ist, dass du einen
PXE-bootfähigen Computer oder Netzwerkadapter haben musst. Einige
Dokumente weisen darauf hin, dass alle modernen NICs und Computer
PXE-Unterstützung hätten, aber das ist einfach nicht wahr -
viele Niedrigpreissysteme liefern keine PXE-ROMs mit oder verwenden
ein älteres Netzwerkbootprotokoll. Du brauchst außerdem einen
ordentlich konfigurierten <a href="#DHCP">DHCP</a>- und TFTP-Server.

<p>
Davon ausgehend, dass eine OpenBSD-Maschine die Quelle der Bootdateien
ist, muss die <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf&amp;sektion=5"
>dhcpd.conf</a>-Datei des DHCP-Servers folgende Zeile beinhalten:
<pre>
    filename "pxeboot";
</pre>
damit der DHCP-Server diese Datei dem bootenden Arbeitsplatz anbietet.
Zum Beispiel:

<pre>
    shared-network LOCAL-NET {
            option  domain-name "example.com";
            option  domain-name-servers 192.168.1.3, 192.168.1.5;

            subnet 192.168.1.0 netmask 255.255.255.0 {
                    option routers 192.168.1.1;
                    <b>filename "pxeboot";</b>
                    range 192.168.1.32 192.168.1.127;
                    default-lease-time 86400;
                    max-lease-time 90000;
            }
    }
</pre>

<p>
Du musst außerdem den <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftpd&amp;sektion=8"
>tftpd(8)</a>-Daemon aktivieren. Dies wird normalerweise durch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8"
>inetd(8)</a> realisiert.
Die standardmäßige OpenBSD-Installation hat eine Beispielzeile in
<tt>inetd.conf</tt>, die wunderbar für dich funktionieren wird:
<pre>
    #tftp  dgram   udp  wait  root  /usr/libexec/tftpd   tftpd -s /tftpboot
</pre>

von der lediglich das »#«-Zeichen entfernt werden muss. Sende inetd(8)
ein -HUP Signal, um mitzuteilen, dass <tt>/etc/inetd.conf</tt> neu
geladen werden soll. tftpd(8) bietet die Dateien von einem bestimmten
Verzeichnis an, in dem Fall von dieser Zeile ist es das
<tt>/tftpboot</tt>-Verzeichnis, welches wir für dieses Beispiel
verwenden werden. Offensichtlich ist, dass dieses Verzeichnis angelegt
und eingerichtet werden muss. Typischerweise wirst du hier nur ein paar
Dateien für das PXE-Booting haben:

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot</a>, der PXE-Bootloader (der die gleichen Funktionen
bereitstellt wie <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>boot</a> auf einem plattenbasierten System).
<li><a href="faq4.html#bsd.rd">bsd.rd</a>, der Installationskernel, oder
<tt>bsd</tt>, ein angepasster Kernel.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"
>/etc/boot.conf</a>, eine Bootkonfigurationsdatei.
</ul>

Denke daran, dass <tt>/etc/boot.conf</tt> nur gebraucht wird, wenn der
Kernel, den du booten möchtest, nicht <tt>bsd</tt> heißt oder andere
pxeboot-Standardwerte nicht so sind, wie du sie haben möchtest
(zum Beispiel, wenn du eine serielle Konsole wünschst).
Du kannst deinen tftpd(8)-Server mit einem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a>-Client testen, indem du sicherstellst, dass du die
benötigten Dateien herunterladen kannst.

<p>
Wenn deine DHCP- und TFTP-Server laufen, bist du bereit, es auszuprobieren.
Du wirst PXE-Boot auf deinem System oder auf der Netzwerkkarte aktivieren
müssen; konsultiere deine Systemdokumentation. Wenn du es gesetzt hast,
solltest du etwas sehen, das diesem ähnlich ist:

<pre>
    Intel UNDI, PXE-2.0 (build 067)
    Copyright (C) 1997,1998 Intel Corporation

    For Realtek RTL 8139(X) PCI Fast Ethernet Controller v1.00 (990420)

    DHCP MAC ADDR: 00 E0 C5 C8 CF E1
    CLIENT IP: 192.168.1.76  MASK: 255.255.255.0  DHCP IP: 192.168.1.252
    GATEWAY IP: 192.168.1.1
    probing: pc0 com0 com1 apm pxe![2.1] mem[540k 28m a20=on]
    disk: hd0*
    net: mac 00:e0:c5:c8:cf:e1, ip 192.168.1.76, server 192.168.1.252
    >> OpenBSD/i386 PXEBOOT 1.00
    boot>
</pre>

Zu diesem Zeitpunkt hast du den normalen OpenBSD-Bootprompt.
Wenn du hier einfach »<tt>bsd.rd</tt>« eintippst, wirst du die Datei
<tt>bsd.rd</tt> von dem TFTP-Server laden.

<pre>
    >> OpenBSD/i386 PXEBOOT 1.00
    boot> bsd.rd
    booting tftp:bsd.rd: 4375152+733120 [58+122112+105468]=0x516d04
    entry point at 0x100120

    Copyright (c) 1982, 1986, 1989, 1991, 1993
            The Regents of the University of California.  All rights reserved.

    Copyright (c) 1995-2008 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

    OpenBSD 4.4 (RAMDISK_CD) #857: Tue Aug 12 17:31:49 MDT 2008
      ...
</pre>

Der <a href="faq4.html#bsd.rd">bsd.rd-Installationskernel</a> wird nun
booten.

<p>

<h3>Kann ich andere Kerneltypen mit PXE booten, außer
<tt>bsd.rd</tt>?</h3>

Ja, obwohl mit den Programmen, die zurzeit in OpenBSD enthalten sind,
PXE-Booting primär für die Installation des OS gedacht ist.

<a name="CARP"></a>
<h2>6.11 - Das Common-Address-Redundancy-Protokoll (CARP)</h2>
<h3>6.11.1 - Was ist CARP und wie funktioniert es?</h3>
<!-- This article written by Sunny Raspet, slr@mordac.info, and
released under the BSD license -->

<p>
CARP ist ein Werkzeug um beim Erreichen von Systemredundanz zu helfen,
indem mehrere Computer ein einzelnes, virtuelles Netzwerkinterface
zwischen sich errichten, sodass beim Ausfall eines Systems ein
anderes antworten kann. Des Weiteren wird somit ein gewisser Grad an
Lastverteilung zwischen Systemen ermöglicht. CARP ist eine Verbesserung
vom Standard Virtual-Router-Redundancy-Protokoll (VRRP). Es wurde
entwickelt, nachdem VRRP als nicht frei genug wegen einem
möglicherweise überlappendem Cisco-Patent angesehen wurde. Für weitere
Informationen über CARPs Ursprünge und den rechtlichen Problemen mit
VRRP, besuche bitte <a href="../../lyrics.html#35">diese Seite</a>.

<p>
Um gesetzliche Konflikte zu umgehen, entwarf Ryan McBride (mit Hilfe von
Michael Shalayeff, Marco Pfatschbacher und Markus Friedl) CARP so, dass
es fundamental anders war. Die Einbindung von Kryptographie ist eine der
prominentesten Änderungen - aber weiterhin nur eine von vielen.

<p>
Wie es funktioniert: CARP ist ein Multicast-Protokoll. Es gruppiert
mehrere physikalische Computer unter einer oder mehreren virtuellen
Adressen zusammen. Von diesen ist ein System der Master und antwortet
auf alle Pakete, die für diese Gruppe bestimmt sind, während die anderen
Systeme als Hotspares agieren. Unbedeutend wie die IP- und MAC-Adressen
des lokalen Interfaces sind, werden Pakete, die zum CARP-Interface
gesendet worden sind, mit CARP-Informationen zurückgesendet.

<p>
Zu konfigurierbaren Intervallen bekundet der Master seine Operation auf
der IP-Protokollnummer 112. Wenn der Master offline geht, beginnen die
anderen Systeme in der CARP-Gruppe mit dem bekunden. Der Host, der in
der Lage ist am häufigsten zu bekunden, wird der neue Master. Wenn das
Hauptsystem wieder online kommt, wird es standardmäßig ein Backuphost,
obwohl wenn es wünschenswerter ist, dass ein Host immer Master wird wenn
das möglich ist (z.&nbsp;B. wenn ein Host eine schnelle Sun Fire V120
ist und die anderen vergleichbar langsame SPARCstation IPCs sind),
kannst du sie so konfigurieren.

<p>
Während hoch redundante und fehlertolerante Hardware die Notwendigkeit
von CARP verringert, vernichtet sie sie nicht. Es gibt keine
Hardwarefehlertoleranz die in der Lage ist zu helfen, wenn jemand das
Stromkabel herauszieht oder wenn dein Systemadministrator
<tt>reboot</tt> im falschen Fenster eintippt. CARP macht es außerdem
einfacher, den Patch- und Rebootzyklus transparent den Anwendern
gegenüber zu gestalten, und einfacher ein Software- oder Hardwareupgrade
zu testen - wenn es nicht funktioniert, kannst du auf deine Spares
zurückgreifen, bis es behoben ist.

<p>Es gibt jedoch Situationen, in denen CARP nicht helfen wird.
CARPs Design setzt voraus, dass die Mitglieder einer Gruppe sich im
selben physikalischen Subnetz mit einer statischen IP-Adresse befinden,
obwohl mit der Einführung der carpdev-Direktive es keine Notwendigkeit
mehr gibt, den physischen Interfaces IP-Adressen zuzuweisen. Ähnlich
werden Dienste, die eine durchgehende Verbindung zum Server benötigen
(so wie SSH oder IRC), nicht transparent auf andere Systeme
weitergeleitet - obwohl in diesem Fall CARP helfen kann, die Ausfallzeit
zu minimieren. CARP wird von sich aus Daten zwischen Applikationen nicht
synchronisieren, dies muss über »alternative Kanäle« wie zum Beispiel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfsync&amp;sektion=4"
>pfsync(4)</a> (für redundantes Filtern), manuelles Duplizieren von
Daten zwischen Systemen mit <a href="http://rsync.samba.org/">rsync</a>
oder was auch immer für deine Anwendungen geeignet ist, durchgeführt
werden.

<h3>6.11.2 - Konfiguration</h3>

<p>
CARPs Kontrollen befinden sich an zwei Orten: <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8"
>sysctl(8)</a> und <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>.
Lass uns nun zuerst die sysctls betrachten.

<p>Die erste sysctl namens <tt>net.inet.carp.allow</tt> definiert, ob
der Host überhaupt CARP-Pakete handhabt. Klarerweise ist dies notwendig,
um CARP nutzen zu können. Diese sysctl ist standardmäßig aktiviert.

<p>Die zweite namens <tt>net.inet.carp.arpbalance</tt> wird für die
Lastverteilung verwendet. Wenn diese Funktion aktiviert ist, wird CARP
ein Sourcehash auf die Quell-IP der Anfrage durchführen. Dieser Hash
wird dann verwendet, um einen virtuellen Host aus dem zur Verfügung
stehenden Pool auszuwählen, damit dieser die Anfrage verarbeitet.
Dies ist standardmäßig deaktiviert.

<p>Die dritte namens <tt>net.inet.carp.log</tt> zeichnet CARP-Fehler
auf. Standardmäßig deaktiviert.

<p>Die vierte namens <tt>net.inet.carp.preempt</tt> aktiviert natürliche
Auswahl zwischen CARP-Hosts. Der passendste für den Job (das heißt, wer
in der Lage ist am schnellsten zu bekunden) wird zum Master.
Standardmäßig deaktiviert: Das bedeutet, dass ein System, das nicht
zum Master auserwählt wurde, nicht versuchen wird den Masterstatus
(wieder) zu erhalten.

<p>
Alle diese sysctl-Variablen sind in <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3"
>sysctl(3)</a> dokumentiert.

<p>Für den Rest von CARPs Konfiguration verlassen wir uns auf <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a>. Die CARP-spezifischen Kommandos <tt>advbase</tt> und
 <tt>advskew</tt> behandeln das Intervall zwischen CARP-Advertisements.
Die Formel (in Sekunden) ist <tt>advskew</tt> dividiert durch 256 und
dann zu <tt>advbase</tt> addiert.
<tt>advbase</tt> kann verwendet werden, um Netzwerkverkehr zu verringern
oder eine längere Latenz zuzulassen, bevor ein Backuphost übernimmt;
<tt>advskew</tt> lässt dir die Möglichkeit zu verwalten, welcher
Host Master sein wird, ohne große Failoververzögerungen
(sollte das notwendig sein).

<p>Als nächstes setzt <tt>pass</tt> ein Passwort und <tt>vhid</tt> die
virtuelle Hostidentifizierungsnummer der CARP-Gruppe. Du musst jeder
CARP-Gruppe eine einzigartige Nummer verteilen, selbst wenn (für
Lastverteilung) sie sich die gleiche IP-Adresse teilen.  CARP ist auf
255 Gruppen begrenzt.

<p>
Zum Schluss gibt <tt>carpdev</tt> an, welches physische Interface zu
dieser bestimmten CARP-Gruppe gehört.
Standardmäßig gilt, dass jedes Interface, das eine IP-Adresse im
gleichen Subnetz von CARP zugewiesen bekam, genutzt wird.

<p>Lass uns alle diese Einstellungen zusammen in eine Grundkonfiguration
packen. Angenommen du setzt zwei identische Webserver auf,
<i>rachael</i> (192.168.0.5) und <i>pris</i> (192.168.0.6), um ein
älteres System zu ersetzen, das unter 192.168.0.7 verfügbar war. Die
Befehle:

<blockquote><pre>
rachael# <b>ifconfig carp0 create</b>
rachael# <b>ifconfig carp0 vhid 1 pass tyrell carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

<p>erstellen das carp0-Interface und geben es eine vhid von 1, ein
Passwort, das <i>tyrell</i> lautet, und die IP-Adresse 192.168.0.7 mit
der Maske 255.255.255.0. Weise fxp0 als Mitgliedsinterface zu. Um es
über die nächsten Reboots hinaus permanent zu machen, kannst
du eine <tt>/etc/hostnamecarp0</tt>-Datei anlegen, die wie folgt
aussieht:

<blockquote><pre>
inet 192.168.0.7 255.255.255.0 192.168.0.255 vhid 1 pass tyrell carpdev fxp0
</pre></blockquote>

Achte darauf, dass die Broadcastadresse in der Zeile neben der vhid
und dem Passwort mit angegeben wurde. Das Vergessen der Angabe dieser
Adresse ist ein häufiger Grund für Fehler, da sie als Platzhalter
benötigt wird.

<p>
Mache das Gleiche auf <i>pris</i>. Welches System von beiden das
CARP-Interface zu erst aufsetzt wird Master (unter der Annahme, dass
»preempt« deaktiviert ist; das Gegenteil ist der Fall, wenn »preempt«
aktiviert wurde).

<p>

Aber lass uns sagen, dass du nicht von Anfang an aufsetzt.
<i>rachael</i> war bereits unter der Adresse 192.168.0.7 vorhanden.
Wie umgehst du das? Glücklicherweise kann CARP mit dieser Situation
umgehen. Du kannst die Adresse einfach dem CARP-Interface zuweisen und
das physikalische Gerät bei der Angabe des »carpdev«-Schlüsselwortes
belassen, ohne eine IP-Adresse zuzuweisen. Trotz allem tendiert es dazu
sauberer zu sein jeweils eine IP für jedes System zu haben - es macht
individuelle Überwachungen und Zugriffe viel einfacher.

<p>Lass uns nun einen weiteren Schwierigkeitsgrad hinzufügen; wir
möchten, dass <i>rachael</i> so lange wie möglich Master bleibt.
Es gibt einige Gründe, warum wir das benötigen könnten:
Hardwareunterschiede, einfache Vorurteile, »wenn das System nicht Master
ist, wird es Probleme geben« oder zu wissen, wer der standardmäßige
Master ist ohne mit Skripten die Ausgabe von ifconfig zu verarbeiten und
per E-Mail zu versenden.

<p>Auf <i>rachael</i> werden wir die sysctl verwenden, die wir weiter
oben erstellt haben und editieren dann <tt>/etc/sysctl.conf</tt>, um sie
permanent zu machen.

<blockquote><pre>
rachael# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>Wir werden ebenfalls die Konfiguration auf <i>pris</i> durchführen:

<blockquote><pre>
pris# <b>ifconfig carp0 advskew 100</b>
</pre></blockquote>

<p>Dies verzögert die Bekundungen von <i>pris</i> ein wenig, was
bedeutet, dass <i>rachael</i> Master sein wird, wenn der Host
angeschlossen wurde.

<p>
Bedenke, dass du »proto carp« mit folgender Zeile an alle beteiligten
Interfaces übergeben musst, wenn du PF auf einem geCARPten Computer
verwendest:
<blockquote><pre>
pass on fxp0 proto carp keep state
</pre></blockquote>

<h3>6.11.3 - Lastverteilung</h3>

<p>Siehe nun einige Monate nach vorne. Unsere Firma des vorherigen
Beispiels ist so gewachsen, dass sie an dem Punkt angekommen ist, an dem
ein einzelner Webserver die Last gerade so verarbeiten kann. Was nun?
CARP ist die Rettung. Es ist Zeit, Lastverteilung zu versuchen. Erstelle
ein neues CARP-Interface und eine neue CARP-Gruppe auf <i>rachael</i>:

<blockquote><pre>
rachael# <b>ifconfig carp1 create</b>
rachael# <b>ifconfig carp1 vhid 2 advskew 100 pass bryant carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

<p>Auf <i>pris</i> werden wir ebenfalls eine neue Gruppe und Interface
anlegen und dann das »preempt«-sysctl setzen:

<blockquote><pre>
pris# <b>ifconfig carp1 carp1</b>
pris# <b>ifconfig carp1 vhid 2 pass bryant carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
pris# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>Nun haben wir zwei CARP-Gruppen mit der gleichen IP-Adresse.
Jede Gruppe zeigt auf einen anderen Host. Das bedeutet, dass
<i>rachael</i> Master der originalen Gruppe bleibt, aber <i>pris</i> die
neue übernehmen wird.

<p>Alles, was wir nun tun müssen, ist die sysctl für die Lastverteilung
auf beiden Systemen zu laden, die wir zuvor besprochen haben:

<blockquote><pre>
# <b>sysctl net.inet.carp.arpbalance=1</b>
</pre></blockquote>

<p>Während diese Beispiele für einen Cluster bestehend aus zwei
Maschinen sind, gelten die gleichen Prinzipien auch für mehrere Systeme.
Bitte bedenke, dass es trotzdem nicht erwartet wird, dass du perfekte
50/50-Distribution zwischen den beiden Maschinen erreichst - CARP
verwendet einen Hash der ankommenden IP-Adresse um zu ermitteln, welches
System die Anfrage verarbeitet, statt durch Auslastung zu entscheiden.

<h3>6.11.4 - Weitere Informationen zu CARP</h3>
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>
<li><a href="http://www.countersiege.com/doc/pfsync-carp/">Firewall
Failover with pfsync and CARP</a> von Ryan McBride
</ul>

<a name="OpenNTPD"></a>
<h2>6.12 - OpenNTPD verwenden</h2>
Genaue Zeit ist wichtig für viele Computerapplikationen.
Trotzdem mussten viele Leute feststellen, dass ihre $5-Uhr eine genauere
Uhrzeit halten kann als ihr $2000-Computer. Zusätzlich zum Wissen,
welche Uhrzeit gerade ist, ist es ebenfalls häufig wichtig, Computer zu
synchronisieren, sodass sie alle mit der gleichen Uhrzeit
übereinstimmen. Für eine gewisse Zeit hat <a
href="http://www.ntp.org">ntp.org</a> ein Applikation für das
 Network-Time-Protokoll (<a
href="http://www.ietf.org/rfc/rfc1305.txt">RFC1305</a>, <a
href="http://www.ietf.org/rfc/rfc2030.txt">RFC2030</a>) entwickelt,
verfügbar als <a href="faq15.html#Ports">Port</a>, die verwendet werden
kann, um die Uhren auf den Computern über das Internet zu
synchronisieren.  Trotzdem ist dies ein nicht triviales Programm zum
Einrichten, schwerer Code zum Überprüfen und hat eine große
Speicheranforderung. Kurz gesagt spielt es eine wichtige Rolle für
einige Leute, aber es ist weit entfernt von einer Lösung für jedermann.

<p>
<a href="http://www.openntpd.org/de">OpenNTPD</a> ist ein Versuch,
einige dieser Probleme zu lösen, es einfacher zu administrieren zu
machen und ein sicherer und simpler NTP-kompatibler Weg zu sein, um eine
genaue Uhrzeit auf deinem Computer zu haben. OpenBSDs <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd&amp;sektion=8"
>ntpd(8)</a> wird von einer einfach zu verstehenden Konfigurationsdatei
gesteuert: <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5"
><tt>/etc/ntpd.conf</tt></a>.

<p>
Aktiviere ntpd(8) einfach in <a href="faq10.html#rc">rc.conf.local</a>
und das Resultat wird sein, dass deine Computeruhr nach und nach
weiter nach vorne gestellt wird, bis sie sich selbst mit den <a
href="http://www.pool.ntp.org/">pool.ntp.org</a>-Servern synchronisiert
halten kann - einer Sammlung von öffentlich verfügbaren Zeitservern.
Wenn deine Uhr erst einmal genau eingestellt ist, wird ntpd sie auf einem
sehr hohen Genauigkeitsgrad halten. Sollte deine Uhr jedoch um einige
Minuten falsch gehen, so wird <i>dringend</i> dazu geraten, sie zuerst
genau einzustellen, da es Tage oder sogar Wochen dauern kann, eine sehr
ungenau eingestellte Uhr zu synchronisieren. Du kannst dies tun, indem
du entweder die Option »<tt>-s</tt>« an ntpd(8) übergibst oder aber
einen anderen Weg findest, wie du deine Systemzeit richtig einstellen
kannst.

<a name="OpenNTPDaccurate"></a>
<h3>6.12.1 - »Aber OpenNTPD ist nicht so genau wie der ntp.org-Daemon!«</h3>
Das mag wahr sein. Es ist nicht OpenNTPDs
<a href="http://www.openntpd.org/de/goals.html">Entwurfssziel</a>. Es
ist vorgesehen, dass es frei, simpel, zuverlässig und sicher ist.
Wenn du wirklich Mikrosekundenpräzision mehr als die Vorteile von
OpenNTPD brauchst, tu dir keinen Zwang an und verwende ntp.orgs ntpd, da
er weiterhin als Port und Package verfügbar sein wird. Es existieren
weder ein Plan noch das Verlangen, OpenNTPD mit allen vorstellbaren
Funktionen vollzustopfen.

<a name="OpenNTPDharmful"></a>
<h3>6.12.2 - »Jemand hat behauptet, dass OpenNTPD schädlich ist!«</h3>
Einige Leute haben die Ziele von OpenNTPD nicht verstanden: ein
einfacher, sicherer und einfach zu verwaltender Weg, um die Uhr deines
Computers genau zu halten. Wenn genaue Zeit wichtig ist, haben einige
Benutzer berichtet, dass die Ergebnisse von OpenNTPD besser sind als
die von ntp.orgs ntpd. Wenn Sicherheit wichtig ist, ist OpenNTPDs Code
sehr viel besser lesbar (und daher kontrollierbar) und wurde unter
Verwendung von OpenBSD-Funktionsaufrufen wie <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy&amp;sektion=3"
>strlcpy</a> statt portableren Funktionen wie <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=strcpy&amp;sektion=3"
>strcpy</a> entwickelt und wurde von Anfang an sicher geschrieben und
nicht »später sicher gemacht«. Wenn es wertvoll ist, dass so viele Leute
wie möglich Zeitsynchronisierung verwenden, macht es OpenNTPD einer
großen Anzahl Leute einfacher, diese zu nutzen. Wenn das
»schädlich« ist, stimmen wir dem voll und ganz zu.

<p>
Es gibt Anwendungsgebiete, bei denen ntp.orgs ntpd genauer ist, trotzdem
geht man davon aus, dass für einen Großteil der restlichen Anwender
OpenNTPD mehr als ausreichend sein wird.

<p>
Eine ausführlichere Antwort hierauf von den OpenNTPD-Entwicklern kannst
du <a
href="http://www.advogato.org/person/dtucker/diary.html?start=52"
>hier</a> lesen.

<a name="OpenNTPDNoServe"></a>
<h3>6.12.3 - Warum können meine anderen Systeme nicht ihre
Uhrzeit mit OpenNTPD abgleichen?</h3>

Standardmäßig hört ntpd(8) auf keiner Adresse. Damit du OpenNTPD also
als Server verwenden kannst, musst du die Zeile
»<tt>#listen&nbsp;on&nbsp;*</tt>« in <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5"
>/etc/ntpd.conf</a> auskommentieren und den ntpd(8)-Daemon neustarten.
Selbstverständlich kannst du auch eine bestimmte IP-Adresse angeben, so
dass er nicht auf allen verfügbaren Adressen und Interfaces hört:
ersetze »*« mit der gewünschten Adresse.

<p>
Obwohl nun ntpd(8) erreichbar ist, kann es durchaus passieren, dass sich
andere Maschinen noch immer nicht synchronisieren können. Ein erst
kürzlich gestarteter ntpd(8)-Daemon (wenn du zum Beispiel jetzt gerade
nach der Anpassung der ntpd.conf neugestartet hast) verweigert die
Angabe von Zeitinformationen an andere Clients, bis er seine eigene
Uhrzeit auf ein hinnehmbar stabiles Maß angepasst hat. Wenn ntpd(8)
seine eigene Zeitinformation als stabil betrachtet, wird der Eintrag
»clock now synced« in <tt>/var/log/daemon</tt> geschrieben. Selbst wenn
die Systemzeit bereits von Anfang an sehr genau war, kann es bis zu 10
Minuten dauern, bis alles synchronisiert ist - wenn die Uhrzeit nicht
genau eingestellt ist sogar Stunden oder Tage.



<a name="Wireless"></a>
<h2>6.13 - Welche Möglichkeiten stehen mir für Drahtlosnetzwerke zur
Verfügung?</h2>
OpenBSD hat Unterstützung für eine Vielzahl an Wireless-Chipsätzen:
<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=awi&amp;sektion=4"
>awi(4)</a> AMD 802.11 PCnet Mobile.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&amp;sektion=4"
>an(4)</a> Aironet Communications 4500/4800.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&amp;sektion=4"
>wi(4)</a> Prism2/2.5/3. <sup>(AP</sup>
<li><a
 href="http://www.openbsd.org/cgi-bin/man.cgi?query=atw&amp;sektion=4"
>atw(4)</a> ADMtek ADM8211.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ath&amp;sektion=4"
>ath(4)</a> Treiber für Atheros IEEE 802.11a/b/g. <sup>(AP)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&amp;sektion=4"
>iwi(4)</a> Intel PRO/Wireless 2200BG/2225BG/2915ABG IEEE 802.11a/b/g.
<sup>(NFF)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipw&amp;sektion=4"
>ipw(4)</a> Intel PRO/Wireless 2100 IEEE 802.11b. <sup>(NFF)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=atu&amp;sektion=4"
>atu(4)</a> Atmel AT76C50x USB IEEE 802.11b.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ral&amp;sektion=4"
>ral(4)</a> und <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ural&amp;sektion=4"
>ural(4)</a> [USB] Ralink Technology RT25x0 IEEE 802.11a/b/g.
<sup>(AP)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=rtw&amp;sektion=4"
>rtw(4)</a> Realtek 8180 IEEE 802.11b. <sup>(AP)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=acx&amp;sektion=4"
>acx(4)</a> TI ACX100/ACX111. <sup>(NFF) (AP)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pgt&amp;sektion=4"
>pgt(4)</a> Conexant/Intersil Prism GT Full-MAC. <sup>(NFF) (AP)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=rum&amp;sektion=4"
>rum(4)</a> Ralink Technology RT2501USB. <sup>(AP)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=wpi&amp;sektion=4"
>wpi(4)</a> Intel PRO/Wireless 3945ABG. <sup>(NFF)</sup>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=uath&amp;sektion=4"
>uath(4)</a> Atheros AR5005UG/AR5005UX USB2.0 (es wird dran gearbeitet).
<sup>(NFF)</sup>

</ul>

<sup>(AP)</sup> weist darauf hin, dass diese Karte als Accesspoint
eingesetzt werden kann.<br>
<sup>(NFF)</sup> weist darauf hin, dass der Chip eine nicht freie
Firmware benötigt, die nicht in OpenBSD eingebunden werden kann.

<p>
Karten, die auf diesen Chips basieren, können fast genauso wie andere
Netzwerkkarten genutzt werden, um ein OpenBSD-System mit Hilfe von <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8"
>ifconfig(8)</a> an ein existierendes Drahtlosnetzwerk anzubinden (bitte
lies die Manualseiten für präzise Details). Einige dieser Karten können
jedoch auch im hostbasierten Accesspointmodus genutzt werden, das ihnen
erlaubt, in deinen Wireless-Accesspoint für dein Netzwerk als Teil
deiner Firewall gesetzt zu werden.

<p>
Beachte bitte, dass du für einige Karten erst die Firmwaredateien
beziehen musst, bevor du sie einsetzen kannst. Dies gilt für alle
Firmwaredateien, für die die Hersteller keine <a
href="faq1.html#ReallyFree">freie</a> Weiterverbreitung erlauben,
sodass sie nicht in OpenBSD eingebunden werden können. Wenn möglich,
dann lies die zuvor aufgelisteten Manualseiten. Sie beinhalten
Kontaktadressen für die zuständigen Mitarbeiter der Firma, sodass du
sie anschreiben und ihnen mitteilen kannst, wie du darüber denkst.
Oder teile ihnen mit, welches Produkt du stattdessen erworben hast.

<p>
Eine andere Möglichkeit, mit deiner OpenBSD-basierten Firewall einen
Wireless Access anzubieten, ist die Verwendung einer konventionellen NIC
und einem externen Bridging-Accesspoint.
Dies hat den zusätzlichen Vorteil, dass du die Position der Antenne
mit Leichtigkeit an die Stelle ändern kannst, an der sie am
effektivsten ist, was nicht häufig direkt auf der Rückseite
deiner Firewall ist.


<a name="Multipath"></a>
<h2>6.14 - Wie kann ich »equal-cost multipath routing« durchführen?</h2>

<p>
»Equal-cost multipath routing« bedeutet, dass sich mehrere Routen
in der Routingtabelle für das gleiche Netzwerk befinden - zum
Beispiel die Standardroute 0.0.0.0/0. Wenn der Kernel nach einer Route
sucht, um Pakete an ein bestimmtes Netzwerk senden zu können, kann er
eine von den »equal-cost routes« auswählen. In den meisten Fällen wird
Multipathrouting eingesetzt, um redundante Uplinkverbindungen aufzubauen,
z. B. redundante Internetverbindungen.

<p>
Das Kommando <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8"
>route(8)</a> wird verwendet, um Routen zur Routingtabelle hinzuzufügen,
dort zu ändern oder sie aus der Routingtabelle zu löschen. Das Argument
<tt>-mpath</tt> wird verwendet, um Multipath-Routen hinzuzufügen.

<blockquote><pre>
# <b>route add -mpath default 10.130.128.1</b>
# <b>route add -mpath default 10.132.0.1</b>
</pre></blockquote>

<p>
Überprüfe die Routen wie folgt:

<blockquote><pre>
# <b>netstat -rnf inet | grep default</b>
default     10.130.128.1      UGS       2      134      -     fxp1
default     10.132.0.1        UGS       0      172      -     fxp2
</pre></blockquote>

<p>
In diesem Beispiel können wir sehen, dass eine Standardroute auf
10.130.128.1 zeigt, die über das fxp1-Interface erreichbar ist. Die
andere zeigt auf 10.132.0.1 und ist über fxp2 erreichbar.

<p>
Da die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate&amp;sektion=5"
>mygate(5)</a> bisher noch keine Multipath-Standardrouten unterstützt,
sollte der vorherige Befehl an das Ende der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
>hostname.if(5)</a>-Dateien für die Interfaces fxp1 und fxp2 angehängt
werden. Die <tt>/etc/mygate</tt>-Datei sollte danach gelöscht werden.

<dl>
<dt><b>/etc/hostname.fxp1</b></dt>
<dd><tt>!route add -mpath default 10.130.128.1</tt></dd>
<dt><b>/etc/hostname.fxp2</b></dt>
<dd><tt>!route add -mpath default 10.132.0.1</tt></dd>
</dl>

<p>
Vergiss zum Schluss nicht, dass du den Einsatz von Multipathrouten
mit der dafür vorgesehenen sysctl(3)-Variablen aktivieren musst.

<blockquote><pre>
# <b>sysctl net.inet.ip.multipath=1</b>
# <b>sysctl net.inet6.ip6.multipath=1</b>
</pre></blockquote>

<p>
Ändere ebenfalls die Datei <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5"
>sysctl.conf(5)</a>, um die Änderungen permanent zu machen.

<p>
Versuch nun traceroute mit verschiedenen Zielen aufzurufen. Der
Kernel wird die Datenlast auf die einzelnen Multipathrouten ausgleichen.

<blockquote><pre>
# <b>traceroute -n 154.11.0.4</b>
traceroute to 154.11.0.4 (154.11.0.4), 64 hops max, 60 byte packets
 1  10.130.128.1  19.337 ms  18.194 ms  18.849 ms
 2  154.11.95.170  17.642 ms  18.176 ms  17.731 ms
 3  154.11.5.33  110.486 ms  19.478 ms  100.949 ms
 4  154.11.0.4  32.772 ms  33.534 ms  32.835 ms

# <b>traceroute -n 154.11.0.5</b>
traceroute to 154.11.0.5 (154.11.0.5), 64 hops max, 60 byte packets
 1  10.132.0.1  14.175 ms  14.503 ms  14.58 ms
 2  154.11.95.38  13.664 ms  13.962 ms  13.445 ms
 3  208.38.16.151  13.964 ms  13.347 ms  13.788 ms
 4  154.11.0.5  30.177 ms  30.95 ms  30.593 ms
</pre></blockquote>

<p>
Lies im <a href="http://www.ietf.org/rfc/rfc2992.txt">RFC2992</a>
das Kapitel »Analysis of an Equal-Cost Multi-Path Algorithm« wenn du
Genaueres über die Routenauswahl erfahren möchtest.

<p>
Des Weiteren ist es erwähnenswert, dass beim Ausfall eines Interfaces
(z. B. beim Verlust des Carriers) für eine Multipathroute der Kernel
weiterhin versucht, Pakete über die Route zu senden, die an dieses
Interface gebunden wurde. Der Datenverkehr wird natürlich ins Nichts
führen und somit verloren gehen. Es wird daher dringend empfohlen,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifstated&amp;sektion=8"
>ifstated(8)</a> auf nicht verfügbare Interfaces zu überprüfen und die
Routingtabelle dementsprechend anzupassen.


<p>
<font color="#0000e0">
<a href="index.html">[FAQ-Index]</a>
<a href="faq5.html">[Zum Kapitel 5 - Das System aus dem Quelltext erzeugen]</a>
<a href="faq7.html">[Zum Kapitel 7 - Tastatur- und Bildschirmkontrollen]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[zurück]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq6.html,v 1.270 ]<br>
$Translation: faq6.html,v 1.156 2008/10/31 19:20:41 simon Exp $<br>
-->
$OpenBSD: faq6.html,v 1.125 2008/11/01 11:02:21 tobias Exp $
</small>

</body>
</html>

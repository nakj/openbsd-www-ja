<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>13 - Multimedia</title>

<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description" content= "the OpenBSD FAQ page">
<meta name= "keywords" content= "openbsd,faq">
<meta name= "distribution" content= "global">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>

<!--
Copyright (c) 2005, 2007 Steven Mestdagh <steven@openbsd.org>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../fr/index.html"><img
alt="[OpenBSD]" src="../../images/smalltitle.gif" border="0" height="30" width="141">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[Index de la FAQ]</a>
<a href= "faq12.html">[Section 12 - Questions Spécifiques Aux
Plates-Formes Et Au Matériel]</a>
<a href= "faq14.html">[Section 14 - Configuration des disques]</a>
</font>

<h1><font color="#e00000">13 - Multimedia</font></h1><hr>

<h3>Table des matières</h3>
<ul>
<li><a href="#confaudio">13.1 - Comment configurer mon périphérique audio ?</a>
<li><a href="#playaudio">13.2 - Jouer différents types de formats audio</a>
<li><a href="#playCD">13.3 - Comment jouer des CDs dans OpenBSD ?</a>
<li><a href="#recordaudio">13.4 - Puis-je utiliser OpenBSD pour enregistrer des séquences audio ?</a>
<li><a href="#audioserver">13.5 - Comment configurer un serveur audio ?</a>
<li><a href="#audioprob"  >13.6 - Que puis-je faire si j'ai des problèmes audio ?</a>
<li><a href="#midi"	  >13.7 - Comment puis-je utiliser mes instruments MIDI ?<a>
<li><a href="#lossyaudio">13.8 - Parlez moi de l'encodage Ogg Vorbis et MP3 ?</a>
<li><a href="#playDVD">13.9 - Comment lire des vidéos DVDs sous OpenBSD ?</a>
<li><a href="#burnCD">13.10 - Comment graver des CDs et DVDs ?</a>
<ul>
<li><a href="#burnIntro">13.10.1 - Introduction et configuration de base</a>
<li><a href="#writeCD">13.10.2 - Graver des CDs</a>
<li><a href="#writeDVD">13.10.3 - Graver des DVDs</a>
</ul>
<li><a href="#convert">13.11 - Je voudrais mes fichiers multimédia au format FOO.</a>
<li><a href="#streaming">13.12 - Est-il possible de lire des fichiers en streaming sous OpenBSD ?</a>
<li><a href="#javaplugin">13.13 - Puis-je utiliser un Java avec mon navigateur ? (spécifique à i386 &amp; amd64)</a>
<li><a href="#flashplugin">13.14 - Puis-je utiliser Flash avec mon navigateur ? (spécifique à i386)</a>
<!--
<li><a href="#camera"     >13.xx - Can I use my digital camera under OpenBSD?</a>
<li><a href="#scanner"    >13.yy - How do I set up and use my scanner?</a>
-->
</ul>
<hr>

<a name="confaudio"></a>
<h2>13.1 - Comment configurer mon périphérique audio ?</h2>

Les périphériques concernant l'audio sous OpenBSD sont :
<tt>/dev/audio</tt>, <tt>/dev/sound</tt>, <tt>/dev/audioctl</tt> et
<tt>/dev/mixer</tt>.
Pour une belle introduction à la couche de support audio, vous pouvez
lire la page de manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audio&amp;sektion=4">audio(4)</a>.

<p>
Tous les matériels audio supportés sont déjà inclus dans le noyau
GENERIC, il n'y a donc pas besoin de configuration supplémentaire ou
d'installation de drivers.
Pour trouver des informations spécifiques à la puce de votre carte son,
vous devrez déterminer quelle puce vous avez. Les puces supportées
peuvent être trouvées sur la page des matériels supportés pour votre
<a href="../../fr/plat.html">plate-forme</a>.
Si vous avez déjà OpenBSD lancé, cherchez l'apparition d'un driver de
carte son dans la sortie de la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>,
et lisez le manuel du driver pour des informations plus spécifiques
comme les options et autres détails sur celui-ci.
Voici un exemple d'une puce audio dans une sortie dmesg :

<blockquote><pre>auich0 at pci0 dev 31 function 5 "Intel 82801BA AC97" rev 0x04: irq 10, ICH2 AC97
ac97: codec id 0x41445360 (Analog Devices AD1885)
ac97: codec features headphone, Analog Devices Phat Stereo
audio0 at auich0
</pre></blockquote>

<p>
OpenBSD de base fournit deux outils pour superviser et configurer les
périphériques audio.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audioctl&amp;sektion=1">audioctl(1)</a>
est utilisé pour les paramétres de traitement audio, comme l'encodage, le taux
d'échantillonnage et le nombre de voix, tandis que
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mixerctl&amp;sektion=1">mixerctl(1)</a>
est utilisé pour les paramétres de mixage, comme la voix source, le niveau de
gain et la mise en sourdine.
 
<p>
La commande suivante utilise
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audioctl&amp;sektion=1">audioctl(1)</a>
pour afficher les paramétres audio par défaut d'un périphérique audio.

<blockquote><pre>
$ <strong>audioctl -f /dev/audio</strong>
...
</pre></blockquote>

Il faut remarquer que <tt>-f /dev/audio</tt> est utilisé explicitement.
Ouvrir <tt>/dev/audio</tt> fait que le périphérique audio fait un reset aux
paramétres par défaut, ce qui est ce que nous voulons voir.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audioctl&amp;sektion=1">audioctl(1)</a>
est aussi trés utile pour explorer les capacités d'un périphérique audio.
Par exemple, pour savoir si un périphérique supporte quelques taux 
d'échantillonnage standards, vous pouvez simplement essayer de changer
les taux de lecture :
 
<blockquote><pre>
$ <strong>audioctl play.rate=48000</strong>
play.rate: -> 48000
$ <strong>audioctl play.rate=44100</strong>
play.rate: -> 44100
$ <strong>audioctl play.rate=22050</strong>
audioctl: set failed: Invalid argument
$ <strong>audioctl play.rate=8000</strong>
audioctl: set failed: Invalid argument
$
</pre></blockquote>

Ce périphérique supprte des taux de playback de 48000 et 44100 Hz, mais pas
22050 ou 8000.
Il faut remarquer que si le taux d'échantillonnage n'est pas supporté, il
n'y a pas obligatoirement un message d'erreur, mais le taux 
d'échantillonnage renvoyé n'est pas celui désiré.

<blockquote><pre>
$ <strong>audioctl play.rate=48000</strong>
play.rate: -> 48000
$ <strong>audioctl play.rate=44100</strong>
play.rate: -> 48000
$ <strong>audioctl play.rate=22050</strong>
play.rate: -> 48000
$ <strong>audioctl play.rate=8000</strong>
play.rate: -> 48000
$
</pre></blockquote>

Ce périphérique supporte uniquement la lecture en 48000 Hz.

<p>
Un matériel audio est usuellement capable d'au moins quelques capacitées de
mixage minimale.
Exécuter
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mixerctl&amp;sektion=1">mixerctl(1)</a>
sans arguments affichera la liste des contrôles de mixage du périphérique et
ses paramétres actuels.
 
<blockquote><pre>
$ <strong>mixerctl</strong>
...
</pre></blockquote>

Certains périphériques possédent seulement quelques contrôles, alors que 
d'autres une centaine ou plus.
Il faut remarquer que toutes les options de chaque puce audio n'atteint pas
nécessairement le monde extérieur.
Il y a donc, par exemple, plus de sorties énumérées que celles qui sont 
physiquement disponible sur une carte son ou carte mère.

<p>
Il y a quelques contrôles qui sont communs à plusieurs périphériques :
<ul>
<li><tt>outputs.master</tt> contrôle le niveau de sortie de lecture
<li><tt>inputs.dac</tt> contrôle le niveau du DAC (convertisseur numérique
vers analogique), utilisé quand on joue un fichier audio
<li><tt>record.source</tt> contrôle les entrées qui sont mixées dans l'ADC
(convertisseur analogique vers numérique), utilisé lors d'enregistrements
<li><tt>record.volume</tt> ou <tt>record.record</tt> controle le niveau
d'entrée de l'ADC
</ul>

Le contrôle d'un périphérique audio peut-être affiché differemment.
Par exemple, il pourrait ne pas être <tt>outputs.master</tt> comme ci-dessus,
mais <tt>outputs.outputs</tt> qui fait la même chose.
Habituellement, les contrôles ont un label, mais parfois il faut simplement
essayer différents réglages pour voir l'effet que chacun a sur le contrôle.

<p>
Certains périphériques qui sont connus comme EAPD, qui signifie amplificateur
externe d'arrêt.
Cependant c'est juste un bouton marche/arrêt.
Il fait probablement référence à un "arrêt" car il est souvent utilisé comme
économiseur d'énergie, ce qui signifie que ce type de contrôle est plus
souvent trouvé sur les portables.
Quelquefois il est nécessaire de paramétrer les contrôles avec <tt>eapd</tt>
ou <tt>extamp</tt> dans leur nom avec <tt>on</tt> pour obtenir un
signal de sortie.

<p>
Comme exemple simple d'un usage courant de mixerctl, pour paramétrer le
volume des voix gauche et droite à 200, vous devrez

<blockquote><pre>
$ <strong>mixerctl outputs.master=200,200</strong>
outputs.master: 255,255 -&gt; 207,207
</pre></blockquote>

Remarquez que la valeur est devenue 207.
La raison à cela est que le périphérique de cette carte audio est un codec
AC'97, qui utilise seulement 5 bits pour le contrôle, ce qui ne laisse
que 32 valeurs possibles. D'autres matériels peuvent
avoir une résolution différente.

<p>
Pour activer le canal "master", vous devriez faire :

<blockquote><pre>
$ <strong>mixerctl outputs.master.mute=off</strong>
outputs.master.mute: on -&gt; off
</pre></blockquote>

<p>
Pour que vos changements soient effectifs à chaque redémarrage vous devrez 
éditer <i>/etc/mixerctl.conf</i>, par exemple :

<blockquote><pre>
$ <strong>cat /etc/mixerctl.conf</strong>
outputs.master=200,200
outputs.master.mute=off
outputs.headphones=160,160
outputs.headphones.mute=off
</pre></blockquote>

<a name="playaudio"></a>
<h2>13.2 - Jouer différents types de formats audio</h2>

<h3>Audio digitalisée</h3>

<h4>Formats audio sans perte (AU, PCM, WAV, FLAC, TTA)</h4>

Certains formats audio sans perte peuvent être joués sans qu'un logiciel
tierce partie ne soit nécessaire, ils contiennent les enregistrements
digitaux non compressés en flots d'octets.
Ces formats incluent les fichiers Sun audio (AU), les fichiers raw PCM
(sans en-têtes) et les RIFF WAV.

<p>
OpenBSD est fourni avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1">aucat(1)</a>,
un programme pour enregistrer et jouer de l'audio non compressé.
L'exemple suivant jouera un fichier WAV.

<blockquote><pre>
$ <strong>aucat -i filename.wav</strong>
</pre></blockquote>

<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1">aucat(1)</a>
supporte autant les écouteurs que les fichiers audio WAV avec l'option -i.
aucat joue aussi les fichiers audio Sun ou les données audio sont encodées
en 8 kHz monaural mulaw, qui est l'encodage le plus courant pour ce type de
fichier audio.

<p>
Il est aussi possible de jouer des données audio non compressées en les
envoyant directement sur le périphérique audio.
Pour jouer un tel fichier, vous devrez connaître ses paramètres
principaux : le type d'encodage, le nombre de canaux, la fréquence, et
le nombre de bit par morceau.
Si vous ignorez ces paramètres, vous pourrez les retrouver en utilisant
l'utilitaire :
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=file&amp;sektion=1">file(1)</a>.

<blockquote><pre>
$ <strong>file music.au</strong>
music.au:  Sun/NeXT audio data: 16-bit linear PCM, stereo, 44100 Hz
</pre></blockquote>

<blockquote><pre>
$ <strong>file music.wav</strong>
music.wav: Microsoft RIFF, WAVE audio data, 16 bit, stereo 44100 Hz
</pre></blockquote>

La seule chose qu'il vous reste à savoir sur ces fichiers d'exemple est
qu'ils sont encodés dans le format d'octet "little-endian" utilisant la
quantification linéaire signée.
Vous pouvez vérifier cela en lisant son en-tête avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hexdump&amp;sektion=1">hexdump(1)</a>.
Si vous utilisez un fichier sans en-tête (raw), il n'y a aucun moyen de
connaître les paramètres à l'avance.
Configurez les paramètres suivants en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=audioctl&amp;sektion=1">audioctl(1)</a>.

<blockquote><pre>
play.encoding=slinear_le
play.rate=44100
play.channels=2
play.precision=16
</pre></blockquote>

Ensuite, envoyez le fichier audio au périphérique son :

<blockquote><pre>
$ <strong>cat music.au &gt; /dev/sound</strong>
</pre></blockquote>

Si vous avez appliqué les bons paramètres, vous devriez entendre ce que
vous souhaitiez entendre.

<p>
Remarque : Utilisez toujours <tt>/dev/sound</tt>, et non
<tt>/dev/audio</tt>, si vous souhaitez que les paramètres appliqués
restent en place.

<p>
Il y a d'autres utilitaires que vous pouvez utiliser, comme
<tt>audio/waveplay</tt> dans les paquetages et les ports. Bien sur, des
logiciels populaires comme XMMS sont aussi capables de jouer ces
fichiers aussi bien que d'autres formats;

<p>
A l'inverse de ce qui a été dit précédemment, il existe des formats audio
sans perte de qualité.
Free Lossless Audio Codec (FLAC) et TTA en sont des exemples.
L'implémentation FLAC a été portée sous OpenBSD et peut être trouvée
dans <tt>audio/flac</tt> dans les paquetages et les ports.

<h4>Formats audio utilisant la compression par perte (Ogg Vorbis, MP3,
WMA, AAC)</h4>

La compression par perte de qualité est souvent utilisée pour l'audio ou
les autres fichiers multimédia. L'idée est qu'un certain volume de
données est supprimé pendant la compression, en utilisant une méthode
qui fait que le résultat compressé est toujours très exploitable et
dispose d'une bonne qualité pour être joué.
L'avantage de ces techniques est qu'ils autorisent de plus gros ratios
de compression, ce qui résulte en une plus faible place disque utilisée
et de plus besoins en bande passante.

<p>
Un bon exemple est le format libre, ouvert et non déposé
<a href="http://www.vorbis.com/">Ogg Vorbis</a>.
Pour jouer des fichiers Ogg Vorbis, vous pouvez utiliser l'utilitaire
ogg123, qui est inclus dans le paquetage <tt>audio/vorbis-tools</tt>.
Par exemple :

<blockquote><pre>
$ <strong>ogg123 music.ogg</strong>

Audio Device:   Sun audio driver output

Playing: music.ogg
Ogg Vorbis stream: 2 channel, 44100 Hz
Time: 00:02.95 [02:21.45] of 02:24.40  (133.1 kbps)  Output Buffer  87.5%
</pre></blockquote>

Bien sur, les plugins Ogg Vorbis existent pour beaucoup d'autres
logiciels audio.

<p>
Un autre exemple est le très populaire encodage MPEG-1 Audio Layer 3
(MP3), qui a, cependant, ses problèmes de redistribution et brevets.
Beaucoup de programmes peuvent jouer des fichiers MP3, consultez la
section <tt>audio</tt> du système de paquetages et de ports et choisissez
celui que vous souhaitez.

<p>
Que dire du format Windows Media Audio (WMA) ? Les fichiers de ce type
peuvent être lus en utilisant <tt>x11/mplayer</tt> qui se sert de
l'architecture <a href="http://ffmpeg.sourceforge.net">FFmpeg</a>.

<p>
Un bon point de départ pour en savoir plus sur les différents formats de
fichiers audio est de lire l'article Wikipedia suivant :
<a href="http://en.wikipedia.org/wiki/Audio_file_format">Audio file
formats (en anglais)</a>.

<h3>Son synthétisé</h3>

<h4>MIDI</h4>

Le protocole "Musical Intrument Digital Interface" (MIDI) est fourni
par <a href="#midi">MIDI devices</a>.
Si vous ne possédez pas de synthétiseur MIDI, mais que vous voulez jouer un
fichier MIDI standard (SMF), vous pouvez utiliser un logiciel de rendu de
données MIDI générant des fichiers audio.
Par défaut, le port <tt>audio/timidity</tt> utilise les fichiers MIDI et les
joue sur le périphérique audio :

<blockquote><pre>
$ <strong>timidity file.mid</strong>
</pre></blockquote>

<h4>MOD</h4>

Un module "Soundtracker" est un format binaire qui mixe les plages
audio avec des ordres de séquences, autorisant à jouer de très grands
morceaux de musique digitalisée avec un qualité raisonnablement bonne.

<p>
Le moyen le plus simple de jouer vos fichiers MOD favoris sur OpenBSD
est probablement d'utiliser le logiciel XMMS, disponible via les
paquetages et les ports.
Vous devriez installer le sous-paquetage <tt>-mikmod</tt> pour XMMS afin
de lui permettre d'utiliser la bibliothèque sonore MikMod, qui supporte les
modules de formats MOD, S3M, IT et XM.

<p>
Vous trouverez aussi liste de "trackers" dans la section <tt>audio</tt>
de la collection de ports et de paquetages, comme par exemple tracker,
soundtracker.
Avec ces trackers, vous ne pouvez pas seulement jouer mais aussi générer
vos propres modules.
Remarquez que tous les trackers ne sont pas supportés par les outils de
l'arbre des ports.
Vous êtes invités à <a href="../ports/index.html">envoyer un port</a>
de votre programme de tracker favori.

<a name="playCD"></a>
<h2>13.3 - Comment jouer des CDs dans OpenBSD ?</h2>

Il est possible de jouer un CD audio aussi bien en ayant le lecteur de
CD jouant le disque et envoyant les données audio analogique à la carte
sonore qu'en lisant les données audio en envoyant les échantillons
numériques à la carte sonore à travers le bus PCI.

<p>
Pour jouer un CD audio, en utilisant la sortie analogique de votre
lecteur CD-ROM, vous pouvez
<ul>
<li>Utiliser la sortie casque audio, souvent présente sur la face avant
    de votre lecteur de cdrom.
<li>Connecter la sortie audio sur le connecteur noir de votre carte
    audio. Oui, il s'agit d'un câble supplémentaire près de celui des
    données (SCSI/IDE) et de celui de l'alimentation.
</ul>

<p>
Un utilitaire pratique en ligne de commande appelé
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1">cdio(1)</a>
a été inclut dans le système de base. Appelé sans paramètres, il entrera
en mode interactif. Si vous souhaitez jouer un CD-ROM, entrez :

<blockquote><pre>
$ <strong>cdio play</strong>
</pre></blockquote>

<p>
Cela lira depuis le premier lecteur CD-ROM, <tt>cd0</tt>, par défaut.
Notez que l'utilisateur qui lance cdio doit bénéficier des permissions
de lecture sur le périphérique CD-ROM (ex. <tt>/dev/rcd0c</tt>).
Etant donné que par défaut ce périphérique n'est accessible en lecture
que par root et le groupe "operator", pour plus de facilité vous pouvez
ajouter l'utilisateur au groupe operator en éditant la ligne
correspondante dans <tt>/etc/group</tt>.
Une autre solution est de modifier les permissions du périphérique comme
vous le souhaitez.

<p>
Vous aurez peut-être besoin d'activer l'entrée CD au niveau du mixeur de
sons. Au même titre que les sorties, le nom réel de ce canal d'entrée
varie selon les systèmes. Mais la commande à utiliser ressemble à la
commande suivante :

<blockquote><pre>
$ <strong>mixerctl inputs.cd.mute=off</strong>
</pre></blockquote>

Il est aussi possible qu'il n'y est pas de connexion audio analogique entre
votre lecteur CD et le périphérique audio.
Dans ce cas vous pouvez utiliser les commandes <tt>cdplay</tt> de <tt>cdio</tt>
pour envoyer les données audio du CD vers la carte sonore à travers le bus PCI.

<blockquote><pre>
$ <strong>cdio cdplay</strong>
</pre></blockquote>

<p>

Si vous préférez une belle GUI, il y a beaucoup de lecteurs de CDs
basés sur X11 dans la collection de paquetages et de ports. Consultez
simplement la section <tt>audio</tt>.

<a name="recordaudio"></a>
<h2>13.4 - Puis-je utiliser OpenBSD pour enregistrer des séquences audio ?</h2>

Oui.
La plupart des périphériques supportent l'enregistrement.
 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1">aucat(1)</a>
est distribué avec OpenBSD et peut-être utilisé pour l'enregistrement.

<blockquote><pre>
$ <strong>aucat -o file.wav</strong>
</pre></blockquote>

La commande précédente commencera l'enregistrement d'un fichier au format WAV.
Appuyez sur [CTRL]-C pour terminer l'enregistrement.
Le fichier contiendra des échantillons signés 16-bit stéréo, échantillonné à
44.1 kHz.
D'autres formats d'échantillonnage, taux d'échantillonnage et nombre de voix
peuvent être enregistré.
Lisez le manuel pour plus de détail.

<p>
Utilisez aucat pour rejouer le fichier :
 
<blockquote><pre>
$ <strong>aucat -i file.wav</strong>
</pre></blockquote>

<p>
Si l'enregistrement semble fonctionner mais que la sortie de l'enregistrement
est muette ou n'est pas ce que vous souhaitez, le mixer a surement besoin
d'être configuré.
Soyez sur que vous sélectionnez le bon périphérique pour enregistrer et 
que la source n'est pas muette.
Vous pouvez configurer les paramètres nécessaires en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mixerctl&amp;sektion=1">mixerctl(1)</a>.
Par exemple :

<blockquote><pre>
inputs.mic.mute=off
inputs.mic.preamp=on
inputs.mic.source=mic0
record.source=mic
record.volume=255,255
record.volume.mute=off
record.mic=255
record.mic.mute=off
</pre></blockquote>

Il y a des paramétres pour l'enregistrement avec un microphone.
La pré-amplification a été activée, car sinon le son enregistré peut
être quelque peu silencieux sur certains systèmes.

<a name="audioserver"></a>
<h2>13.5 - Comment configurer un serveur audio ?</h2>

<!-- This section Copyright (c) 2009 Alexandre Ratchov -->

<h3>Est-ce que j'ai besoin d'un serveur audio ?</h3>

L'utilitaire 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1">aucat(1)</a>
peut-être utilisé comme serveur audio,
qui agit comme une couche entre le pilote audio(4)
et l'application audio.
Cela vise à :

<ul>

<li>
Dépasser les incompatibilités entre le matériel et les applications.
Par exemple une application ne supporte pas l'encodage et les taux
d'échantillonnage du matériel; si c'est le cas, le cas peut faire les
conversions nécessaires à la volée. 

<li>
Permettre à plusieurs applications d'utiliser le matériel simultanement.
Par exemple, pour utiliser un lecteur de musique en tache de fond pendant
que l'on éxecute une application jouant des sons, ou pour
utiliser simultanement les hauts-parleurs frontaux pour la musique et la
prise casque pour la téléphonie est un autre exemple.

</ul>

Si les applications utilisées sont compatibles avec votre matériel et que
vous ne pensez pas utiliser plusieurs applications simultanement, vous
n'avez donc pas besoin d'un serveur audio.

<h3>Comment configurer aucat(1)</h3>

Il n'y a pas de fichier de configuration, et dans la plupart des cas, rien à
faire. Tapez :

<pre>
$ <strong>aucat -l</strong>
</pre>

démarrera le serveur sur le périphérique audio par défaut (celui ou pointe
le lien symbolique sur <tt>/dev/audio</tt>) fonctionnant à 44.1KHz et
utilisant deux voix (stéréo).
Cela signifie que les applications utilisant la stéréo à 44.1KHz
fonctionneront de maniére optimale, c'est à dire, sans passer par du code de
conversion.
Si le périphérique ne supporte pas ces paramétres,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1">aucat(1)</a>
utilisera automatiquement un autre ensemble de paramétres.

<p>
Si vous avez les priviléges nécessaires, vous pouvez augmenter sa priorité,
pour diminuer la probabilité d'un probléme de cache, par exemple :

<pre>
$ <strong>sudo renice -n -20 `pgrep -x aucat`</strong>
</pre>

Remarquez de aucat(1) démarre en mode full-duplex par défaut, ce qui
nécessite que votre matériel supporte le mode full-duplex.
Si cela n'est pas le cas, vous devez démarrer aucat(1) en mode lecture seule
ou enregistrement seul, par exemple :

<pre>
$ <strong>aucat -l -m play</strong>
</pre>

<h3>Comment démarrer aucat(1) au démarrage du système ?</h3>

Si vous êtes le seul utilisateur local de la machine, vous pouvez démarrer 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1">aucat(1)</a>
au démarrage du système via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8">rc.local(8)</a>,
par exemple :

<pre>
<strong>nice -n -20 su -m mylogin -c "aucat -l"</strong>
</pre>

Le processus aucat(1) ne peut pas être partagé entre plusieurs utilisateurs.

<h3>Quel temps de latence configurer ?</h3>

Le temps de latence est le temps entre la décision pour un programme de
jouer un échantillon et le moment ou l'utilisateur entend l'échantillon.
Comme les données audio sont toujours en cache, ce délai est proportionnel à
la taille du cache audio.
Les valeurs suivantes sont recommandées :

<ul>

<li>
Synthétiser temps-réel : 5ms.
C'est le temps qui est pris entre l'appuie d'une touche sur le clavier MIDI
et entendre la note.
Grossièrement, 5ms correspond au temps que mets le son pour se propager sur
1,75m.

<li>
Jeux : 50ms.
C'est le temps qui correspond au moment ou vous voyez l'événement et
entendez le son correspondant.

<li>
Lecteurs de films et assimilés : 500ms et plus.
Ces applications sont "connues" pour jouer le son en avance, et envoyer les
données audio de tel façon quelles sont jouées simultanement avec l'image
correspondante.

</ul>

Plus le cache audio est petit (pour avoir un temps de latence faible), plus
les probabilités sont grandes d'avoir des problèmes de overrun/underrun.
Le cache en overruns/underruns donnera au son un "bégaiement".

<p>
En mode serveur, aucat(1) impose un temps minimum de latence pour toutes les
applications audio, et le temps de latence par défaut est autour de 250ms.

Si vous prévoyez d'utiliser des applications qui demandent une latence plus
courte, utilisez l'option "-b" pour sélectionner la latence désirée
(exprimée en nombre d'échantillons).

Par exemple à 44100 échantillons/seconde, 50ms de latence correspond à :

<blockquote>
44100 échantillons/seconde x 0.050 secondes = 2205 échantillons
</blockquote>
 
donc lancez 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=aucat&amp;sektion=1">aucat(1)</a>
ainsi :

<pre>
$ <strong>aucat -b 2205 -l</strong>
</pre>

<h3>Une latence plus faible améliore-t-elle la synchronisation audio-vidéo ?</h3>

Synchronisez l'audio à la vidéo ne nécessite pas une latence faible.
Les problèmes de synchronisation sont souvent causés par le logiciel
lui-même (mauvaise implémentation, bogues, &nbsp;...).
Forcer l'application à utiliser des cache plus petits (en démarrant aucat(1)
en mode latence faible) peut cacher les problémes actuels dans certains cas
et donner la sensation que le logiciel fonctionne mieux, mais normalement la
bonne chose à faire et de commencer à chercher le bogue correspondant.


<h2>13.6 - Que puis-je faire si j'ai des problémes audios ?</h2>
Si vous n'entendez rien  quand vous jouez de l'audio, il est possible
que le contrôle du mixage soit trop faible ou simplement muet.
Voir la section
<a href="#confaudio">13.1 - Comment puis-je configurer mon périphérique audio</a>
pour configurer le mixage.
Merci de rendre non muet <b>toutes</b> les entrées et sorties avant de 
reporter un probléme.
 
<p>
Si le son est distordu, il est possible que votre carte audio ne supporte
qu'un unique ou nombre limité de taux d'échantillonnage ou d'encodages.
Voir la section
<a href="#confaudio">13.1 - Comment configurer mon périphérique audio ?</a>
par exemple pour déterminer quels paramétres audio votre périphérique supporte.

<p>
Si votre périphérique ne supporte seulement que des encodages peu courants
ou qu'un ou peu de taux d'échantillonnage, et l'application que vous
utilisez ne peut pas faire les conversions audio nécessaires, considérez
aucat(1) comme serveur audio.
Voir le paragraphe 
<a href="#audioserver">13.5 - Comment configurer un serveur audio ?</a>

<p>
Si vous avez toujours des problémes, voici quelques choses à considérer :
<ul>
<li>
Quelques vieilles cartes ISA ont des astuces particuliéres :
  <ul>
  <li>Certaines ont besoin d'être configurées avec des adresses I/O et IRQ
  différentes pour éviter les conflits avec d'autres matériels.
  Vous pouvez essayer facilement différentes combinaisons en utilisant le
  <a href="faq5.html#BootConfig">User Kernel Configuration (UKC)</a>.
  <li>Il est possible qu'un pilote moins optimal soit attaché au périphérique
  audio et que vous ayez de meilleurs résultats avec un autre pilote.
  Ce n'est pas la chose la plus simple à observer, mais regardez attentivement
  votre sortie
  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
  et trouvez les lignes ou votre pilote audio est attaché.
  Si vous voyez plus d'un pilote sonore attaché (ou essayant), essayez les un 
  à un en les désactivant via
  <a href="faq5.html#BootConfig">User Kernel Configuration (UKC)</a>.
  </ul>
<li>
Trouvez des informations sur votre périphérique sonore.
Utilisez la documentation ou utilisez les moteurs de recherche sur Internet 
pour trouvez ses spécifications.
Pour les périphériques
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ac97&amp;sektion=4">ac97(4)</a>
et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=azalia&amp;sektion=4">azalia(4)</a>
regardez la documentation pour le contrôleur et le codec.
Cela vous permettra de trouver la source du probléme.
</ul>

<p>
Si vous croyez que votre périphérique doit fonctionner, mais que pour une 
raison inconnue ce n'est pas le cas, il est temps de deboguer.
Les étapes suivantes peuvent déterminer si les données sont traitées par le 
DAC.

<blockquote><pre>
$ <strong>cat > /dev/audio < /dev/zero &</strong>
[1] 9926
$ <strong>audioctl play.{seek,samples,errors}</strong>
play.seek=48000
play.samples=3312000
play.errors=0
$ <strong>audioctl play.{seek,samples,errors}</strong>
play.seek=57600
play.samples=7065600
play.errors=0
$ <strong>audioctl play.{seek,samples,errors}</strong>
play.seek=48000
play.samples=9379200
play.errors=0
$ <strong>kill %1</strong>
$ <strong>fg %1</strong>
cat > /dev/audio < /dev/zero
Terminated
</pre></blockquote>

Ici nous observons que le compteur des données traitées <tt>play.samples</tt>
augmente chaque fois lors de la vérification, donc les données passent.
Nous observons aussi que le périphérique récupére assez de données dans le
tampon <tt>play.seek</tt> et que le périphérique n'a pas de problémes
via <tt>play.errors</tt>.
C'est une bonne chose.

<p>
I faut remarquer que même si vous avez des enceintes connectées quand vous
faites vos tests, vous n'entendrez rien.
Le test envoie des zéros au périphérique qui devient silencieux pour tous
les encodages par défaut supportés.

<p>
Depuis que nous savons que le périphérique peut traiter des données, c'est
un bonne idée de vérifier encore les paramétres de mixage.
Soyez sur que toutes les sorties et entrées ne sont pas muettes et à un niveau
raisonnable.

<p>
Si à ce moment vous continuez d'avoir des problémes, il est probablement temps
<a href="http://www.openbsd.org/report.html">d'envoyer un fichier de rapport de bogue</a>.
En plus du rapport d'information de bogue comme un dmesg complet et
une description du probléme, merci d'inclure aussi le sortie par défaut de
<tt>mixerctl -v</tt> et les sorties des tests précedents du traitement DAC.

<a name="midi"></a>
<h2>13.7 - Comment puis-je utiliser mes instruments MIDI ?</h2>

Le protocole "Musical Intrument Digital Interface" (MIDI) fournit un
façon standardisée et efficace de représenter les informations musicales
comme données électroniqies. 
Une donnée MIDI contient uniquement les informations nécessaires au 
synthétiseur pour jouer les sons, au lieu des sons eux-mêmes.
Plus d'informations :
<a href="http://www.harmony-central.com/MIDI/Doc/tutorial.html">Tutorial
on MIDI and Music Synthesis</a>.

<!-- <h3>Devices setup</h3> -->

<p>
Pour jouer des données MIDI, un synthétiseur connecté au port MIDI de la
machine est indispensable. De façon similaire, pour enregistrer des données
MIDI, un instrument MIDI est indispensable (comme un clavier MIDI).
Certaines cartes sonores embarquent des synthétiseurs MIDI qui sont attachés
au ports MIDI.
Les instruments MIDI évolués peuvent contenir plusieurs éléments 
(synthétiseurs, claviers, contrôle de la surface, etc...), ils apparaissent
comme plusieurs ports MIDI sous OpenBSD.

<p>
Quand OpenBSD est déjà fonctionnel, regardez les ports MIDI dans la sortie de
la commande dmesg(8).
Un exemple de ports MIDI dans une sortie dmesg :

<blockquote><pre>
midi0 at pcppi0: &lt;PC speaker&gt;
umidi0 at uhub2 port 2 configuration 1 interface 0 "Roland Roland XV-2020" rev 1.10/1.00 addr 2
midi1 at umidi0: &lt;USB MIDI I/F&gt;
umidi1 at uhub1 port 2 configuration 1 interface 1 "Evolution Electronics Ltd. USB Keystation 61es" rev 1.00/1.25 addr 3
midi2 at umidi1: &lt;USB MIDI I/F&gt;
</pre></blockquote>

Il montre trois ports MIDI correspondants à :
 
<ul>
<li> <tt>/dev/rmidi0</tt> - le haut parleur du PC
<li> <tt>/dev/rmidi1</tt> - synthétiseur connecté par USB
<li> <tt>/dev/rmidi2</tt> - un clavier MIDI maitre
</ul>

Pour tester votre clavier MIDI vous pouvez utiliser l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hexdump&amp;sektion=1">hexdump(1)</a>
qui affiche les données MIDI que vous jouez dessus :

<blockquote><pre>
$ <strong>hexdump -e '1/1 "%02x\n"' &lt;/dev/rmidi2 </strong>
90
3c
71
...
</pre></blockquote>

La sortie du clavier peut être connectée à l'entrée du synthétiseur comme :

<blockquote><pre>
$ <strong>cat -u /dev/rmidi1 &gt;/dev/rmidi2</strong>
</pre></blockquote>

Maintenant vous pouvez entendre sur le synthétiseur ce que vous jouez sur le
clavier MIDI.
Les informations que vous jouez sont capturées de /dev/rmidi1 et envoyées
sur /dev/rmidi2 en temps réel.
Referez vous aux pages du manuel 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=midi&amp;sektion=4">midi(4)</a>
pour plus d'informations.

<!-- <h3>Playing, recording MIDI sequences</h3> -->

<p>
L'utilitaire principal pour jouer des fichiers MIDI est
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=midiplay&amp;sektion=1">midiplay(1)</a>.
Jouer un fichier MIDI standard, dans cet exemple à travers le synthétiseur,
est aussi simple que :
 
<blockquote><pre>
$ <strong>midiplay -d 1 file.mid</strong>
</pre></blockquote>

Il faut remarquer que nous spécifions le numéro de périphérique MID à 1 
(<tt>/dev/rmidi1</tt>) comme paramétre à cause du numéro de périphérique 0
qui est utilisé par défaut.

<p>
Pour enregistrer des fichiers MIDI, vous pouvez utiliser l'utilitaire
<tt>smfrec</tt> fournit dans le port <tt>audio/midish</tt>, ainsi :

<blockquote><pre>
$ <strong>smfrec -d /dev/rmidi1 -i /dev/rmidi2 file.mid</strong>
</pre></blockquote>

enregistrera ce qui est joué au clavier (<tt>/dev/rmidi2</tt>) pendant
qu'il enverra en temps réel sur le synthétiseur (<tt>/dev/rmidi1</tt>) ce que
vous pourrez entendre en jouant.
Une opération plus compliquée comme l'édition, routage, mixage et la 
transformation de données MIDI peut être réalisée en utilisant l'utilitaire
<tt>rmidish</tt> disponible dans le port <tt>audio/midish</tt>.

<a name="lossyaudio"></a>
<h2>13.8 - Parlez moi de l'encodage Ogg Vorbis et MP3 ?</h2>

Ces formats ont déjà été mentionnés dans
<a href="#playaudio">Jouer différents formats audio</a>.
Dans cette section nous donnerons une brève introduction à l'encodage de
tels fichiers. Si vous êtes intéressé par le fonctionnement de ces
codecs de compression audio, de plus amples informations peuvent être
trouvées dans les articles Wikipedia concernant
<a href="http://en.wikipedia.org/wiki/Vorbis">Vorbis</a> et
<a href="http://en.wikipedia.org/wiki/MP3">MP3</a>.

<h3>Ogg Vorbis</h3>

L'encodage de formats audio raw, WAV ou AIFF en
<a href="http://www.vorbis.com/">Ogg Vorbis</a> peut être réalisé via
l'utilitaire <b>oggenc</b>, faisant partie du paquetage
<tt>audio/vorbis-tools</tt>, qui est disponible via le système de ports
et de paquetages d'OpenBSD.

<p>
Disons que vous avez un certain nombre de fichier WAV à encoder, par
exemple votre album favori que vous venez juste d'extraire de son CD.
Pour encoder tous ces fichiers en utilisant une fréquence d'environ 192
kbps, vous pouvez utiliser une commande comme celle ci :
<blockquote><pre>
$ <strong>oggenc *.wav -b 192</strong>
</pre></blockquote>

Une fois terminé, cela vous fournira un ensemble de fichiers .ogg dans
le dossier courant. Des exemples plus précis ainsi que les options
d'encodage peuvent être trouvés dans le manuel oggenc.

<h3>MPEG-1 Audio Layer 3 (MP3)</h3>

Si pour quelque raison que ce soit, vous souhaitez utiliser le format
MP3, vous pouvez utiliser
<a href="http://lame.sourceforge.net/">"Lame ain't an MP3 encoder" (LAME)</a>,
un outil d'éducation utilisé pour apprendre l'encodage MP3. Lame est
inclut dans l'arbre des sources OpenBSD.
Notez que pour des raisons de brevets MP3, vous ne trouverez pas ce
paquetage dans le
<a href="../../orders.html">Set de CDs officiels</a>.

<p>
Ci-dessous ce trouve un exemple simple d'encodage d'un fichier WAV avec
une fréquence de 192 kbps :
<blockquote><pre>
$ <strong>lame -b 192 track01.wav track01.mp3</strong>
</pre></blockquote>

Pour toutes les options et les détails, merci de consulter le manuel
fournit avec lame.


<a name="playDVD"></a>
<h2>13.9 - Comment lire des vidéos DVDs sous OpenBSD ?</h2>

Pour l'instant, OpenBSD supporte les médias DVD à travers le système de
fichiers ISO 9660 qui est aussi utilisé pour les CD-ROMs et, depuis la
version 3.8, également à travers le système de fichiers plus récent,
<a href="http://www.osta.org/specs/">Universal Disk Format (UDF)</a>,
présent sur certains DVDs.
Cependant, presque tous les disques DVD-Video et DVD-ROM utilisent le
format passerelle UDF, qui est une combinaison des systèmes de fichiers
DVD MicroUDF (sous-ensemble de UDF 1.02) et ISO 9660. Ce format est
utilisé afin de garantir la compatibilité ascendante.

<p>
Puisque la plupart des ordinateurs disposant d'un lecteur DVD-ROM
utilisent un décodage logiciel, il est recommandé d'avoir au moins un
processeur Pentium II 350-MHz ou équivalent pour disposer d'une bonne
qualité d'écoute.

<p>
Quelques utilitaires de lecture DVD populaires ont été portés sur OpenBSD.
Comme par exemple <a href="http://www.dtek.chalmers.se/groups/dvd/">ogle</a>
,<a href="http://www.mplayerhq.hu/">mplayer</a>,
<a href="http://www.xine-project.org/">xine</a> et
<a href="http://kaffeine.sourceforge.net/">kaffeine</a>.
Veuillez lire les instructions d'installation livrées avec ces
paquetages, car ces fichiers peuvent nécessiter plus de configuration.
Avec ces utilitaires il est possible de lire des DVD directement en
accédant au périphérique raw.
Bien sur, il est possible de monter d'abord le DVD en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_cd9660&amp;sektion=8">mount_cd9660(8)</a>,
et de jouer les fichiers sur ce système de fichiers ou un autre.

<p>
<b>Remarque :</b>
<ul>
<li>Quasiment tous les DVDs que vous achetez sont encryptés en utilisant
le "Content Scrambling System (CSS)". Pour pouvoir jouer ces DVDs
encryptés, vous pouvez utiliser la bibliothèque
<b>libdvd</b> disponible via les paquetages et les ports.
<li>Soyez averti qu'un code région doit être présent sur votre disque
DVD. Cela ne devrait pas réellement être un problème lorsque les
DVDs sont joués sur un ordinateur.
</ul>


<a name="burnCD"></a>
<h2>13.10 - Comment graver des CDs et DVDs ?</h2>

<a name="burnIntro"></a>
<h3>13.10.1 - Introduction et configuration de base</h3>

Vous devriez tout d'abord être sur que votre graveur CD/DVD a bien été
reconnu et configuré par le noyau.
La plupart des périphériques SCSI sont reconnus. Les matériels IDE/ATAPI
et USB sont supportés au travers de l'émulation SCSI. Vous trouverez
rapidement votre périphérique dans la sortie d'un
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>.
Cherchez simplement les lignes commençant par "cd", par exemple :

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;TOSHIBA, CD-ROM XM-5702B, 2826&gt; SCSI0 5/cdrom removable
cd1 at scsibus1 targ 4 lun 0: &lt;PLEXTOR, CD-R PX-R412C, 1.04&gt; SCSI2 5/cdrom removable
</pre></blockquote>

<h4>Mais <tt>cdrecord -scanbus</tt> ne fonctionne pas!</h4>

Oui. OpenBSD utilise un espace de nommage de périphérique différent de
celui du système d'exploitation pour lequel cdrecord a été écrit.
Tous les périphériques doivent être dans la sortie dmesg, comme
mentionné ci-dessus. L'information dont vous avez besoin se trouve ici.

<h4>Error: <tt>mount_cd9660: /dev/cd2c on /mnt/cdrom: No such file or directory</tt></h4>

Par défaut, l'installeur OpenBSD ne crée que deux périphériques cd
<tt>cd0</tt> et <tt>cd1</tt>.
Pour commencer à utiliser votre périphérique <tt>cd2</tt>, vous devez
créer le périphérique nécessaire pour celui-ci.
La méthode recommandée pour cela est d'utiliser le script
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=MAKEDEV&amp;sektion=8">MAKEDEV(8)</a>
(Sélectionnez votre plate-forme) :

<blockquote><pre>
# <strong>cd /dev</strong>
# <strong>./MAKEDEV cd2</strong>
</pre></blockquote>

Dans ce qui suit, nous accèderons principalement au graveur de CD/DVD à
travers le périphérique <i>raw</i> et <b>non</b> le périphérique
<i>block</i>.

<h4>Vérifier le fonctionnement du graveur de CD/DVD</h4>

Il est recommandé de vérifier que votre graveur de CD/DVD fonctionne
correctement. Dans cet exemple, j'utilise un graveur DVD USB 2.0 :

<blockquote><pre>
cd2 at scsibus2 targ 1 lun 0: &lt;LITE-ON, DVDRW LDW-851S, GS0C&gt; SCSI0 5/cdrom removable
</pre></blockquote>

Essayez de l'utiliser en y montant un CD/DVD.
Si vous le souhaitez, vous pouvez aussi vérifier les taux de transfert
que vous obtenez en copiant des fichiers sur votre disque dur.
La commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=time&amp;sektion=1">time(1)</a>
sera votre meilleure amie.

<p>
Si quelque chose se passe mal ici et que vous obtenez des erreurs durant
cette phase, il est important de les corriger avant de commencer à
écrire un CD/DVD.

<h4>Je souhaite maintenant graver un CD ! Pouvons nous commencer ?</h4>

Auparavant, il est judicieux de garder quelques conseils en tête :

<ul>
<li>Ne lancez pas de tâches utilisant lourdement le disque pendant que
    vous écrivez un CD/DVD. Cela réduira la vitesse d'écriture vers
    votre graveur CD/DVD. Si la vitesse descend plus bas que ce que le
    graveur attend pendant un temps trop long, son buffer sera vide. Ce
    phénomène est aussi connu sous le nom de "buffer underrun".
<li>Evitez les chocs pendant la gravure, cela pourrait faire glisser le
    laser de sa piste, et pourra conduire à des erreurs sur le disque.
<li>Tous les graveurs de DVD ne supportent pas tous les formats DVD,
    voyez ci-dessous.
</ul>

<a name="writeCD"></a>
<h3>13.10.2 - Graver des CDs</h3>

<h4>Créer des CD-ROMs de données</h4>

Tout d'abord, vous devrez créer un système de fichier ISO 9660 à mettre
sur un CD-ROM.
Pour cela vous pouvez utiliser l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mkhybrid&amp;sektion=8">mkhybrid(8)</a>
fournit dans le système de base ou mkisofs du
<a href="faq15.html#PkgMgmt">paquetage</a> cdrtools qui est plus
performant avec des arborescences importantes. Dans l'exemple suivant, nous
utiliserons mkhybrid bien que l'utilisation de mkisofs soit similaire.

<p>
Comme exemple d'utilisation, j'ai essayé de sauvegarder les sources
d'OpenBSD dans une image ISO 9660 :

<blockquote><pre>
$ <strong>mkhybrid -R -o sys.iso /usr/src/sys</strong>

Using ALTQ_RMC.000;1 for  /usr/src/sys/altq/altq_rmclass_debug.h (altq_rmclass.h)
...
Using IEEE8021.00H;1 for  /usr/src/sys/net80211/ieee80211_amrr.c (ieee80211.c)
 10.89% done, estimate finish Sat Nov  3 08:01:23 2007
 21.78% done, estimate finish Sat Nov  3 08:01:28 2007
...
 87.12% done, estimate finish Sat Nov  3 08:01:31 2007
 98.01% done, estimate finish Sat Nov  3 08:01:32 2007
Total rockridge attributes bytes: 896209
Total directory bytes: 2586624
Path table size(bytes): 11886
Max brk space used 0
45919 extents written (89 Mb)
</pre></blockquote>

<p>
L'option <tt>-R</tt> demande à <tt>mkhybrid</tt> de rajouter des
extensions Rock Ridge dans l'image ISO 9660.
Le "Rock Ridge Interchange Protocol" a été crée pour supporter le
système de fichiers POSIX à l'intérieur du système de fichiers ISO 9660,
comme les longs nom de fichiers, les créateurs de fichiers, les
permissions, les liens de fichiers, les fichiers de périphériques, les
hiérarchies de fichiers profondes (plus de 8 niveaux de sous-dossiers),
etc...

<p>
Si vous souhaitez que les longs noms de fichiers sur votre CD-ROM soient
lisibles sur les systèmes Windows et DOS, vous devriez ajouter le
paramètre <tt>-J</tt> pour inclure les extensions Joliet dans l'image
ISO 9660.

<p>
Après avoir crée les systèmes de fichiers, vous pouvez le vérifier en
<a href="faq14.html#MountImage">montant l'image ISO 9660</a>.
Si tout se passe bien, vous êtes maintenant prêt à écrire le CD-R(W).
La façon la plus aisée pour faire cela consiste à employer l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1">cdio(1)</a>.

<p>
Si vous utilisez des média réinscriptibles tels que des CD-RW, vous
devez tout d'abord procéder à un effacement avant de pouvoir faire une
réécriture.
 
<blockquote><pre>
# <strong>cdio -f cd1c blank</strong>
</pre></blockquote>

Vous êtes maintenant prêt à graver l'image créée dans l'exemple
précédant sur un CD-R(W) vierge. Vous pourrez utiliser une commande
similaire à :

<blockquote><pre>
# <strong>cdio -f cd1c tao sys.iso</strong>#
</pre></blockquote>

En utilisant les options spécifiées ci-dessus, nous demandons à cdio
d'utiliser le second périphérique CD-ROM comme graveur de CD.

<p>
Pour vérifier que le CD-ROM a bien été écrit, vous pouvez le monter et
vérifier que tout ce qui doit y être y est. Pour monter le système de
fichier, vous devez utiliser le périphérique <i>block</i> pour le
lecteur de CD-ROM, qui dans ce cas est toujours le graveur de CD :

<blockquote><pre>
# <strong>mount /dev/cd1c /mnt/cdrom</strong>
</pre></blockquote>


<h4>Créer des CDs audio</h4>

Pour graver des CDs audio, vous pouvez encore une fois utiliser
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1">cdio(1)</a>
avec l'option <tt>tao -a</tt>.

<p>
Comme exemple, je ferais une copie de sauvegarde d'un de mes CDs de
musique.
Cela implique deux étapes :

<ol>
<li>Copier les pistes audio depuis votre CD original
Par exemple :
<blockquote><pre>
# <strong>cdio -f cd1c cdrip</strong>
</pre></blockquote>
Cette commande va extraire une série de fichiers WAV de votre second
lecteur CD-ROM et les écrire sur votre disques.
<li>Graver les pistes sur un CD vierge
Par exemple :
<blockquote><pre>
# <strong>cdio -f cd1c tao -a *.wav</strong>
</pre></blockquote>
</ol>


<a name="writeDVD"></a>
<h3>13.10.3 - Graver des DVDs</h3>

Il y a quelques détails importants à propos des DVDs que vous devriez
savoir avant de créer vos propres DVDs.

<p>
<b>Remarques importantes :</b>
<ul>
<li>Si vous souhaitez vraiment tout savoir sur les DVDs, je vous suggère
    de lire la très complète
    <a href="http://www.dvddemystified.com/dvdfaq.html">FAQ DVD</a>.

<li>Cette section a été très peu testée et nous n'avons probablement pas
testé toutes les combinaisons de médias et de graveurs possibles.
Cependant nous avons eu où reçu des retours d'expériences positifs avec
les formats de DVD suivants. Vous êtes invités à
<a href="mailto:faq@openbsd.org">nous informer</a> de vos succès ou
échecs.
</ul>

<h4>Différents formats de DVD</h4>

Il y a plusieurs formats différents de DVD. Les plus utilisés sont
les formats DVD-R, DVD-RW, DVD+R et DVD-RW (R signifie enregistrable une
seule fois, RW signifie qu'il peut être réécrit quelques milliers de
fois). Il existe d'autres standards plus compétitifs.

<p>
Un format différent est le DVD-RAM, qui a principalement été développé
comme un lecteur de données et dispose de fonctions d'écriture de
paquets avancées, autorisant à l'utiliser comme une sorte de disque dur
optique. DVD-RAM n'est pas recommandé pour une utilisation vidéo car les
vidéos sont écrites sur le disque dans un format non compatible avec les
lecteurs de DVD normaux.

<p>
Le point le plus important est d'utiliser le média adapté à votre
graveur de DVD.
Si vous souhaitez la compatibilité avec d'autres lecteurs de DVD,
veuillez lire
<a href="http://www.dvddemystified.com/dvdfaq.html#4.3.1">cette section</a>
de la FAQ DVD.

<h4>Vitesse de gravure DVD</h4>

Il est important de spécifier que les indications de vitesses des DVDs
diffèrent de celles des CD-ROMs. La table suivante en donne un aperçu :

<p>
<table border="1" style="empty-cells: show;">
<tr align="center">
<td>Vitesse de Lecture/Ecriture DVD</td>
<td>Taux de transfert (Mo/s)</td>
<td>Vitesse de Lecture/Ecriture CD-R(W)</td>
</tr>
<tr align="center">
<td>1x</td>
<td>1.32</td>
<td>9x</td>
</tr>
<tr align="center">
<td>2x</td>
<td>2.64</td>
<td>18x</td>
</tr>
<tr align="center">
<td>4x</td>
<td>5.28</td>
<td>36x</td>
</tr>
<tr align="center">
<td>8x</td>
<td>10.57</td>
<td>72x</td>
</tr>
</table>

<p>
Comme on peut le voir dans le tableau, les taux de transfert sont
relativement hauts, et vous devrez vérifier que votre bus (SCSI,
(E)IDE/ATAPI, USB) est assez performant pour les supporter.
Spécifiquement, les vielles interfaces USB 1.0 et 1.1 travaillent à des
taux plus bas, avec des vitesses de transfert de 1.5 Mbit/s et 12
Mbit/s, respectivement.
Cela signifie que l'USB 1.0 a une vitesse maximum de 178.8 kByte/s et
USB 1.1 de 1.43 MB/s.
USB 2.0 est plus rapide : 480 Mbit/s ou 57.2 MB/s.
En général, les vitesses des bus SCSI et (E)IDE/ATAPI sont correctes.

<h4>Graver les DVDs</h4>

Basiquement, le processus est très similaire à celui d'écrire des CD-
R(W)s.
Le logiciel, cependant, diffère.
A ce moment, la meilleure option est <b>growisofs</b> depuis le paquetage
<tt>sysutils/dvd+rw-tools</tt>.
Cet utilitaire écrit une image ISO 9660 sur le média DVD. Tous les
formats DVD sont supportés par dvd+rw-tools.

<p>
Dans le cas où vous voudriez plus d'informations sur le média présent
dans votre graveur de DVD (par exemple si vous avez perdu le texte
d'information dans la boite du cd ou êtes simplement désorganisé comme
moi), vous pouvez utiliser l'utilitaire <b>dvd+rw-mediainfo</b>.

<!--blockquote><pre>
$ <strong>dvd+rw-mediainfo /dev/rcd2c</strong>
INQUIRY:                [LITE-ON ][DVDRW LDW-851S  ][GS0C]
GET [CURRENT] CONFIGURATION:
 Mounted Media:         1Ah, DVD+RW
 Current Write Speed:   4.0x1385=5540KB/s
 Write Speed #0:        4.0x1385=5540KB/s
 Write Speed #1:        2.4x1385=3324KB/s
GET [CURRENT] PERFORMANCE:
 Write Performance:     4.0x1385=5540KB/s@[0 -> 0]
 Speed Descriptor#0:    00/0 R@2.4x1385=3324KB/s W@4.0x1385=5540KB/s
 Speed Descriptor#1:    00/0 R@2.4x1385=3324KB/s W@2.4x1385=3324KB/s
READ DVD STRUCTURE[#0h]:
 Media Book Type:       92h, DVD+RW book [revision 2]
 Media ID:              SONY/S11
 Legacy lead-out at:    2295104*2KB=4700372992
READ DISC INFORMATION:
 Disc status:           blank
 Number of Sessions:    1
 State of Last Session: empty
 Number of Tracks:      1
READ TRACK INFORMATION[#1]:
 Track State:           blank
 Track Start Address:   0*2KB
 Free Blocks:           2295104*2KB
 Track Size:            2295104*2KB
READ CAPACITY:          1*2048=2048
</pre></blockquote-->

Il y a deux options pour écrire le DVD:
<ul>
<li>Pre-masteuriser une image ISO 9660 depuis vos données, stockant
l'image sur votre disque dur; puis l'écrire sur le DVD.
<li>Ecrire une image ISO 9660 de vos données directement sur le DVD.
</ul>

<p>
J'ai crée une image ISO 9660 pré-masteurisée depuis les modules CVS
d'OpenBSD (src, XF4, ports et www) présents dans le dossier /cvs de mon
disque.
J'ai utilisé la commande suivante, qui ressemble beaucoup à celle que
j'ai utilisé pour créer l'image CD-ROM précédente.

<blockquote><pre>
$ <strong>mkisofs -R -o cvs.iso /cvs</strong>
</pre></blockquote>

Si vous le souhaitez, testez le système de fichiers ISO 9660 en
<a href="faq14.html#MountImage">montant l'image</a>.
Pour écrire cette image (environ 2Go) sur un disque DVD, on peut
utiliser :

<blockquote><pre>
# <strong>growisofs -dvd-compat -Z /dev/rcd2c=cvs.iso</strong>
Executing 'builtin_dd if=cvs.iso of=/dev/rcd2c obs=32k seek=0'
/dev/rcd2c: pre-formatting blank DVD+RW...
/dev/rcd2c: "Current Write Speed" is 4.1x1385KBps.
23822336/1545832448 ( 1.5%) @3.9x, remaining 5:19
42172416/1545832448 ( 2.7%) @3.9x, remaining 5:20
60522496/1545832448 ( 3.9%) @3.9x, remaining 4:54
...
1504706560/1545832448 (97.3%) @3.9x, remaining 0:07
1523318784/1545832448 (98.5%) @3.9x, remaining 0:04
1541898240/1545832448 (99.7%) @3.9x, remaining 0:00
/dev/rcd2c: flushing cache
/dev/rcd2c: writing lead-out
/dev/rcd2c: reloading tray
</pre></blockquote>

L'option <tt>-Z</tt> demande à growisofs de graver une session initiale
sur le périphérique, qui dans ce cas est mon graveur de DVD, attaché à
cd2.
L'option <tt>-dvd-compat</tt> finalise le disque, ce qui signifie
qu'aucune nouvelle session ne peut y être rajoutée.
Cela devrait fournir une meilleure compatibilité avec les lecteurs DVD
et quelques vielles unités DVD-ROM.

<p>Remarquez comment growisofs indique la vitesse d'écriture, dans notre
cas 3.9x, ce qui est ce que l'on peut attendre en combinant les vitesses
du média et du graveur, comme indiqué par le dvd+rw-mediainfo.

<p>
Si vous ne disposez pas de suffisamment de place pour stocker une image
de ISO 9660 four un DVD, vous pouvez écrire vos données directement sur
le DVD. Essayons simplement une simulation de création du système de
fichiers.

<blockquote><pre>
# <strong>growisofs -dry-run -Z /dev/rcd2c -R /cvs</strong>
</pre></blockquote>

Si cela fonctionne, retirez simplement l'option -dry-run et commencez
l'écriture du DVD.

<blockquote><pre>
# <strong>growisofs -Z /dev/rcd2c -R /cvs</strong>
</pre></blockquote>

<p>
Il est aussi possible d'ajouter des données à un DVD existant, en
utilisant l'option -M, qui fond une nouvelle session dans une session
existante :

<blockquote><pre>
# <strong>growisofs -M /dev/rcd2c -R /mydata</strong>
</pre></blockquote>

Pour plus d'informations à propos de growisofs, consultez sa page de
manuel.

<p>
Lorsque vous avez terminé d'écrire le DVD, montez le et vérifiez que
tout ce que vous souhaitiez présent y soit effectivement.

<h4>Pourquoi je n'obtiens pas la vitesse que je veux ?</h4>

Au lieu de la vitesse d'écriture précédente, vous pourriez voir quelque
chose comme ceci :

<blockquote><pre>
  4784128/1545832448 ( 0.3%) @0.7x, remaining 26:50
  7929856/1545832448 ( 0.5%) @0.7x, remaining 29:05
  14123008/1545832448 ( 0.9%) @0.7x, remaining 27:06
  ...
</pre></blockquote>

ce qui est bien plus lent.
Cela signifie qu'il ne transite pas assez d'informations sur l'un des
bus que votre DVD utilise.

Dans l'exemple précédent, le graveur de DVD USB fut installé sur une machine
sur laquelle le driver
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ehci&amp;sektion=4">ehci(4)</a>,
utilisé par les contrôleurs USB 2.0, ne s'est pas initialisé correctement.
Comme d'habitude, vous êtes invités à envoyer des patchs et résultats de
vos tests.

Le graveur de DVD fut ralenti par l'interface USB 1.1 plus lente, ce qui
a réduit la vitesse de gravure.
L'USB 1.1 est limité à 12 Mbit/s, ce qui correspond à 1.43 MB/s ou 1.08x
en terme de vitesse DVD.

Le graveur de DVD est descendu à une plus basse vitesse de gravure pour
diminuer le risque de buffer overrun (défaut de données à écrire).


<a name="convert"></a>
<h2>13.11 - Je voudrais mes fichiers multimédia au format FOO.</h2>

<h3>Conversion entre différents formats audios</h3>

Admettons que vous souhaitiez convertir le son enregistré avec
<a href="#recordaudio">FAQ 13 - Enregistrer des séquences audio</a>.
Cet enregistrement a été enregistré en format brut. Il serait utile de
le convertir car le format brut ("raw") ne contient pas d'en-tête et les
paramètres devront être spécifiés à chaque utilisation du fichier.

<p>
Un bon outil de conversion de format est <tt>audio/sox</tt>, disponible 
au travers des ports et des paquetages.
<b>sox</b> supporte les formats AIFF, AU, MP3, Ogg Vorbis, RIFF WAV et
raw, ainsi que certains autres plus exotiques. Ci-dessous vous trouverez
un exemple de conversion de l'enregistrement vers le format RIFF WAV.

<blockquote><pre>
$ <strong>sox -U -c 1 -r 8000 -b myvoice.raw myvoice.wav</strong>
</pre></blockquote>

Notez que les paramètres spécifiés correspondent aux paramètres
d'enregistrement spécifiés avant l'enregistrement.
Cela n'est qu'un exemple. De nombreux autres programmes et bibliothèques
peuvent être utilisés en conversion audio.

<p>
<b>Note :</b>
Il n'est pas recommandé de convertir entre différents formats de
compression dits destructeurs ("lossy"). Par exemple, les codecs MP3 et
Vorbis suppriment certaines informations du fichier audio original.
Ainsi, lorsque vous convertissez un fichier MP3 en Ogg Vorbis, le
résultat final sonnera certainement moins bon que l'original.

<h3>Conversion entre différents formats vidéos</h3>

Il est important de faire une distinction entre
<ul>
<li>le format du containeur - par exemple, MP4, OGG, MPEG, MOV, AVI,
ASF.
<li>le codec vidéo - par exemple, MPEG-1, MPEG-2, codecs compatibles
MPEG-4 (comme Xvid et DivX), FFmpeg, WMV, ... - lisez
<a href="http://en.wikipedia.org/wiki/Video_codec">l'article Wikipedia
sur les codecs vidéos</a> pour en savoir plus.
</ul>

Pour le moment, le support des containeurs MPEG et AVI est le plus
abouti.

<p>
Il existe deux utilitaires populaires, <tt>multimedia/transcode</tt> et
<b>mencoder</b> (qui fait partie de <tt>x11/mplayer</tt>). Ils utilisent
ou  peuvent utiliser la bibliothèque <b>libavcodec</b> disponible dans
le port <tt>graphics/ffmpeg</tt> et qui génère un format de sortie de
bonne qualité. Vous pouvez bien sûr utiliser <b>ffmpeg</b> directement.
Il devrait aussi être possible d'utiliser l'encodeur XviD présent dans
<tt>multimedia/xvidcore</tt>.

<p>
La documentation, qui vient avec ces paquetages sous la forme de pages
de manuel ou de documents HTML dans <tt>/usr/local/share/doc</tt>,
contient de nombreux exemples, c'est pourquoi il est HAUTEMENT
recommandé de lire ces documents.


<a name="streaming"></a>
<h2>13.12 - Est-il possible de lire des fichiers en streaming sous
OpenBSD ?</h2>

Oui, c'est possible. De nombreux streams audio et vidéos fonctionneront
sans soucis sur un nombre limité de plates-formes. Certains, quant à eux,
ne fonctionneront pas.

<p>
Ce document ne représente pas une réponse exhaustive sur la manière de
faire fonctionner tous les formats de streaming possibles sur n'importe
qu'elle architecture. Tout d'abord, vous devriez vous renseigner sur
la technologie de streaming. Quoi qu'un peu daté, le
<a href="http://www.oreilly.com/catalog/sound/chapter/ch05.html">
chapitre à propos du streaming</a> tiré du livre "Designing Web Audio"
aux éditions O'Reilly représente un bon début.

<p>
La première chose à savoir est qu'il existe plusieurs protocoles de
streaming. Le <b>protocole</b> de streaming définit la façon dont les
flux seront envoyés à travers le réseau. Ils ont été développés afin de
garantir une transmission audio/vidéo efficace en temps réel par
internet. En bref, le protocole de streaming est un protocole applicatif
(niveau 7) capable d'utiliser les protocoles de transport UDP ou TCP
(niveau 4). Le protocole de transport UDP ("User Datagram Protocol")
convient parfaitement pour ce type d'application puisqu'il n'effectue
aucune retransmission de paquets ou autre type de charge réseau. Un
certain nombre de protocoles spécialisés mais propriétaires ont été
développés, par exemple Microsoft Media Services (MMS - services média
de Microsoft) et le Real Time Streaming Protocol (RTSP - protocole de
transmission de flux en temps réel). Comme nous le verrons, HTTP (qui
utilise TCP) est également parfois utilisé, même s'il ne permet pas de
transmettre des flux à une vitesse régulière comme UDP, RTSP et MMS.

<p>
Ensuite, il y a le <b>format</b> de streaming qui représente la façon
dont les données audio/vidéo ont été organisées et peuvent être lues.
Les formats de streaming les plus utilisés sont le MP3, Real Audio (RA,
RM) et le Windows Media (ASF) qui sont tous des technologies
propriétaires. Parfois, vous rencontrerez certains streams au format
Ogg Vorbis.

<p>
Pour l'exemple, j'expliquerai, en quelques étapes, comment j'arrive à
écouter <a href="http://www.radio1.be">Radio 1</a>, une des stations
radios nationales belges. Sous OpenBSD, les plugins (modules externes)
de navigateurs ne sont pas disponibles, ce qui signifie que la mise en
place se résume rarement en un "clic et lecture".

<ul>
<li>Déterminer le protocole de streaming et le format.<br>
Ceci est généralement indiqué sur le site web sur lequel vous accédez
au stream. Dans ce cas, je clic simplement sur le lien "Listen live"
(écoutez en direct) à partir du site principal qui me répond que mon
système d'exploitation n'est pas supporté. Ils sont suffisamment polis
pour me signifier que je peux également écouter leur stream MP3 sans
utiliser leur lecteur Flash qui nécessite un plugin. Ensuite une liste
de liens vers les stations radios nationales apparaît, ce qui me permet
de passer à la suite. Notez que j'ai dû utiliser un navigateur
compatible JavaScript afin d'arriver ici.
<li>Déterminer l'URL précise.<br>
De nombreux sites internet lient vers un containeur (du type M3U, ASX,
RAM) qui contient la localisation effective du flux. Enregistrez
simplement ce fichier et récupérez l'URL à partir de celui-ci. Dans mon
exemple, il s'agit de :

<blockquote><pre>
$ <strong>ftp http://internetradio.vrt.be/dab/hoeluisteren/pc/help/gebruiksvoorwaarden/stream_11.m3U</strong>
$ <strong>cat stream_11.m3U</strong>
http://mp3.streampower.be/radio1-mid.mp3
http://mp3.streampower.be/radio1-low.mp3
http://mp3.streampower.be/radio1-high.mp3
</pre></blockquote>

Visiblement, je peux même choisir entre différentes qualités de flux
("low, medium et high"). D'autres sites peuvent contenir du code
JavaScript pour créer l'URL. Dans ce cas, le meilleur conseil serait :
parcourez le source HTML ainsi que les scripts auxquels il se réfère. Il
existe une bonne chance que vous soyez en mesure de reconstruire l'URL à
partir de ces données.

<li>Pour lire ces flux, votre meilleure chance est probablement
<tt>x11/mplayer</tt>, disponible en tant que paquetage et dans l'arbre
des ports. Il supporte la plupart des protocoles et formats de streaming
et fonctionne sur les plates-formes amd64, i386, powerpc et sparc64. Mais
il existe des alternatives : <b>ogg123</b> dans
<tt>audio/vorbis-tools</tt> (pour les streams Ogg Vorbis),
<tt>audio/mpg123</tt> et <tt>audio/mpg321</tt> (pour les streams MP3),
XMMS dans <tt>audio/xmms</tt> et le client Videolan dans
<tt>x11/vlc</tt>. Continuons l'exemple :

<blockquote><pre>
$ <strong>mplayer http://mp3.streampower.be/radio1-mid.mp3</strong>
</pre></blockquote>

<li>Si vous le souhaitez, vous pouvez faciliter cela en ajoutant un
alias dans votre fichier <tt>.profile</tt> :

<blockquote><pre>
alias radio1='mplayer http://mp3.streampower.be/radio1-mid.mp3'
</pre></blockquote>

</ul>

<!--  
check out http://www.cbc.ca/listen/index.html
it has DivX streams over MMS as well as Ogg Vorbis streams over HTTP.
maybe a good example but also nearly an ideal case...
-->

Les flux Windows Media (ASF) fonctionneront la plupart du temps bien
qu'ils puissent contenir des données aux formats supportés uniquement
grâce au port <tt>graphics/win32-codecs</tt> qui ne tourne que sous
i386 ('pkg_info win32-codecs' vous donnera la liste des codecs
supportés). Certains flux Real Audio peuvent fonctionner sous i386 en
utilisant <b>mplayer</b> en conjonction avec les ports
<tt>graphics/win32-codecs</tt> et <tt>emulators/fedora/base</tt> (lisez
<a href="http://marc.info/?t=107060510300001&amp;r=1&amp;w=2">
ce fil</a> de la liste de discussion des ports).

<a name="javaflash"></a>
<a name="javaplugin"></a>

<h2>13.13 - Puis-je utiliser un plugin Java avec mon navigateur ?
(spécifique à i386 &amp; amd64)</h2>

Le plugin Java fait partie du kit de développement Java ("Java
Development Toolkit" - JDK). Pour des raisons de licence ,OpenBSD ne
peut pas distribuer de paquetages binaires du JDK. Cela signifie que
vous devrez le compiler à partir des ports. De plus amples informations
sur la compilation du JDK sont disponibles dans
<a href="faq8.html#Programming">FAQ 8 - Langages de programmation</a>.
Une fois le paquet créé, vous pouvez installer le JDK complet ou
simplement l'environnement d'exécution Java ("Java Runtime Environment"
- JRE) qui se trouve dans un sous-paquetage et contient le
plugin web.

<p>
A la fin de l'installation, des instructions seront affichées afin
d'utiliser le plugin Java avec Firefox ou un navigateur basé sur
Seamonkey. Créez le lien comme expliqué et vous devriez voir le plugin
Java lorsque vous entrerez "about:plugins" dans la barre d'adresse.

<p>
Pour le navigateur web Konqueror de KDE, le binaire java doit être dans
votre PATH, ou son chemin absolu doit être configuré du menu
Settings -&gt; Configure Konqueror -&gt; Java &amp; JavaScript.
Par défaut le binaire java se trouve dans
<tt>/usr/local/jre-<i>version</i>/bin/</tt> ou
<tt>/usr/local/jdk-<i>version</i>/bin/</tt>, cela dépend si vous avez
installé le JRE oue le JDK.

<p>
<b>Remarque :</b> Le support Java a été testé uniquement avec les navigateurs 
Firefox, Seamonkey et Konqueror.
Si il fonctionne bien avec d'autres navigateurs merci de nous le signaler.

<a name="flashplugin"></a>
<h2>13.14 - Puis-je utiliser un plugin Flash avec mon navigateur ?
(spécifique à i386)</h2>

Le plugin Flash est distribué par Adobe sous forme binaire uniquement.
Adobe ne fournit pas de plugin natif pour OpenBSD mais il existe un
plugin pour Linux qui peut être utilisé sous émulation. Ce plugin n'est
disponible que pour les plates-formes i386.

<p>
Avant de poursuivre, vous devriez vous renseigner sur l'émulation Linux
dans la page de manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=compat_linux&amp;sektion=8">compat_linux(8)</a>
ainsi que
<a href="faq9.html#Interact">FAQ 9 - Exécution des binaires Linux sous OpenBSD</a>.

<p>
Si vous avez assimilé ces documents mais n'avez pas encore installé les
fichiers nécessaires, ajoutez simplement le paquetage fedora. En
admettant que vous ayez correctement défini la variable
<tt>PKG_PATH</tt> (voyez <a href="../fr/faq15.html#Easy">FAQ 15</a>),

<blockquote><pre>
# <b>pkg_add -i fedora_base</b>
</pre></blockquote>

La première commande définira automatiquement
<tt>kern.emul.linux=1</tt>, mais pas de façon permanente. Si vous avez
besoin de l'émulation Linux en permanence, vous devez le spécifier dans
<tt>/etc/sysctl.conf</tt>, comme expliqué dans
<a href="faq9.html#Interact">FAQ 9 - Exécution des binaires Linux sous
OpenBSD</a>.

<p>
Une autre chose que vous devriez savoir est que les bibliothèques partagées
ainsi que les modules Linux ne peuvent pas être utilisés avec des
exécutables OpenBSD, ce qui signifie que vous aurez également besoin
d'un navigateur Linux.

<p>
Un candidat serait le navigateur
<a href="http://www.opera.com/">Opera</a>, disponible dans l'arbre des
ports. OpenBSD ne distribue pas de paquetage car la licence d'Opera
n'est pas claire à ce sujet. Cependant, l'installation ne devrait pas
prendre de temps puisqu'il est distribué sous forme binaire par Opera
Software. Après cela vous pouvez facilement installer le plugin Flash en
utilisant les ports.

<blockquote><pre>
# <b>cd /usr/ports/www/opera</b>
# <b>make install</b>
# <b>cd /usr/ports/www/opera-flashplugin</b>
# <b>make install</b>
</pre></blockquote>

<p>
<b>Note :</b>
La dernière étape devrait suffire en elle-même car le système des ports
devrait installer les dépendances automatiquement. Cependant, dans un
souci de clarté nous séparons le processus en plusieurs étapes afin d'en
faciliter la compréhension.

<p>
Si vous avez suivi ce guide, le plugin Flash devrait être listé lorsque
vous tapez "about:plugins" dans la barre d'adresse.

<!--
this would be interesting, but lack of hardware at the moment

<a name="camera"></a>
<h2>13.xx - Can I use my digital camera under OpenBSD?</h2>

<a name="scanner"></a>
<h2>13.yy - How do I set up and use my scanner?</h2>
-->

<p>
<font color= "#0000e0">
<a href= "index.html">[Index de la FAQ]</a>
<a href= "faq12.html">[Section 12 - Questions Spécifiques Aux
Plates-Formes Et Au Matériel]</a>
<a href= "faq14.html">[Section 14 - Configuration des disques]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq13.html,v 1.135 ]<br>
$Translation: faq13.html,v 1.59 2010/02/26 07:58:39 ajacoutot Exp $<br>
-->
$OpenBSD: faq13.html,v 1.51 2010/02/28 08:37:46 ajacoutot Exp $
</small>

</body></html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>7 - Contrôles du clavier et de l'affichage</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2008 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../fr/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[Index de La FAQ]</a>
<a href= "faq6.html">[Section 6 - Administration réseau]</a>
<a href= "faq8.html">[Section 8 - Questions diverses]</a>
</font>

<h1><font color="#e00000">7 - Contrôles du clavier et de l'affichage</font></h1>
<!-- UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC -->

<!--
<hr>
<p>
<b><font color="#e00000">Remarque Importante :</font></b> Le contenu de
   ce fichier est obsolète. Consultez la version anglaise 
   <a href="../../faq7.html">ici</a> pour des informations à jour.

<p>
Si vous souhaitez contribuez à l'effort de traduction,
prière de consulter
<a href="../../../../fr/translation.html">la page de traduction</a>.
-->
<hr>

<p>
<h3>Table des matières</h3>
<ul>
<li><a href= "#Keyboard"     >7.1 - Comment puis-je redéfinir le clavier ?
(wscons)</a> 
<li><a href= "#ConsoleMouse" >7.2 - OpenBSD dispose t-il d'un support de la souris
en mode console ?</a> 
<li><a href= "#Scrollback"   >7.3 - Accéder au tampon de la console. 
 (amd64, i386, quelques Alpha)</a>
<li><a href= "#SwitchConsole">7.4 - Comment puis-je changer de console ?
(amd64, i386, Zaurus, quelques Alpha)</a>
<li><a href= "#80x50"        >7.5 - Comment puis-je utiliser une résolution 
 console de 80x50 ? (amd64, i386, quelques Alpha)</a>
<li><a href= "#SerCon"       >7.6 - Comment puis-je utiliser une console série ?</a>
<li><a href= "#Blanker"      >7.7 - Comment effacer la console ? (wscons)</a>
<li><a href= "#ALLCAPS"      >7.8 - TOUT CE QUE JE TAPE A LA CONNEXION EST EN
    MAJUSCULES !</a>
<li><a href= "#tmux"         >7.9 - Qu'est ce que tmux(1) ?</a>
</ul>

<hr>

<br>
<p>
<a name= "Keyboard"></a>
<h2>7.1 - Comment puis-je redéfinir le clavier ? <i>(wscons)</i></h2> 

<p>
En utilisant le pilote console <a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">wscons(4)</a> : 
<a href="../../fr/alpha.html">alpha</a>,
<a href="../../fr/amd64.html">amd64</a>,
<a href="../../fr/hppa.html">hppa</a>,
<a href="../../fr/i386.html">i386</a>,
<a href="../../fr/mac68k.html">mac68k</a>,
<a href="../../fr/macppc.html">macppc</a>,
<a href="../../fr/sparc.html">sparc</a>,
<a href="../../fr/sparc64.html">sparc64</a>,
<a href="../../fr/vax.html">vax</a>,
et <a href="../../fr/zaurus.html">zaurus</a>.

<p>
Avec wscons(4), plusieurs options peuvent être configurées en 
utilisant l'utilitaire <a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a>. 
Par exemple, pour changer la configuration des touches du 
clavier avec <a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a> 
vous devez exécuter ceci :

<blockquote><pre>
# <strong>wsconsctl keyboard.encoding=fr</strong>
</pre></blockquote>

<p>
Dans l'exemple suivant, on redéfinit la touche &quot;Caps Lock&quot; 
en &quot;Control L&quot; :

<blockquote><pre>
# <strong>wsconsctl keyboard.map+="keysym Caps_Lock = Control_L"</strong>
</pre></blockquote>

<a name= "ConsoleMouse"></a>
<h2>7.2 - OpenBSD dispose t-il d'un support de la souris
en mode console ?</h2>

<p>
Pour les plates-formes <a href="../../fr/alpha.html">alpha</a>,
<a href="../../fr/amd64.html">amd64</a> et <a href="../../fr/i386.html">i386</a>, OpenBSD fournit  
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsmoused&amp;sektion=8&amp;arch=i386">wsmoused(8)</a>, 
un port du service moused(8) de FreeBSD. Il peut être
lancé au démarrage en copiant et éditant la ligne appropriée de rc.conf dans 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8">rc.conf.local(8)</a>. 

<p>
<a name= "Scrollback"></a>
<h2>7.3 - Accéder au tampon de la console <i>(amd64, i386, quelques Alpha)</i></h2>

<p>
Sur quelques plates-formes, OpenBSD offre la possibilité de revenir en
arrière dans la console. Ceci permet de voir les informations inscrites
précédemment sur votre écran. Pour monter et descendre dans le tampon,
utilisez simplement les combinaisons de touches
<tt>[SHIFT]+[PGUP]</tt> et <tt>[SHIFT]+[PGDN]</tt>.

<p>
La valeur par défaut de pages que vous pouvez consulter 
en revenant en arrière dans la console est de 8.
Ceci est une fonctionnalité du driver
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga&amp;sektion=4">vga(4)</a>,
donc cela ne fonctionnera pas sans carte vga quelque soit
la plate-forme (beaucoup de systèmes Alpha ont une carte vidéo
de type TGA).

<p>
Par manque d'espace, les noyaux d'installation ne fournissent pas la
possibilité de revenir en arrière dans la console.
<a href="#SwitchConsole">Changer de console</a> effacera le tampon de
retour en arrière.

<p>
<a name= "SwitchConsole"></a>
<h2>7.4 - Comment puis-je changer de console ? <i>(amd64, i386, Zaurus,
      quelques Alpha)</i></h2>

Sur amd64, i386 et quelques systèmes Alpha, avec les cartes
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga&amp;sektion=4">vga(4)</a>,
OpenBSD fournit six terminaux virtuels par défaut, allant de
/dev/ttyC0 à /dev/ttyC5.
ttyC4 est réservée pour l'utilisation de X, laissant donc cinq
consoles texte.
Vous pouvez passer de l'une à l'autre en utilisant
<tt>[CTRL]+[ALT]+[F1]</tt>, <tt>[CTRL]+[ALT]+[F2]</tt>,
<tt>[CTRL]+[ALT]+[F3]</tt>, <tt>[CTRL]+[ALT]+[F4]</tt> et
<tt>[CTRL]+[ALT]+[F6]</tt>.

<p>
L'environnement X utilise ttyC4, <tt>[CTRL]+[ALT]+[F5]</tt>.
Lorsque vous utilisez X,
les combinaisons <tt>[CTRL]+[ALT]+[F</tt><i>n</i><tt>]</tt> vous basculerons
sur les consoles textes ; 
<tt>[CTRL]+[ALT]+[F5]</tt>
vous ramènera à l'environnement graphique. 

<p>
Si vous souhaitez avoir plus de console virtuelles que le nombre par défaut,
utilisez la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg&amp;sektion=8">wsconscfg(8)</a>
pour créer des consoles pour ttyC6, ttyC7 et au delà.
Par exemple :

<blockquote>
<pre>
wsconscfg -t 80x25 6
</pre>
</blockquote>

Créera un terminal virtuel pour ttyC6, accessible par
<tt>[CTRL]+[ALT]+[F7]</tt>.
N'oubliez pas d'ajouter cette commande à votre fichier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8"><tt>rc.local(8)</tt></a>
si vous souhaitez cette console supplémentaire au prochain redémarrage
de votre ordinateur.

<p>
Notez que vous n'obtiendrez pas une invite "<tt>login:</tt>" sur la
nouvelle console virtuelle tant que vous ne l'aurez pas mis à "on" dans
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5"><tt>/etc/ttys(5)</tt></a>,
puis au choix redémarré ou envoyé un signal HUP à
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a>
par le biais de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&amp;sektion=1">kill(1)</a>.

<p>
Sur le Zaurus, deux terminaux virtuels (/dev/ttyC0 and /dev/ttyC1) sont
disponibles par défaut. Ils sont accessibles à l'aide des combinaisons
de touches <tt>[ALT]+[CALENDAR]</tt> et <tt>[ALT]+[ADDRESS]</tt> (La
touche <tt>[ALT]</tt> se situe à gauche de la touche <tt>[CTRL]</tt>
key).

<a name="80x50"></a>
<h2>7.5 - Comment puis-je utiliser une résolution console de 80x50 ?
<i>(amd64, i386, quelques Alpha)</i></h2> 

Les utilisateurs de systèmes i386, amd64 et Alpha (VGA) ont normalement
une console de 25 lignes de 80 caractères.
Cependant, beaucoup de cartes vidéo VGA sont capables
d'afficher une résolution supérieure à 50
lignes de 80 caractères. 

<p>
Premièrement, une police supportant la résolution 
désirée doit être chargée en utilisant la 
commande <a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsfontload&amp;sektion=8">wsfontload</a>.
L'écran standard 80x25 utilise des polices de 8x16 pixels, pour doubler
la résolution verticale, nous allons devoir utiliser des polices
de 8x8 pixels.

<p>
Ensuite, nous allons devoir supprimer et recréer une
<a href="#SwitchConsole">console virtuelle</a> de la résolution
désirée en utilisant la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg&amp;sektion=8">wsconscfg</a>.

<p>
Ceci peut être fait automatiquement en ajoutant les lignes suivantes
à la fin de votre fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local&amp;sektion=8"><tt>rc.local</tt></a> :

<blockquote>
<pre>
wsfontload -h 8 -e ibm /usr/share/misc/pcvtfonts/vt220l.808
wsconscfg -dF 5
wsconscfg -t 80x50 5
</pre>
</blockquote>

Comme pour toutes les configurations de votre système, il est
recommandé de prendre le temps de lire les pages de manuels (man)
afin de comprendre ce que font les commandes ci-dessus.

<p>
La première commande ci-dessus charge une police 8x8.
La seconde supprime la console 5 (qui aurait été accessible via <tt>[CTRL]+[ALT]+[F6]</tt>). 
La troisième crée une nouvelle console 5 avec une
résolution de 50 lignes de 80 caractères chacune.
Si vous procédez de la sorte, vous verrez votre console
principale, ainsi que les trois autres consoles par défaut, 
en mode standard 80x25, mais une nouvelle console 5 en mode
80x50 accessible via <tt>[CTRL]+[ALT]+[F6]</tt>.

<p>
Rappelez vous que <tt>[CTRL]+[ALT]+[F1]</tt> est la console 0 (ttyC0).
Si vous désirez modifier les autres consoles, 
réalisez simplement les étapes de
suppression et d'ajout des consoles pour lesquelles vous
désirez une résolution de 80x50.

<p>
Vous devriez éviter de modifier la console 4 
(ttyC4, <tt>[CTRL]+[ALT]+[F5]</tt>), qui est utilisée 
par X en tant que console graphique. Il n'est pas non
plus possible de changer la résolution de la première
console (exemple ttyC0).

<p>
Comme certains ont pu le remarquer, toutes ces commandes peuvent
être tapées sur la ligne de commande, en tant 
que root, ou (mieux), en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo(8)</a>.

<p>
<b>Note : ceci ne fonctionnera pas avec toutes les cartes vidéo.</b>
Malheureusement, toutes les cartes vidéo ne supportent pas 
les polices fournies qui sont nécessaires à <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">wscons</a>
pour parvenir à configurer le mode texte 80x50. 
Dans ces cas là vous devriez reconsidérer le 
fait d'utiliser X.

<a name="SerCon"></a>
<h2>7.6 - Comment puis-je utiliser une console série ?</h2>

Il y a plusieurs raisons pour que vous souhaitiez utiliser une console
série sur votre système OpenBSD :
<ul>
<li>Enregistrer la sortie de la console (pour de la documentation). 
<li>Administration distante.
<li>Maintenance simplifiée d'un grand nombre de machines.
<li>Obtenir un très utile dmesg de machines depuis lesquelles cette obtention
 aurait été difficile.
<li>Obtenir une sortie "trace" et de "ps" si votre système se crash, pour que les
 développeurs aient une chance de régler le problème.
</ul>
OpenBSD supporte les consoles séries sur la plupart des plates-formes,
cependant certains détails varient considérablement entre plates-formes.

<p>
Notez que l'interfaçage série n'est PAS une tâche triviale -- vous serez
souvent obligé d'utiliser des câbles peu communs, et les ports ne sont
pas standardisés entre machines, dans certains cas, parfois même
incompatibles sur une machine. Nous considérons que vous savez comment
utiliser le câble adéquat entre votre ordinateur et le matériel faisant
office de terminal série. Un tutorial complet sur l'interfaçage série
sortirait du cadre de ce document, cependant, nous vous donnons un petit
conseil : ce n'est pas parce que les prises se connectent que cela
fonctionnera.

<a name="SerContty"></a>
<h3>Modification de <i>/etc/ttys</i></h3>
Deux conditions doivent êtres réunies pour obtenir une console série fonctionnelle
sur un système OpenBSD. Premièrement, vous devez indiquer à OpenBSD d'utiliser
le port série comme console pour les modes "status" et "single user".
Cette étape dépend de la plate-forme que vous utilisez.
Ensuite, vous devez activer votre port série comme terminal
interactif, de façon à ce qu'un utilisateur puisse s'y connecter
en mode multi-utilisateurs. Cette partie est relativement similaire
sur les différentes plates-formes, et est détaillée ici.

<p>
Les sessions de terminaux sont contrôlées par le fichier 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys&amp;sektion=5"><i>/etc/ttys</i></a>.
Avant qu'OpenBSD ne vous présente une invite "<tt>login:</tt>" sur un
périphérique, celui-ci doit être activé dans <i>/etc/ttys</i>, après tout,
il y à d'autres utilisations possibles que celle d'un terminal pour un port série.
Sur les plates-formes qui ont un clavier et un écran attaché comme console,
le terminal série est désactivé par défaut. Nous utiliserons la plate-forme
i386 comme exemple. Dans ce cas vous devez éditer la ligne suivante :

<pre>
     tty00   "/usr/libexec/getty std.9600"   unknown off
</pre>
ainsi (par exemple) :
<pre>
     tty00   "/usr/libexec/getty std.9600"   vt220   on secure
</pre>

Ici, <tt>tty00</tt> est le port série que nous utilisons comme console.
<tt>vt220</tt> représente l'entrée
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=termcap&amp;sektion=5">termcap(5)</a>
équivalente à votre terminal (d'autres options similaires pourraient
inclure <tt>vt100</tt>, <tt>xterm</tt>, etc.).
Le "<tt>on</tt>" active le 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8"><i>getty</i></a>
pour le port série afin que l'invite "<tt>login:</tt>" soit présentée,
le "<tt>secure</tt>" permet une connexion root (uid 0) sur cette
console (ce qui peut être, ou pas, ce que vous souhaitez), et le
"<tt>9600</tt>" est le débit en baud du terminal. Essayez de ne pas
augmenter le débit en baud du terminal jusqu'au maximum de ce que votre
matériel peut supporter car cela risque de poser plus de problèmes que
de bénéfices. La plupart des systèmes ont une vitesse "par défaut"
(supportée par défaut par la ROM de démarrage et/ou le chargeur de
démarrage, généralement 9600), utilisez celle-ci à moins que vous n'ayez
une raison valable de faire autrement.
<p>Notez que vous pouvez utiliser une console série pour l'installation
sans devoir réaliser tout cela étant donné que le système est lancé en
mode "single user" et n'utilise pas <i>getty</i> pour la connexion.

<p>
Sur certaines plates-formes ou configurations, vous devrez démarrer
le système en mode "single user" pour faire cette modification si vous
n'avez rien d'autre qu'une console série.

<h3>amd64 et i386</h3>
Pour que la procédure de démarrage utilise le port série comme console,
créez ou éditez votre fichier
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386">/etc/boot.conf</a></i>
pour y inclure la ligne :
<pre>
     set tty com0
</pre>

afin d'utiliser votre premier port série comme console.

<!-- revision -->

La bande passante en baud par défaut est 9600bps, ceci peut être
changé par une ligne du fichier <i>/etc/boot.conf</i> en utilisant
l'option stty. Ce fichier est stocké dans votre média de démarrage,
qui peut aussi être votre disquette d'installation, la commande peut
être entrée à l'invite <tt>boot></tt> depuis le
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">chargeur
de démarrage de second stage OpenBSD</a> pour une première utilisation de la commande
série.

<p>
<h4>notes pour amd64 et i386 :</h4>
<ul>
<li>OpenBSD numérote les ports séries en commençant à <i>tty00</i>,
les labels DOS/Windows commencent eux à <i>COM1</i>. Gardez donc à
l'esprit que <i>tty02</i> est <i>COM3</i>, et non <i>COM2</i>.

<li>Quelques systèmes pourront fonctionner sans carte vidéo présente dans
la machine, mais sûrement pas tous -- la plupart des systèmes considèrent
cela comme une erreur. Certaines machines refuserons même de fonctionner
sans clavier attaché.

<li>Certains systèmes sont capables de rediriger les activités BIOS du
clavier et de l'écran sur un port série au travers d'une option de
configuration, pour que la machine puisse être complètement maintenue
par le port série.

Les résultats que vous obtiendrez varieront, quelques BIOSs peuvent
empêcher le chargeur de démarrage de voir le port série, et donc le
noyau ne saura pas qu'il doit l'utiliser.
Certains BIOS ont une option "Continuer la redirection de la console
après le POST" (Power On Self Test), cela devra être désactivé, pour que
le chargeur de démarrage et le noyau puissent disposer de leur propre console.
Malheureusement cette option n'est pas universelle.

<li>Les ordinateurs compatibles PC, ne sont pas pensés dans le but d'être
utilisés depuis une console série, à la différence d'autres plates-formes.
Même sur les systèmes qui supportent une console série, celle-ci doit
être activée dans la configuration BIOS -- et si les informations de
configuration de celui-ci sont corrompues, vous serez face à un système
qui recherche de nouveau un moniteur et un clavier.
Vous devrez généralement, disposer d'un moyen d'obtenir un clavier et un
moniteur pour vos systèmes amd64 et i386 en cas d'urgence. 

<li>Vous devrez éditer <i>/etc/ttys</i> comme décrit
<a href="#SerContty">ci-dessus</a>.

</ul>


<h3>SPARC et UltraSPARC</h3>
Ces machines sont construites dans le but d'être totalement configurables
par console série. Retirez simplement le clavier de la machine et le système
lancera une console série.

<h4>Notes SPARC et UltraSPARC</h4>
<ul>
<li>Les ports sur un SPARC sont appelés <i>ttya</i>,
<i>ttyb</i>, etc.

<li>A la différence des autres plates-formes, il n'est pas nécessaire de
faire des changements à <i>/etc/ttys</i> pour utiliser une console série.


<li>Les systèmes SPARC/UltraSPARC interprètent le signal BREAK sur le port
série de la même manière que la commande STOP-A, et renvoient le système
à l'invite "Forth", stoppant toute application et le système lui même
à ce point. Cela est intéressant lorsque souhaité, mais malheureusement,
quelques terminaux série lors de l'arrêt et quelques matériels de switch
RS-232 envoient quelques codes à l'ordinateur que celui-ci interprète comme
un signal BREAK, arrêtant la machine. Testez cela avant de passer la
machine en production.

<li>Si vous avez un clavier et une souris connectés, vous pouvez toujours
forcer l'utilisation de la console série en utilisant les commandes
suivantes à l'invite <tt>ok</tt> :
<pre>
    ok <b>setenv input-device ttya</b>
    ok <b>setenv output-device ttya</b>
    ok <b>reset</b>
</pre>
Si le clavier et l'écran (ttyC0) sont activés dans <i>/etc/ttys</i>
(<a href="#SerContty">ci-dessus</a>), vous pouvez utiliser le clavier
et le moniteur dans X.
</ul>

<h3>MacPPC</h3>
Les machines MacPPC, sont configurées pour utiliser une console série
au travers de "OpenFirmware". L'utilisation des commandes
 <pre>
     ok <b>setenv output-device scca</b>
     ok <b>setenv input-device scca</b>
     ok <b>reset-all</b>
 </pre>

Vous configurera une console série à 57600bps, 8N1.

<h4>Notes MacPPC</h4>
<ul>
<li>Malheureusement, l'utilisation des consoles séries n'est pas directement
possible sur la plupart des MacPPCs.
Alors que la plupart des machines auront le matériel série, il n'est pas
accessible à l'extérieur de la machine.
Heureusement, quelques sociétés offrent des matériel tiers pour la plupart
des modèles Macintosh qui rendront ce port accessible pour une utilisation de
console série (ou autre).
Utilisez votre moteur de recherche préféré et recherchez
"Macintosh internal serial port".

<li>Vous devrez positionner <tt>tty00</tt> dans <i>/etc/ttys</i> à
<tt>on</tt> et mettre la vitesse à 57600 plutôt que la valeur par
défaut 9600 comme décrit <a href="#SerContty">ci-dessus</a> dans le
mode "single user" avant de démarrer en mode multi-utilisateurs et
obtenir une console série fonctionnelle.</ul>


<h3>Mac68k</h3>

La console série est sélectionnée dans le programme <i>Booter</i>,
sous le menu "<tt>Options</tt>", puis "<tt>Serial Ports</tt>".
Cochez le bouton "Serial Console", puis choisissez le port du modem
ou de l'imprimante. Vous aurez besoin d'un modem Macintosh ou d'un
câble d'imprimante à attacher à un port série Mac. Si vous souhaitez
que ces paramètres soient utilisés par défaut, demandez au programme
"Booter" de sauvegarder vos options.

<h4>Notes Mac68k</h4>
<ul>
<li>Le port du modem est <i>tty00</i>, celui de l'imprimante <i>tty01</i>.

<li>Le Mac68k n'active pas son port série tant que cela n'est pas demandé,
aussi, votre machine n'enverra aucun signal sur la console série avant
que la procédure de démarrage OpenBSD ne commence.

<li>Vous devrez activer le port (<i>tty00</i> ou <i>tty01</i>) comme
indiqué <a href="#SerContty">ci-dessus</a>.
</ul>

<a name="Blanker"></a>
<h2>7.7 - Comment effacer la console ? (wscons)</h2>
Si vous souhaitez effacer votre console après une certaine période
d'inactivité sans utiliser X, vous pouvez modifier les variables
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons&amp;sektion=4">wscons(4)</a>
suivantes :

<ul>
<li><b><tt>display.vblank</tt></b> réglé à <tt>on</tt> désactivera les
rafraîchissements verticaux, ce qui mettra la plupart des moniteurs dans
le mode "économie d'énergie". Il faudra plus de temps pour retrouver
l'affichage, mais cela réduira la consommation d'énergie.

Quand il est réglé à <tt>off</tt>, l'affichage sera désactivé, mais le
moniteur continuera de recevoir les signaux de synchronisation verticaux
et horizontaux, donc l'affichage sera très vite réactivé.

<li><b><tt>display.screen_off</tt></b> règle le nombre de nettoyages en
millisecondes, par exemple, 60000 serait le temps pour une minute.

<li><b><tt>display.kbdact</tt></b> détermine si l'activité du clavier
provoquera le rafraîchissement de l'écran. En général, ceci est souhaité.

<li><b><tt>display.outact</tt></b> détermine si une sortie texte sur l'écran
provoquera le retour de l'affichage.
</ul>

Vous pouvez positionner ces variables en ligne de commande en utilisant
l'utilitaire 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl&amp;sektion=8">wsconsctl(8)</a> :
<pre>
     # <b>wsconsctl display.screen_off=60000</b>
     display.screen_off -> 60000
</pre>

ou les positionner de manière permanente en éditant le fichier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl.conf&amp;sektion=5"><i>/etc/wsconsctl.conf</i></a>
de manière à ce que les paramètres soient repris au prochain redémarrage :

<pre>
     display.vblank=on               # enable vertical sync blank
     display.screen_off=600000       # set screen blank timeout to 10 minutes
     display.kbdact=on               # Restore screen on keyboard input
     display.outact=off              # Restore screen on display output
</pre>

Le vidage est activé à partir du moment où <tt>display.kbdact</tt> ou
<tt>display.outact</tt> sont positionnés à "<tt>on</tt>".  

<a name="ALLCAPS"></a>
<h2>7.8 - TOUT CE QUE JE TAPE A LA CONNEXION EST EN
    MAJUSCULES !</H2>
En réalité, ceci est une fonctionnalité, non un bogue.

<p>
Virtuellement toutes les commandes et les noms d'utilisateurs sont
entrés en minuscules.

Cependant, quelques très vieux terminaux sont simplement incapables
d'afficher des caractères en minuscules, ce qui rend leur utilisation
difficile, voir impossible à utiliser avec UNIX.

Pour pallier cela, si vous utilisez un nom d'utilisateur entièrement
en majuscules,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8">getty(8)</a>
assumera que votre terminal ne supporte pas les minuscules, et
interprétera simplement tout ce que vous tapez comme des minuscules
alors qu'il affichera tout en majuscules.
Si votre mot de passe est composé de minuscules et de majuscules, la
connexion sera impossible.

<p>
L'appui sur CTRL-D à la connexion provoquera l'arrêt de getty(0) et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a>
en relancera un nouveau, qui acceptera correctement les minuscules
et les majuscules.

<a name="tmux"></a>
<h2>7.9 - Qu'est ce que tmux ?</h2>
<i>Remarque : tmux est une nouvelle fonctionnalité de OpenBSD 4.6</i>
<p>

Pour ceux qui sont familiés avec le programme "screen", disponible comme
paquetage, ou window(1) qui a été dans la base, il est plus simple de
répondre en disant que
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1">tmux(1)</a>
fournit plusieurs fonctions de screen et window, avec beaucoup de
fonctionnalités en plus.

<p>
Pour ceux qui ne sont pas familier avec ces programmes, tmux est un
<i>multiplexeur de terminal</i>.
C'est un programme qui permet qu'un nombre de plusieurs processus partagent le
même écran pour les entrées et sorties.
Dans tmux, cet ensemble de programmes d'appelle une <i>session</i>, dont
chaque programme est contenu dans une <i>windows</i> tmux.

<p>
En plus de partager le terminal, tmux vous permet de detacher une session et
ces fenêtres de l'écran, les laissant continuer à fonctionner en
arriére-plan, pour les réattacher plus tard dans le même écran ou dans un
autre.
Une session peut-être détachée manuellement ou à cause d'un évenement
inattendu comme une déconnexion réseau, dans tous les cas les programmes
survivent et continuent de fonctionner normalement.

<p>
tmux posséde aussi beaucoup d'autres fonctionnalités comme scinder une
fenêtre simple en plusieurs sections (appelés <i>panes</i>), un historique
du texte affiché dans chaque fenêtre, copier et coller du texte entre
fenêtres, combinaisons de touches configurable et verrouillage du terminal.
Jetez un oeil sur la page de man 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1">
tmux(1)</a> pour plus d'information.

<h3>Comment est-ce que j'utilise tmux ?</h3>

<p>
La premiére étape est de lancer tmux :

<blockquote><pre>
$ tmux
</pre></blockquote>

<p>
Ce démarre un nouveau tmux avec une nouvelle session unique (appelée "0") et
lui crée un affichage client sur l'écran.
La plupart de l'écran montrera une fenêtre contenant une invite de commande,
et vous remarquerez que la dernière ligne est occupée par une ligne d'état.
Cela affiche le nom de la session entre crochets à gauche,le nom de la
fenêtre (normalement vide pour les shells) et le temps sur la droite, et un
résumé de la fenêtre courante ouverte au milieu.
Dans notre nouvelle session, les fenêtres courantes ouvertes contiendront
une entrée, par exemple :

<blockquote><pre>
0:ksh*
</pre></blockquote>

<p>
Un rappel bref sur les terminaux : sur OpenBSD les applications sont faites
pour être indépendante des capacitées du terminal grâce à la variable
d'environnement TERM.
C'est configuré par le nom d'une entrée dans la base de données 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=terminfo&amp;sektion=5">terminfo(5)</a>
et dit aux programmes que le terminal, par exemple, supporte la couleur, ou
posséde la possibilité d'insérer des lignes, ou bien d'autres choses.
Une chose importante à remarquer est que l'entrée "xterm" dans la base de
données n'inclue pas la couleur, donc tmux n'utilise pas la couleur par
défaut dans xterm, TERM doit être configuré à "xterm-xfree86" à la place si
la couleur est désirée (la resource X "XTerm*termName" doit être configurée
dans .Xdefaults pour être utilisée dans tous les xterms).
Il est aussi important que le TERM dans les shells démarrés dans tmux soient
configurés à "screen" ou les programmes executés pour eux ne s'afficheront
pas correctement - tmux le configurera lui-même, mais il faut faire
attention à ne pas le surcharger dans des fichiers de démarrage shell.

<p>
Retournons à la ligne d'état, le numéro "0" est l'index de la fenêtre, "ksh"
le nom de la fenêtre, et le "*" que c'est la fenêtre courante qui est
affichée au dessus de la ligne d'état.
Tous ce que l'on tape est envoyé au shell et toutes sorties affichées.
Par exemple, si vous lancez 
"<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=top&amp;sektion=1">top</a>" :

<blockquote><pre>
$ top
</pre></blockquote>

<p>
Il fonctionnera normalement, occupant l'espace de l'écran au dessus de la
ligne d'état.
Vous remarquerez aussi que le nom de la fenêtre dans la ligne d'état a été
modifié de "ksh" à "top" - tmux renomme les fenêtres pour refleter le
programme qui fonctionne actuellement en elles-mêmes.

<p>
Maintenant, disons que vous voulez détacher tmux de l'écran et retourner au
shell d'origine d'ou vous l'avez lancé.
Une session tmux peut-être détachée en pressant en premier les touches
<i>Ctrl</i> et <i>b</i> ensembles puis la touche <i>d</i>.
La combinaison de touches <i>Ctrl-b</i> (raccourcie dans tmux et dans sa
page de man à "C-b") est appelée <i>touche de préfixe</i> et est utilisée
pour dire à tmux que la prochaine touche pressée est une instruction qui
doit générer une action, plutôt que de passer la touche à travers un
programme le programme dans la fenêtre.

<p>
Après avoir pressé <i>Ctrl-b d</i> et retourné à l'invite de commande,
reattachez la session tmux en utilisant la commande "attach" :

<blockquote><pre>
$ tmux attach
</pre></blockquote>
 
<p>
La session tmux réapparaitra, avec la ligne d'état et "top" fonctionnera
joyeusement.
(Si à la place vous éxecutez tmux sans argument, une deuxième sessions sera
crée, nommée "1").

<p>
Ensuite, créeons une deuxiéme fenêtre.
C'est réalisé en utilisant la touche "c" : pressez la touche préfixe,
<i>Ctrl-b</i>, puis la touche "c".
Une nouvelle fenêtre sera crée et une invite de commande sera encore
affichée sur l'écran.
La ligne d'état sera mise à jour pour afficher la nouvelle fenêtre :

<blockquote><pre>
0:top- 1:ksh*
</pre></blockquote>

<p>
Le "-" après "top" affiche la fenêtre courante précédente (la derniére
fenêtre).
En Pressant encore <i>Ctrl-b c</i> créera une nouvelle invite de commande :

<blockquote><pre>
0:top  1:ksh- 2:ksh*
</pre></blockquote>

<p>
Il y a plusieurs commandes pour se déplacer entre les fenêtres.
De la fenêtre 2, vous pouvez vous déplacer vers la fenêtre précédente,
numéro 1, en tapant <i>Ctrl-b p</i>.
<i>Ctrl-b n</i> déplacera vers la fenêtre suivante : dans ce cas, il n'y a
pas de fenêtre 3 donc la fenêtre courante deviendra la fenêtre 0.
Vous pouvez aussi taper <i>Ctrl-b w</i> pour obtenir un menu intéractif des
fenêtres ouvertes, <i>Ctrl-b l</i> pour se déplacer à la derniére fenêtre
(celle marquée avec un "-"), ou <i>Ctrl-b 0</i> pour se déplacer à la
fenêtre 0, <i>Ctrl-b 1</i> à la fenêtre 1 et jusqu'a <i>Ctrl-b 9</i> pour la
fenêtre 9.
Donc, pour retourner au "top" de la fenêtre 0, vous pouvez presser
<i>Ctrl-b 0</i> pour aller directement à la fenêtre 0, <i>Ctrl-b p</i> deux
fois pour aller à la fenêtre 1, <i>Ctrl-b n</i> pour sauter de la fenêtre 2
à la fenêtre 0, ou presser <i>Ctrl-b w</i> et sélectionner la fenêtre 0 de
la liste.

<p>
Parfois vous voulez créer une fenêtre executant directement un programme,
sans passer par l'invite de commande.  
Cela peut-être fait de tmux via <i>l'invite de commande</i>.
En pressant la séquence de touches <i>Ctrl-b :</i> la ligne d'état change
pour afficher une invite ":" ou des commandes peuvent être entrées.
Toutes les commandes tmux sont documentées dans la page de man.
Dans ce cas, la commande "new-window" est nécessaire.
Chaque commande posséde un alias plus court qui peut-être utilisé à la place
de taper le nom complet, pour "new-window" c'est "neww".
Donc pour créer une nouvelle fenêtre éxecutant 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tetris&amp;sektion=6">tetris(6)</a>, 
tapez :

<blockquote><pre>
neww tetris
</pre></blockquote>

<p>
La nouvelle fenêtre sera fermée quand tetris sera terminé, ou sera forcement
tuée en utilisant la combinaison de touches <i>Ctrl-b &<</i>.
Cela demandera en premier une confirmation et si elle est donnée, fermera la
fenêtre et terminera le programme fonctionnant en elle.

<p>
Un autre besoin courant est de renommer une fenêtre.
Cela peut-être fait avec la combinaison de touches <i>Ctrl-b ,</i>.
La ligne d'état sera modifiée pour afficher une invite "(rename-window)" ou
l'on fournira le nom de la nouvelle fenêtre.
Renommer une fenêtre désactive le renommage automatique pour cette fenêtre,
pour réactiver cette fonctionnalité, pressez <i>Ctrl-b :</i> pour obtenir
l'invite de commande et entrez ce qui suit (plus d'infos sur ce que cela
signifie dans le paragraphe suivant) :

<blockquote><pre>
setw -u automatic-rename
</pre></blockquote>

<p>
Une autre combinaison de touches importante à se souvenir : <i>Ctrl-b ?</i>.
Cela affichera la liste de toutes les touches tmux et commandes qu'il
execute.
Par exemple, <i>Ctrl-b ?</i> montre que la touche <i>c</i> est reliée à la
commande "new-window" et la touche <i>n</i> à la commande "next-window".

<h3>Configurer tmux</h3>

<p>
Beaucoup d'utilisateurs voudront personnaliser l'aspect et le comportement de tmux. 
Cela peut-être réalisé à travers le fichier de configuration <i>~/.tmux.conf</i>.
Ce fichier est une liste de commandes tmux qui sont executées quand tmux est
démarré initialement, avant que la premiére session ne soit crée.
Toutes les commandes tmux sont documentées dans la page man, mais quelques
exemples courant que vous pourrez utiliser dans votre fichier de
configuration sont expliqués ci-dessous.

<p>
La plupart des besoins courants sont la configuration des options.
Il y a deux types d'options dans tmux : <i>options de session</i> et les
<i>options de fenêtre</i>.
Les options de session contrôlent la façon dont sont gérées les options de
session et fenêtre d'une fenêtre individuelle.
Pour l'ensemble il y a un ensemble d'options globales.
Quand tmux vient à décider de la valeur d'une option pour une session
ou fenêtre particuliére, il regarde en premier les options locales de cette
fenêtre; si l'option n'est pas configurée, la valeur de l'option globale est
utilisée.

<p>
Les options de session sont configurées avec la commande "set-option" (alias
"set") et le options de fenêtre avec la commande "set-window-option" (alias "setw"). 
Pour configurer une option globale, utilisez l'argument "-g", si cela n'est
pas précisé l'option est configurée pour la fenêtre ou session courante.
Ces commandes acceptent aussi quelques autres arguments, comme "-u" pour
désactiver une option locale et permettre à une fenêtre ou session d'hériter
à nouveau d'une option globale.

<p>
Dans le fichier de configuration, il est usuel de configurer des options
globales. Regardez ces exemples pour personnaliser la ligne d'état :

<blockquote><pre>
set -g status-bg blue
set -g status-right '#(sysctl vm.loadavg)'
setw -g window-status-current-attr underscore
</pre></blockquote>

<p>
Mettez ces trois commandes dans .tmux.conf et en redémarrant, tmux change
l'arriére-plan de la ligne d'état en bleu, afficher la charge courante sur
le coté droit et souligne la fenêtre courante.
La ligne d'état peut-être désactivée complétement avec :

<blockquote><pre>
set -g status off
</pre></blockquote>

<p>
Il y a un grand nombre d'autres options; un autre exemple est de changer le
style de combinaisons de touche pour ressembler à 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vi&amp;sektion=1">vi(1)</a>
à l'invite de commande
et dans la liste des fenêtres et d'autres modes intéractifs de tmux :

<blockquote><pre>
set -g status-keys vi
setw -g mode-keys vi
</pre></blockquote>

<p>
Les options courantes et leur valeurs seront affichées avec les commandes
"show-options" et "show-window-options".
Comme les commandes de configuration elles acceptent "-g" pour afficher les
options globales.

<p>
Une autre tache courante du fichier de configuration est d'ajouter ou de
modifier des commandes de combinaisons de touches, ce sont les commandes qui
sont éxecutées après avoir pressé <i>Ctrl-b</i> avec une autre touche.
Elles sont ajoutées ou modifiées avec la commande "bind-key" (alias "bind")
et supprimées avec la commande "unbind-key" (alias "unbind").
Voici deux exemples de l'utilisation de "bind-key" :

<blockquote><pre>
bind C-d detach
bind / neww 'exec top'
</pre></blockquote>

<p>
La premiére crée une combinaison pour <i>Ctrl-b Ctrl-d</i> pour détacher
tmux, la même que par défaut <i>Ctrl-b d</i>, et la seconde combinaison
<i>Ctrl-b /</i> pour créer une nouvelle fenêtre éxecutant top.

<p>
Plusieurs personnes aiment utiliser un préfixe différent de <i>Ctrl-b</i>.
Cela peut-être réalisé en utilisant à la fois le "set-option" et les
commandes de combinaison de touche pour altérer l'option de préfixe de
touche et le changer pour qu'en pressant deux fois le préfixe continue de
fournir la même combinaison de touche à travers la fenêtre.
Pour changer le préfixe de touche à <i>Ctrl-a</i> :

<blockquote><pre>
set -g prefix C-a
unbind C-b
bind C-a send-prefix
</pre></blockquote>

<p>
La derniére chose utile à faire dans le fichier de configuration est de
créer un ensemble de fenêtre initiale quand tmux démarre.
C'est un peu plus compliqué que les exemples précédents.
Dans tmux, une session ne peut pas avoir aucune fenêtre, et vous ne pouvez
pas créer de fenêtre sans session.
Donc, pour avoir des fenêtres crées par le fichier de configuration vous
devez en premier créer une session qui les contient.
Par exemple (remarquez que "new" est un alias for la commande "new-session") :

<blockquote><pre>
new -d 'exec top'
neww -d
neww -d
</pre></blockquote>

<p>
Ces commandes créent une nouvelle session avec "top" s'éxecutant dans la
premiére fenêtre, puis crée deux fenêtres additionnelles.
L'argument "-d" indique à tmux de ne pas essayer d'attacher la nouvelle
session ou de faire des nouvelles fenêtres la fenêtre courante.
Avant de mettre ces lignes dans .tmux.conf, il y a un autre problème.
Executé sans arguments, tmux éxecute la commande "new-session", donc quand
on lance tmux avec "tmux" du shell, le fichier de configuration indique à
tmux de créer une session, et la commande du shell lui dit d'en créer une
autre, donc vous avez finalement <i>deux</i> sessions.
Pour éviter cela, tmux doit être démarré avec "tmux attach" quand il doit
créer une session du fichier de configuration - cela signifie qu'il crée la
session de .tmux.conf et l'attache immédiatement sans créer une seconde
session.

<h3>Utilisation avancée de tmux</h3>

Ce paragraphe couvre briévement certaines des fonctionnalités les plus
avancées dans tmux
Consultez la 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1">   
page man</a>
pour plus d'information.

<p>
Dans tmux vous pouvez copier et coller du texte entre les fenêtres.
C'est réalisé en copiant le texte en <i>mode copie</i> puis en le collant
avec la commande coller.
Pour entrer en mode copie, pressez <i>Ctrl-b [</i>.
En mode copie (avec l'option de fenêtre "mode-keys" configurée pour emacs,
pour les touches vi consultez la page man) les touches de fléches doivent
être utilisées pour positionner le curseur, <i>Ctrl-Space</i> débute la
sélection et <i>Ctrl-w</i> copie.
Vous pouvez aussi utiliser <i>Page Up</i>, <i>Page Down</i>, <i>Ctrl-a</i>
et <i>Ctrl-e</i> pour bouger le curseur.
Pressez <i>q</i> ou <i>Escape</i> pour quitter le mode copie.
Après cela, <i>Ctrl-b ]</i> copiera le texte copié dans la fenêtre courante
comme si vous aviez tapé le texte directement.

<p>
tmux est facilement scriptable, et la plupart des commandes qui sont entrées
via l'invite de commande ou reliées à une touche peuvent être éxecutées du
shell.
Presque toutes les commandes tmux acceptent un argument optionnel "-t" qui
spécifie la session ou la fenêtre ou agir.
Par exemple cette commande :

<blockquote><pre>
$ tmux kill-window -t0:1
</pre></blockquote>

tuera la fenêtre 1 dans la session 0.
Et :

<blockquote><pre>
$ tmux new-window -tmysession
</pre></blockquote>

<p>
Crée une nouvelle fenêtre dans la session nommée 'mysession".
Plusieurs commandes acceptent d'autres arguments, par exemple la commande
"new-window" accepte une option "-n" pour donner le nom de la nouvelle
fenêtre, et "new-session" accepte plusieurs arguments pour spécifier les
attributs de la fenêtre initiale crée avec la session.
Ces arguments peuvent être naturellement utilisés quand une commande est
liée à une touche ou éxecutée de l'invite de commande bien évidemment.

<p>
Une autre fonctionnalité utile est la possibilité de couper une fenêtre
unique en plusieurs sections, appelées <i>panes</i>.
En 4.6, vous pouvez découper une fenêtre verticalement (haut en bas) avec la
combinaison de touche  <i>Ctrl-b "</i>.
Un pane peut être redimensionné en haut et bas avec <i>Ctrl-b Alt-Up</i> et
<i>Ctrl-b Alt-Down</i> et le pane actif modifié avec <i>Ctrl-b o</i>.
En plus, une fenêtre découpée de cette façon peut-être modifiée en une parmi
plusieurs mises en page fixes, elles défilent avec <i>Ctrl-b Space</i> mais
les panes utilisant ces mises en page ne peuvent pas être redimensionnées.
En -current, le découpage a été étendu pour supporter le découpage
horizontal (<i>Ctrl-b %</i>) et les mises en page fixes modifiées pour être
appliquées une fois (avec la même combinaison de touche <i>Ctrl-b Space</i>)
mais elles peuvent être librement redimensionnées et modifiées aussi bien
verticalement que horizontalement.
 
<p>
<font color= "#0000e0">
<a href= "index.html">[Index de La FAQ]</a> 
<a href= "faq6.html">[Section 6 - Administration réseau]</a>
<a href= "faq8.html">[Section 8 - Questions diverses ]</a>
</font> 

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" 
border= "0" alt= "[back]"></a> 
<a href= "mailto:www@openbsd.org">www@openbsd.org</a><br>
<small>
<!--
Originally [OpenBSD: faq7.html,v 1.88 ]<br>
$Translation: faq7.html,v 1.46 2010/03/14 20:24:27 benoit Exp $<br>
-->
$OpenBSD: faq7.html,v 1.38 2010/03/19 14:01:23 ajacoutot Exp $
</small>

</body>
</html>

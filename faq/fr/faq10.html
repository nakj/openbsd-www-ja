<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>10 - Gestion du Système</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2009 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">
<a href="../../fr/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[Index de la FAQ]</a>
<a href= "faq9.html">[Section 9 - Migrer vers OpenBSD]</a>
<a href= "faq11.html">[Section 11 - Le système X Window]</a>
</font>

<h1><font color="#e00000">10 - Gestion du Système</font></h1> 
<hr>

<p>
<h3>Table des matières</h3>
<ul>
  <li><a href="#wheel"         >10.1 - Quand j'essaie de passer root à l'aide de su, on me dit que je suis dans le mauvais groupe.</a> 
  <li><a href="#DupFS"         >10.2 - Comment dupliquer un système de fichiers ?</a> 
  <li><a href="#rc"            >10.3 - Comment démarrer des services en même temps que le système ? (Vue d'ensemble de rc(8))</a> 
  <li><a href="#RelayingDenied">10.4 - Pourquoi les utilisateurs sont interdits de relais quand ils envoient des mails à distance à travers mon système OpenBSD ?</a> 
  <li><a href="#POP"           >10.5 - J'ai mis en place POP, mais j'ai des erreurs quand j'accède à ma messagerie via POP. Que puis-je faire ?</a> 
  <li><a href="#SendmailDNS"   >10.6 - Pourquoi Sendmail ignore-t-il le
fichier /etc/hosts ?</a>
  <li><a href="#HTTPS"         >10.7 - Configurer HTTP en mode sécurisé à l'aide de ssl(8)</a> 
  <li><a href="#vipw"          >10.8 - J'ai effectué des changements dans /etc/passwd avec vi(1), mais les changements ne semblent pas être pris en compte. Pourquoi ?</a> 
  <li><a href="#AddDelUser"    >10.9 - Comment je crée un compte utilisateur ? Ou je supprime un compte utilisateur ?</a> 
  <li><a href="#FTPOnly"       >10.10 - Comment puis-je créer un compte pour ftp uniquement ?</a> 
  <li><a href="#Quotas"        >10.11 - Mise en place des quotas </a>
  <li><a href="#Kerberos"      >10.12 - Mise en place de Clients et Serveurs KerberosV</a>
  <li><a href="#AnonFTP"       >10.13 - Mise en place d'un serveur FTP Anonyme</a>
  <li><a href="#ftpchroot"     >10.14 - Confiner les utilisateurs à leur répertoire HOME avec ftpd(8)</a> 
  <li><a href="#Patches"       >10.15 - Appliquer des correctifs sous OpenBSD</a>
  <li><a href="#httpdchroot"   >10.16 - Parlez moi de chroot(2) Apache ?</a>
  <li><a href="#rootshell" >10.17 - Puis-je changer le shell de
      l'utilisateur root ?</a>
  <li><a href="#ksh"           >10.18 - Que puis-je faire d'autre avec ksh ?</a>
  <li><a href="#Dir"           >10.19 - Services d'annuaires</a>
  <ul>
   <li><a href="#Dir.available" >10.19.1 - Quels sont les services d'annuaires 
   disponibles ?</a>
   <li><a href="#YP_secure"     >10.19.2 - Considérations sur la sécurité de YP</a>
   <li><a href="#YP_server"     >10.19.3 - Configurer un serveur YP</a>
   <li><a href="#YP_client"     >10.19.4 - Configurer un client YP</a>
  </ul>
</ul>

<hr>

<p>
<a name= "wheel"></a>
<h2>10.1 - Quand j'essaie de passer root à l'aide de su, on me
    dit que je suis dans le mauvais groupe</h2>

<p> 
Les utilisateurs existant sur le système doivent être rajoutés au groupe
<kbd>"wheel"</kbd> à la main. Ceci est fait pour des raisons
de sécurité, et vous devriez apporter une attention toute particulière
lorsque vous donnez l'accès à ce groupe à des utilisateurs. Sous
OpenBSD, les utilisateurs appartenant au groupe <kbd>wheel</kbd> sont
autorisés à utiliser le programme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1">su(1)</a>
pour devenir root. Les utilisateurs n'appartenant pas au groupe
<kbd>"wheel"</kbd> ne peuvent pas utiliser su(1). Voici un exemple d'une entrée
<kbd>/etc/group</kbd> pour mettre l'utilisateur <b>ericj</b>
dans le groupe <kbd>"wheel"</kbd>.
<p>Si vous ajoutez un utilisateur avec 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>, 
vous pouvez le mettre dans le groupe wheel en répondant wheel à la
question "<tt>Invite <i>user</i> into other groups:</tt>". Ceci aura
pour effet de rajouter l'entrée correspondante dans /etc/group qui
ressemble à la ligne suivante :

<blockquote><pre>
wheel:*:0:root,ericj
</pre></blockquote>

<p>
Si vous cherchez un moyen pour limiter l'accès des utilisateurs aux
privilèges du super utilisateur, sans pour autant les mettre dans le
groupe <kbd>"wheel"</kbd>, utilisez

<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo(8)</a>. 

<p><a name= "DupFS"></a>
<h2>10.2 - Comment dupliquer un système de fichiers ?</h2>

<p>
Pour dupliquer votre système de fichiers, utilisez 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a> 
et 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>. 
Par exemple, pour dupliquer tout ce qu'il y a sous le répertoire
<kbd>SRC</kbd> vers le répertoire <kbd>DST</kbd>, faites un :
<blockquote><pre>
# <b>cd /SRC; dump 0f - . | (cd /DST; restore -rf - )</b>
</pre></blockquote>

<p>
dump est conçu pour vous fournir beaucoup de possibilités de sauvegarde,
et c'est peut-être trop si vous voulez juste dupliquer une partie d'un
système de fichiers (entier). La commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a> 
peut être plus rapide pour ce genre d'opération. Le format est très
similaire à celui de dump :

<blockquote><pre>
# <b>cd /SRC; tar cf -  . | (cd /DST; tar xpf - )</b>
</pre></blockquote>

<p>
<a name= "rc"></a>
<h2>10.3 - Comment démarrer des services en même temps que
    le système ? (Vue d'ensemble de rc(8))</h2>

OpenBSD utilise un démarrage de type 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">rc(8)</a>.
Il utilise seulement quelques fichiers clés pour le démarrage.
<ul>
  <li>/etc/rc - Script principal. Ne doit pas être édité.
  <li>/etc/rc.conf - Fichier de configuration utilisé par
       <i>/etc/rc </i>pour activer les paramêtres 
       démarrés en même temps que le système.
       Ne doit pas être édité.
  <li>/etc/rc.conf.local - Fichier de configuration servant à écraser
       /etc/rc.conf, ainsi vous ne touchez pas à /etc/rc.conf, ce
       qui est important lors de la mise à jour du système.
  <li>/etc/netstart - Script pour initialiser le réseau. Ne devrait pas
       être édité.
  <li>/etc/rc.local - Script utilisé pour l'administration locale. C'est
       là où les informations relatives à de nouveaux services ou des
       informations spécifiques à l'hôte doivent être stockées.
  <li>/etc/rc.securelevel - Script utilisé pour exécuter des commandes
       qui doivent être exécutées avant que le niveau de sécurité ne
       change. Voir
       <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a> 
  <li>/etc/rc.shutdown - Script exécuté lors de l'arrêt de la machine.
       Mettez tout ce que vous voulez exécuter avant l'arrêt de la
       machine dans ce fichier. Voir
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.shutdown&amp;sektion=8">rc.shutdown(8)</a> 
</ul>

<h3>Comment fonctionne rc(8) ?</h3>

<p>
<i>/etc/rc.conf</i> (comme guide), <i>/etc/rc.conf.local</i> (pour les
    changements), <i>/etc/rc.local</i>
    et <i>/etc/rc.shutdown</i> sont les principaux fichiers à connaître
    par l'administrateur système. Pour comprendre le fonctionnement de
    la procédure rc(8), en voici le déroulement :

<p>
<i>/etc/rc </i>est appelé après le démarrage du noyau :
<ul> 
  <li>Les systèmes de fichiers sont vérifiés.
  <li>Les variables de configuration par défaut sont lues à partir de
      <i>/etc/rc.conf</i> et ensuite les changements locaux dans 
      <i>/etc/rc.conf.local</i>. Les
      paramètres dans rc.local.conf vont surpasser ceux se
      trouvant dans rc.conf.
  <li>Les systèmes de fichiers sont montés.
  <li><i>/tmp </i>est nettoyé et les fichiers d'éditeurs sont préservés.
  <li>Le réseau est configuré à l'aide de <i>/etc/netstart</i>
  <ul>
      <li>Les interfaces réseau sont montées.
      <li>Le nom d'hôte et le nom de domaine (ainsi que d'autres
          paramètres) sont positionnés.</ul>
  <li>Les services système sont démarrés.
  <li>Diverses vérifications sont effectuées (quota, savecore, etc).
  <li>Les services locaux sont démarrés à partir de
      <i>/etc/rc.local</i>.
</ul>

<h3>Démarrage des services fournis avec OpenBSD</h3>

<p>
La plupart des services fournis avec OpenBSD sont lancés au
démarrage simplement par des variables définis dans le fichier de configuration
<i>/etc/rc.conf</i>. Pour commencer, jetez un coup d'oeil au fichier
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/etc/rc.conf?content-type=text/plain">/etc/rc.conf</a> 
par défaut. Vous verrez des lignes similaires à la ligne suivante :
 
<blockquote><pre>
ftpd_flags=NO           # for non-inetd use: ftpd_flags="-D"
</pre></blockquote>

<p>
Une ligne telle que celle-ci montre que 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>
n'est pas lancé au démarrage du système (du moins pas à travers rc(8);
ftpd est souvent démarré via 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>
lisez la <a href="faq10.html#AnonFTP">FAQ Serveur FTP Anonyme</a> pour plus
d'informations). 
Chaque ligne est dotée d'un commentaire qui vous montrent les drapeaux 
utilisés dans le cadre d'une utilisation <b>NORMALE </b>du service ou du
daemon. 
Cela ne veut pas dire que vous
devez appeler ce service avec ces mêmes drapeaux. Lisez la page man
correspondante pour savoir comment démarrer un service ou daemon donné de la
manière que vous souhaitez. 

<p>
Nous vous suggerons fortement de ne jamais toucher au fichier <i>/etc/rc.conf</i> 
lui-même.
A la place, créez un fichier <i>/etc/rc.conf.local</i>, copiez juste les
lignes que vous désirez modifier de <i>/etc/rc.conf</i> et ajustez les à
votre convenance. 
Cela permettra de faire les futures mises à jour simplement -- tous les
changements seront dans un seul fichier.
En fait, le <a href="../upgrade46.html">processus de mise à jour</a> standard
considère que vous n'avez pas modifié <i>/etc/rc.conf</i>, et l'écrasera
avec la nouvelle version.

<p>
Par exemple, voici la ligne par défaut concernant httpd(8) :
<blockquote><pre>
httpd_flags=NO          # for normal use: "" (or "-DSSL" after reading ssl(8))
</pre></blockquote>

<p>
D'après cet exemple, vous pouvez voir qu'aucun drapeau n'est nécessaire
pour démarrer httpd normalement. Ainsi, la ligne "<tt> httpd_flags=""</tt>
ajoutées à <i>/etc/rc.conf.local</i> suffit. 
Mais pour démarrer httpd avec le support ssl (Reportez vous à la
<a href="#HTTPS">FAQ SSL</a> ou à
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>
), vous devez démarrer httpd avec une ligne comme celle-ci : <tt>"httpd_flags="-DSSL"</tt>,
et vous pouvez aussi ajouter d'autres paramétres pour d'autres raisons.

<h3>Démarrage et configuration des services locaux</h3>

<p>
Pour les services que vous installez via les paquetages ou
d'autres méthodes, vous devez utiliser le fichier
<i>/etc/rc.local</i>. Par exemple, j'ai installé un service
fourni par l'applicatif /usr/local/sbin/daemonx. Je souhaite que ce
service soit lancé au démarrage. Pour cela, je rajoute les lignes
suivantes dans <i>/etc/rc.local</i> :

<blockquote><pre>
if [ -x /usr/local/sbin/daemonx ]; then
             echo -n ' daemonx';       /usr/local/sbin/daemonx
fi
</pre></blockquote>

<p>
(Si le service ne se détache pas automatiquement lors de son démarrage,
souvenez-vous de rajouter "&amp;" à la fin de la commande.)

<p>
A partir de là, ce service sera lancé au démarrage. Vous pourrez voir
toutes les erreurs au démarrage. Un démarrage normal sans erreurs
affichera le message suivant :
<blockquote><pre>
Starting local daemons: daemonx.
</pre></blockquote>

<h3>rc.shutdown</h3>

<p>
<i>/etc/rc.shutdown</i> est un script exécuté à l'arrêt de la machine.
Toutes les tâches à effectuer avant l'arrêt du système devront être
ajoutées à ce fichier. Si vous avez apm, vous pouvez aussi positionner
"powerdown=YES". C'est l'équivalent de "shutdown -p".

<p>
<a name= "RelayingDenied"></a>
<h2>10.4 - Pourquoi les utilisateurs sont interdits de relais quand ils
    envoient des mails à distance à travers mon système OpenBSD ?</h2>

<p> 
Essayez ceci : 

<blockquote><pre>
# <b>grep relay-domains /etc/mail/sendmail.cf</b>
</pre></blockquote>

<p>
Le résultat ressemblerait à la ligne suivante :

<blockquote><pre>
FR-o /etc/mail/relay-domains
</pre></blockquote>

<p>
Si ce fichier n'existe pas, créez le. Vous devez saisir les hôtes qui
envoient des messages à distance en respectant la syntaxe suivante :

<blockquote><pre>
.domain.com    #Allow relaying for/to any host in domain.com
sub.domain.com #Allow relaying for/to sub.domain.com and any host in that domain
10.2           #Allow relaying from all hosts in the IP net 10.2.*.*
</pre></blockquote>

<p>
N'oubliez pas d'envoyer un signal 'HangUP' à sendmail (signal qui
notifie la plupart des processus de relire leur fichier de
configuration) :

<blockquote><pre>
# <b>kill -HUP `head -1 /var/run/sendmail.pid`</b>
</pre></blockquote>

<p>
<h3>Pour plus d'informations </h3>

<p>
<ul>
<li><a href="http://www.sendmail.org/~ca/email/relayingdenied.html">http://www.sendmail.org/~ca/email/relayingdenied.html</a>
<li><a href="http://www.sendmail.org/tips/relaying.php">http://www.sendmail.org/tips/relaying.html</a>
<li><a href="http://www.sendmail.org/antispam/">http://www.sendmail.org/antispam.html</a>
</ul>

<p>
<a name= "POP"></a>
<h2>10.5 - J'ai mis en place POP, mais j'ai des erreurs quand
    j'accède à ma messagerie via POP. Que puis-je faire ? </h2>

<p>
La plupart des problèmes rencontrés avec POP sont liés aux fichiers
temporaires et aux fichiers verrous. Si votre serveur POP renvoie une
erreur du type :

<blockquote><pre>
-ERR Couldn't open temporary file, do you own it?
</pre></blockquote>

<p>
Essayez de positionner les permissions comme suit :

<blockquote><pre>
permission in  /var
drwxrwxr-x   2 bin     mail     512 May 26 20:08 mail


permissions in  /var/mail
-rw-------   1 username   username        0 May 26 20:08 username
</pre></blockquote>

<p>
Vérifiez aussi que l'utilisateur possède son propre fichier /var/mail.
Bien évidemment, ceci devrait être le cas (comme par exemple
l'utilisateur joe qui possède /var/mail/joe) mais si ça n'a pas été
configuré proprement, le problème viendrait de là !

<p>
Bien entendu, si vous donner l'accès à /var/mail en écriture au groupe
mail, vous allez probablement vous exposer à des vagues et obscurs
problèmes de sécurité. Il se pourrait que ça ne pose aucun problème mais
on ne sait jamais (et particulièrement si vous êtes un site de haut vol,
un FAI,...) ! Il existe plusieurs services POP de la collection de ports
OpenBSD. Si possible, utilisez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=popa3d&amp;sektion=8">popa3d(8)</a> 
disponible dans le système de base d'OpenBSD. Ou peut-être vous avez
sélectionné les mauvaises options pour votre programme POP serveur
(comme le dot locking). Ou vous avez peut-être simplement besoin de
changer le répertoire dans lequel les verrous sont crées (bien que les
opérations de verrouillage ne devraient être bénéfiques qu'au service
POP).

<p>
<b>Note :</b> Il est à noter que OpenBSD n'a pas de groupe "mail". Vous
   devez en créer un, si nécessaire, dans le fichier <i>/etc/group</i>.
   La ligne suivante devrait suffire :

<blockquote><pre>
mail:*:6:
</pre></blockquote>

<p>
<a name="SendmailDNS"></a>
<h2>10.6 - Pourquoi Sendmail ignore-t-il le fichier <tt>/etc/hosts</tt>
    ?</h2>

<p>
Par défaut, Sendmail utilise le DNS pour la résolution de nom, non le
fichier <tt>/etc/hosts</tt>. Ce comportement peut être changé par
l'usage du fichier <tt>/etc/mail/service.switch</tt>.

<p>
Si vous désirez interroger le fichier d'hôtes avant les serveurs DNS,
créez un fichier <tt>/etc/mail/service.switch</tt> contenant les lignes
suivantes :

<blockquote><pre>
hosts       files dns
</pre></blockquote>

<p>
Si vous désirez n'interroger QUE le fichier d'hôtes, utilisez ce qui
suit :

<blockquote><pre>
hosts       files
</pre></blockquote>

<p>
Envoyez un signal HUP à Sendmail :

<blockquote><pre>
# <b>kill -HUP `head -1 /var/run/sendmail.pid`</b>
</pre></blockquote>

<p>
et les changements prendront effet.


<p>
<a name= "HTTPS"></a>
<h2>10.7 - Configurer HTTP en mode sécurisé à
    l'aide de SSL(8)</h2>

<p>
OpenBSD est fourni avec des bibliothèques RSA et un service httpd
supportant SSL. Pour utiliser SSL avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>, 
vous devez d'abord créer un certificat. Ce certificat sera stocké dans
<i>/etc/ssl</i> avec la clef correspondante dans <i>/etc/ssl/private/</i>.
Les étapes décrites ici sont en partie prises de la page de manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>. 
Lisez la pour plus d'informations. Cette partie de la FAQ s'intéresse
seulement à la génération d'un certificat RSA pour les serveurs Web.
Elle ne décrit pas les certificats serveur DSA. Pour plus d'informations
à ce sujet, lisez la page de manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>.

<p>
Pour commencer, vous aurez besoin de créer votre clé serveur et le
certificat en utilisant OpenSSL :

<blockquote><pre>
# <b>openssl genrsa -out /etc/ssl/private/server.key 1024</b>
</pre></blockquote>

<p>
Ou si vous voulez que la clé soit cryptée avec un mot de passe que vous
devez saisir à chaque démarrage des serveurs

<blockquote><pre>
# <b>openssl genrsa -des3 -out /etc/ssl/private/server.key 1024</b>
</pre></blockquote>

<p>
La prochaine étape consiste à générer une requête de signature de
certificat qui est utilisée pour permettre à une autorité de
certification (CA) de signer votre certificat. Pour cela, utilisez la
commande suivante :

<blockquote><pre>
# <b>openssl req -new -key /etc/ssl/private/server.key -out /etc/ssl/private/server.csr</b>
</pre></blockquote>

<p>
Le fichier <i>server.csr</i> pourra alors être communiqué à une autorité
de certification qui signera la clé. Une de ces autorités est <b>Thawte
Certification</b> que vous pourrez joindre à l'adresse
<a href="http://www.thawte.com/">http://www.thawte.com/</a>.

<p>
Si vous ne pouvez pas vous permettre un tel service, ou si vous voulez
auto signer le certificat, vous pouvez utiliser la commande suivante :

<blockquote><pre>
# <b>openssl x509 -req -days 365 -in /etc/ssl/private/server.csr \
       -signkey /etc/ssl/private/server.key -out /etc/ssl/server.crt</b>
</pre></blockquote>

<p> 
Avec <i>/etc/ssl/server.crt</i> et <i>/etc/ssl/private/server.key</i>,
vous devez être désormais capable de démarrer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a> 
avec le drapeau <b>-DSSL</b> (consultez la
<a href="#rc">section à propos de rc(8) dans cette faq</a>), activant
ainsi les transactions https sur le port 443 de votre machine.

<p>
<a name= "vipw"></a>
<h2>10.7 - J'ai effectué des changements dans /etc/passwd avec
    vi(1), mais les changements ne semblent pas être pris en compte.
    Pourquoi ?</h2>

<p>
Si vous éditez <i>/etc/passwd</i>, vos modifications seront perdues.
OpenBSD génère <i>/etc/passwd</i> dynamiquement avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pwd_mkdb&amp;sektion=8">pwd_mkdb(8)</a>. 
Le fichier principal de mots de passe sous OpenBSD est
<i>/etc/master.passwd</i>. D'après pwd_mkdb(8),

<blockquote><pre>
FILES
     /etc/master.passwd  fichier courant de mots de passe 
     /etc/passwd         fichier de mots de passe au style "6th Edition"
     /etc/pwd.db         fichier non sécurisé de mots de passe au format base de données
     /etc/pwd.db.tmp     fichier temporaire
     /etc/spwd.db        fichier sécurisé de mots de passe au format base de données
     /etc/spwd.db.tmp    fichier temporaire
</pre></blockquote>

<p>
Dans un fichier de mots de passe Unix traditionnel, toutes les
informations y compris le mot de passe crypté de l'utilisateur sont à la
disposition de n'importe quel utilisateur du système (et c'est la cible
principale de programmes tels que Crack). 4.4BSD a introduit le fichier
master.passwd qui a un format étendu (avec les options additionnelles
par rapport à /etc/passwd). Ce fichier n'est accessible que pour root.
Pour un accès plus rapide aux données, les appels à la bibliothèque qui
utilisent ce type d'informations accèdent normalement à /etc/pwd.db et à
/etc/spwd.db.

<p>
OpenBSD met à votre disposition un outil qui vous permet d'éditer le
fichier de mots de passe. Cet outil s'appelle 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vipw&amp;sektion=8">vipw(8)</a>. 
vipw utilisera vi
(ou votre éditeur favori tel que défini par $EDITOR) pour éditer
/etc/master.passwd. Suite à vos modifications, vipw recréera
/etc/passwd, /etc/pwd.db et /etc/spwd.db qui tiendront compte de vos
modifications. vipw verrouille aussi l'accès à ces fichiers de telle
façon à en interdire l'accès à quiconque essaie d'en changer le contenu
en même temps que vous.

<p>
<a name= "AddDelUser"></a>
<h2>10.8 - Comment je crée un compte utilisateur ? Ou je supprime
    un compte utilisateur ?</h2>

<p>
OpenBSD offre deux commandes pour facilement créer des comptes
utilisateurs sur le système :
<ul>
        <li><a href="#adduser">adduser(8)</a>
        <li><a href="#user">user(8)</a>
</ul>

Il est toujours possible de créer des utilisateurs à la main en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vipw&amp;sektion=8">vipw(8)</a>,
mais cela complique la plupart des étapes.

<a name="adduser"></a> 
<p>
La manière la plus facile pour créer un compte utilisateur sous OpenBSD
est d'utiliser le script
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>.
Ce script est paramétrable à travers le fichier <i>/etc/adduser.conf</i>. 
adduser(8) permet d'effectuer des vérifications sur la cohérence de
<i>/etc/passwd</i>, <i>/etc/group</i> et les bases de données shell.
adduser(8) crée pour vous les entrées correspondantes et les répertoires
$HOME. Il peut aussi envoyer un message de bienvenue aux utilisateurs.
Le comportement de ce programme peut être adapté à vos besoins. Pour
illustrer notre propos, prenons comme exemple la création du compte
<b>testuser</b>. Le répertoire de cet utilisateur sera
<i>/home/testuser</i>. L'utilisateur fera partie du groupe <b>guest
</b>comme groupe et aura un shell <i>/bin/ksh </i>.

<blockquote><pre>
# <b>adduser</b>
Use option ``-silent'' if you don't want to see all warnings and questions.

Reading /etc/shells
Reading /etc/login.conf
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username []: <b>testuser</b>
Enter full name []: <b>Test FAQ User</b>
Enter shell csh ksh nologin sh [sh]: <b>ksh</b>
Uid [1002]: <b><i>Entrée</i></b>
Login group testuser [testuser]: <b>guest</b>
Login group is ``guest''. Invite testuser into other groups: guest no 
[no]: <b>no</b>
Login class auth-defaults auth-ftp-defaults daemon default staff 
[default]: <b><i>Entrée</i></b>
Enter password []: <b><i>Type password, then Enter</i></b>
Enter password again []: <b><i>Type password, then Enter</i></b>

Name:        testuser
Password:    ****
Fullname:    Test FAQ User
Uid:         1002
Gid:         31 (guest)
Groups:      guest
Login Class: default
HOME:        /home/testuser
Shell:       /bin/ksh
OK? (y/n) [y]: <b>y</b>
Added user ``testuser''
Copy files from /etc/skel to /home/testuser
Add another user? (y/n) [y]: <b>n</b>
Goodbye!
</pre></blockquote>

<p>
Pour supprimer des comptes utilisateurs, utilisez la commande 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rmuser&amp;sektion=8">rmuser(8)</a>. 
Cette commande supprimera toute chose relative à l'utilisateur. Elle
supprimera son entrée
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crontab&amp;sektion=1">crontab(1)</a>, 
son répertoire $HOME (s'il lui appartient) et son courrier. Bien
évidemment, cette commande supprimera aussi les entrées correspondantes
dans <i>/etc/passwd</i> et <i>/etc/group</i>. Comme exemple, nous allons
utiliser cette commande pour supprimer le compte utilisateur
précédemment crée. Notez que la commande vous demande l'identifiant du
compte et si oui ou non elle doit supprimer le répertoire home de
l'utilisateur.

<blockquote><pre>
# <b>rmuser</b>
Enter login name for user to remove: <b>testuser</b>
Matching password entry:

testuser:$2a$07$ZWnBOsbqMJ.ducQBfsTKUe3PL97Ve1AHWJ0A4uLamniLNXLeYrEie:1002
:31::0:0:Test FAQ User:/home/testuser:/bin/ksh

Is this the entry you wish to remove? <b>y</b>
Remove user's home directory (/home/testuser)? <b>y</b>
Updating password file, updating databases, done.
Updating group file: done.
Removing user's home directory (/home/testuser): done.
</pre></blockquote>

<a name="user"></a>
<h3>Créer des comptes utilisateurs via user(8)</h3>

<p>
Ces outils sont moins interactifs que la commande 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>, 
ce qui en facilite l'usage dans des scripts.

<p>
La liste complète des outils est :
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=group&amp;sektion=8">group(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupadd&amp;sektion=8">groupadd(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupdel&amp;sektion=8">groupdel(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupinfo&amp;sektion=8">groupinfo(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupmod&amp;sektion=8">groupmod(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=user&amp;sektion=8">user(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=useradd&amp;sektion=8">useradd(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=userdel&amp;sektion=8">userdel(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=userinfo&amp;sektion=8">userinfo(8)</a> 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=usermod&amp;sektion=8">usermod(8)</a> 
</ul>

<h4>Création effective des comptes utilisateurs</h4>

<p>
Etant donné que la commande user(8) n'est pas interactive, la manière la
plus simple et la plus efficace pour créer des comptes utilisateurs est
d'utiliser la commande adduser(8). La commande <i>/usr/sbin/user</i> est
seulement une interface aux autres commandes <i>/usr/sbin/user*</i>.
Ainsi, dans l'exemple qui suit il est possible d'utiliser soit <b>user
add</b> soit <b>useradd</b>. Le choix est votre et ne change rien au
résultat. <p>Dans cet exemple, nous allons créer un compte avec les
mêmes spécificités que le compte crée
<a href="#adduser">précédemment</a>. useradd(8) est bien plus facile à
utiliser si vous connaissez les paramètres par défaut avant de créer un
compte utilisateur. Ces paramètres se trouvent dans le fichier
<i>/etc/usermgmt.conf </i>et peuvent être visualisés comme suit :

<blockquote><pre>
$ <b>user add -D</b>
group           users
base_dir        /home
skel_dir        /etc/skel
shell           /bin/csh
inactive        0
expire          Null (unset)
range           1000..60000
</pre></blockquote>

<p>
Ces paramètres vont être appliqués à chaque nouveau compte si vous ne
changez pas leur valeur en utilisant des options en ligne de commande.
Par exemple, dans notre cas nous voulons que l'utilisateur appartienne
au groupe <b>guest </b> et non pas à <b>users</b>. Il est à noter que
lors de la création des comptes utilisateurs, les mots de passe doivent
être spécifiés sous leur forme cryptée en ligne de commande. Vous devez
donc utiliser, au préalable, l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=encrypt&amp;sektion=1">encrypt(1)</a> 
pour créer le mot de passe. Par exemple : Les mots de passe par défaut
sous OpenBSD utilisent l'algorithme Blowfish avec 6 réitérations. Voici
un exemple d'utilisation de la commande encrypt :

<blockquote><pre>
$ <b>encrypt -p -b 6</b>
Enter string:
$2a$06$YOdOZM3.4m6MObBXjeZtBOWArqC2.uRJZXUkOghbieIvSWXVJRzlq
</pre></blockquote>

<p> 
Maintenant que nous avons le mot de passe crypté, nous sommes prêts à
créer le compte utilisateur :

<blockquote><pre>
# <b>user add -p '$2a$06$YOdOZM3.4m6MObBXjeZtBOWArqC2.uRJZXUkOghbieIvSWXVJRzlq' -u 1002 \
-s /bin/ksh -c "Test FAQ User" -m -g guest testuser</b>
</pre></blockquote>

<p>
<b>Remarque :</b> Assurez vous d'utiliser " pour englober le mot de
   passe. L'utilisation de "" ne permet pas d'empêcher le shell
   d'interpréter le jeu de caractères correspondant au mot de passe
   avant de les communiquer à user(8). De même, assurez vous d'utiliser
   l'option <b>-m </b>si vous voulez créer le répertoire $HOME de
   l'utilisateur et copier les fichiers à partir de <i>/etc/skel</i>
   vers $HOME.

<p>
Pour voir si le compte utilisateur a été correctement crée, nous pouvons
recourir à plusieurs utilitaires. Voici quelques commandes pour vérifier
rapidement que tout s'est bien passé :

<blockquote><pre>
$ <b>ls -la /home</b>
total 14
drwxr-xr-x   5 root      wheel   512 May 12 14:29 .
drwxr-xr-x  15 root      wheel   512 Apr 25 20:52 ..
drwxr-xr-x  24 ericj     wheel  2560 May 12 13:38 ericj
drwxr-xr-x   2 testuser  guest   512 May 12 14:28 testuser
$ <b>id testuser</b>
uid=1002(testuser) gid=31(guest) groups=31(guest)
$ <b>finger testuser</b>
Login: testuser                         Name: Test FAQ User
Directory: /home/testuser               Shell: /bin/ksh
Last login Sat Apr 22 16:05 (EDT) on ttyC2
No Mail.
No Plan.
</pre></blockquote>

<p>
En plus de ces commandes, user(8) fournit son propre utilitaire, appelé
userinfo(8), qui permet d'afficher les caractéristiques d'un compte
utilisateur :

<blockquote><pre>
$ <b>userinfo testuser</b>
login   testuser
passwd  *
uid     1002
groups  guest
change  Wed Dec 31 19:00:00 1969
class
gecos   Test FAQ User
dir     /home/testuser
shell   /bin/ksh
expire  Wed Dec 31 19:00:00 1969
</pre></blockquote>

<h4>Suppression des comptes utilisateurs</h4>

<p>
Pour supprimer des comptes utilisateurs avec la hiérarchie de commandes
user(8), vous devez utiliser userdel(8). Cette commande est simple et
efficace. Pour supprimer le compte précédemment crée, utilisez :

<blockquote><pre>
# <b>userdel -r testuser</b>
</pre></blockquote>

<p>
Notez bien l'option <b>-r</b> qui doit être spécifiée si vous voulez
supprimer les répertoires $HOME aussi. Si vous voulez juste bloquer
l'accès au compte sans supprimer des informations liées au compte,
utilisez <b>-p</b> au lieu de <b>-r</b>.

<p>
<a name= "FTPOnly"></a>
<h2>10.10 - Comment puis-je créer un compte pour ftp uniquement
    ?</h2>

<p>
Il y a plusieurs méthodes pour effectuer cette opération.
Une des manières les plus communes est d'ajouter
<tt>/usr/bin/false</tt>" à "<tt>/etc/shells</tt>".
A partir de là, lorsque vous affectez "<tt>/usr/bin/false</tt>" à un
utilisateur, il ne sera plus capable d'ouvrir une session interactive
sur le système, néanmoins il pourra utiliser le service ftp.
Vous souhaiterez peut-être aussi restreindre l'accès en
<a href="#ftpchroot">Confiner les utilisateurs à leur répertoire HOME avec ftpd(8)</a>.

<p>
<a name= "Quotas"></a>
<h2>10.11 - Mise en place des quotas</h2>

<p>
Les quotas sont utilisés pour limiter l'espace disque disponible pour
les utilisateurs. Ce système peut être très utile si vous avez des
ressources limitées. Les quotas peuvent être configurés par utilisateur
et/ou par groupe.


<p>
La première étape pour configurer les quotas est de s'assurer que
<tt>option QUOTA</tt> est présente dans votre
<a href="faq5.html#Options">configuration noyau</a>. Cette option est
incluse dans le noyau GENERIC. Ensuite, vous aurez besoin de marquer les
systèmes de fichiers où les quotas sont utilisés dans le fichier

<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5"><tt>/etc/fstab</tt></a>. 
Les mots clés <tt>userquota</tt> et <tt>groupquota</tt> doivent être
utilisés pour marquer chaque système de fichiers où les quotas sont
activés. Par défaut, les fichiers <tt>quota.user</tt> et
<tt>quota.group</tt> seront crées à la racine des systèmes de fichiers
où les quotas sont utilisés pour stocker les informations relatives à
ces derniers. Si vous voulez les créer ailleurs, spécifiez un fichier
avec l'option des quotas dans <tt>/etc/fstab</tt>, par exemple
"<tt>userquota=/var/quotas/quota.user</tt>". Voici un exemple de
<tt>/etc/fstab</tt> avec un système de fichiers avec quotas activés et
le fichier de quotas se trouvant dans un endroit non-standard :

<blockquote><pre>
/dev/wd0a / ffs rw,userquota=/var/quotas/quota.user 1 1
</pre></blockquote>

<p>
Maintenant, il faut configurer les quotas par utilisateur. A cette fin,
nous utilisons la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=edquota&amp;sektion=8">edquota(8)</a>. 
Une utilisation simple est "<tt>edquota&nbsp;&lt;user&gt;</tt>".
edquota(8) va utiliser vi(1) pour éditer les quotas à moins que la
variable d'environnement EDITOR est positionnée pour charger un autre
éditeur. Par exemple la commande :

<blockquote><pre>
# <b>edquota ericj</b>
</pre></blockquote>

<p>
Affichera un résultat similaire à :

<blockquote><pre>
Quotas for user ericj:
/: KBytes in use: 62, limits (soft = 0, hard = 0)
        inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

<p>
Pour ajouter des limites, éditer là pour donner un résultat similaire à
:

<blockquote><pre>
Quotas for user ericj:
/: KBytes in use: 62, limits (soft = 1000, hard = 1050)
        inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

<p>
Notez que l'allocation de quotas est en blocs de 1k. Dans ce cas-ci,
softlimit est fixé à 1000k et hardlimit à 1050k. softlimit est une
limite qui permet au système de prévenir les utilisateurs quand ils
l'ont dépassé. Ils auront alors jusqu'à la fin de leur période de grâce
pour redescendre en dessous de cette limite. Les périodes de grâce
peuvent être configurées à l'aide de l'option <b>-t</b> de edquota(8).
Après la fin de la période de grâce, softlimit est géré comme hardlimit.
Ce qui cause un échec d'allocation.

<p>
Une fois les quotas configurés, il faut les activer. Pour cela, utilisez
la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quotaon&amp;sektion=8">quotaon(8)</a>. 
Par exemple :

<blockquote><pre>
# <b>quotaon -a</b>
</pre></blockquote>

<p>
Cette commande analysera le contenu de <tt>/etc/fstab</tt> et activera
les quotas sur les systèmes de fichiers où les options de quota sont
positionnées. Maintenant que les quotas sont activés, vous pouvez les
visualiser à l'aide de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quota&amp;sektion=1">quota(1)</a>. 
Ainsi, la commande "<tt>quota &lt;user&gt;</tt>" fournit les
informations concernant cet utilisateur. Si aucun argument n'est
utilisé, quota vous fournira des statistiques sur les quotas. Par
exemple :

<blockquote><pre>
# <b>quota ericj</b>
</pre></blockquote>

<p>
Afficherait :

<blockquote><pre>
Disk quotas for user ericj (uid 1001): 
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
              /      62    1000    1050              27       0       0        
</pre></blockquote>

<p>
Par défaut, les quotas positionnés dans <tt>/etc/fstab</tt> seront
activés au démarrage. Pour les désactiver, utilisez :

<blockquote><pre>
# <b>quotaoff -a</b>
</pre></blockquote>

<p>
<a name= "Kerberos"></a>
<h2>10.12 - Mise en place de Clients et Serveurs KerberosV</h2>

<p>
OpenBSD inclut KerberosV comme un composant pré-installé sur le système
par défaut.

<p>
Pour plus d'information concernant KerberosV, sur votre système OpenBSD,
utilisez la commande :

<blockquote><pre>
  # <b>info heimdal</b>
</pre></blockquote>

<p>
<a name= "AnonFTP"></a>
<h2>10.13 - Mise en place d'un serveur FTP Anonyme</h2>

<p>
Le mode FTP anonyme permet à des utilisateurs sans compte d'accéder aux
fichiers sur votre machine en utilisant le protocole de transfert de
fichiers. Ce chapitre a pour but de fournir une vue d'ensemble de la
configuration d'un serveur FTP anonyme, les logs générés, etc...

<h3>Création du compte FTP</h3>

<p>
La première étape consiste à créer un compte <i>ftp</i> sur votre
système. Ce compte ne doit pas avoir de mot de passe utilisable. Dans
cet exemple, nous allons considérer que /home/ftp est le répertoire
correspondant au compte "ftp" mais vous n'êtes pas obligé de choisir la
même chose. Quand le mode anonyme est utilisé, le service ftp va se
confiner au répertoire HOME de l'utilisateur <i>ftp</i> (dans notre cas,
ce répertoire est /home/ftp). Pour en savoir plus, lisez les pages du
manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a> 
et 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>. 
Voici un exemple de création du compte <i>ftp</i> en utilisant la
commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>. 
Au préalable, nous avons besoin d'ajouter /usr/bin/false au fichier
<i>/etc/shells</i>. C'est le shell que nous allons attribuer à
l'utilisateur <i>ftp</i>. Il ne permettra pas de connexion en login à ce
compte
même si nous configurons un mot de passe vide. Pour effectuer cette
opération, il suffit de faire

<blockquote><pre>
echo /usr/bin/false &gt;&gt; /etc/shells
</pre></blockquote>

Ensuite vous êtes prêt pour ajouter l'utilisateur <i>ftp</i>.

<blockquote><pre>
# <b>adduser</b>
Use option ``-silent'' if you don't want to see all warnings and questions.

Reading /etc/shells
Reading /etc/login.conf
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username []: <b>ftp</b>
Enter full name []: <b>anonymous ftp</b>
Enter shell csh false ksh nologin sh tcsh zsh [sh]: <b>false</b>
Uid [1002]: <b><i>Entrée</i></b>
Login group ftp [ftp]: <b><i>Entrée</i></b>
Login group is ``ftp''. Invite ftp into other groups: guest no 
[no]: <b>no</b>
Login class auth-defaults auth-ftp-defaults daemon default staff 
[default]: <b><i>Entrée</i></b>
Enter password []: <b><i>Entrée</i></b>
Set the password so that user cannot logon? (y/n) [n]: <b>y</b>

Name:        ftp
Password:    ****
Fullname:    anonymous ftp
Uid:         1002
Gid:         1002 (ftp)
Groups:      ftp
Login Class: default
HOME:        /home/ftp
Shell:       /usr/bin/false
OK? (y/n) [y]: <b>y</b>
Added user ``ftp''
Copy files from /etc/skel to /home/ftp
Add another user? (y/n) [y]: <b>n</b>
Goodbye!
</pre></blockquote>

<h3>Configuration du répertoire</h3>

<p>
L'opération a crée, en plus de l'utilisateur, le répertoire
<i>/home/ftp</i>. C'est ce que nous voulons mais nous avons besoin
d'effectuer quelques modifications pour préparer le système à héberger
le service FTP anonyme. Ces modifications sont expliquées dans la page
du manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>.

<p>
<b>Vous n'avez pas besoin</b> de créer un répertoire /home/ftp/usr ou
/home/ftp/bin.

<ul>
<li><i>/home/ftp</i> - C'est le répertoire principal. Il doit être
    possédé par root avec les permissions 555.
<li><i>/home/ftp/etc</i> - Ce répertoire est optionnel et non
    recommandé. Son seul but est de fournir des informations sur les
    comptes utilisateurs existant. Si vous voulez que les fichiers de
    votre répertoire de ftp soient associés à de vrais utilisateurs,
    vous devez copier /etc/pwd.db et /etc/group dans ce répertoire. Les
    permissions du répertoire doivent être 511. Les permissions sur les
    deux fichiers doivent être 444. Ils sont utilisés pour fournir une
    correspondance entre des nombres et les noms attribués aux comptes
    utilisateurs et groupes. Il n'y a pas de mots de passe dans pwd.db.
    Tous les mots de passe sont stockés dans spwd.db alors ne copiez pas
    ce fichier.
<li><i>/home/ftp/pub</i> - C'est le répertoire standard pour mettre les
    fichiers que vous voulez partagez. Ce répertoire doit avoir les
    permissions 555.
</ul>

<p>
Il est à noter que tous ces répertoires doivent être la propriété de
"root". Voici à quoi doivent ressembler les répertoires après leur
création :

<blockquote><pre>
# pwd 
/home
# ls -laR ftp
total 5
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 .
drwxr-xr-x  7 root  wheel  512 Jul  6 10:58 ..
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 etc
dr-xr-xr-x  2 root  ftp    512 Jul  6 11:33 pub

ftp/etc:
total 43
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 .
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 ..
-r--r--r--  1 root  ftp    316 Jul  6 11:34 group
-r--r--r--  1 root  ftp  40960 Jul  6 11:34 pwd.db

ftp/pub:
total 2
dr-xr-xr-x  2 root  ftp  512 Jul  6 11:33 .
dr-xr-xr-x  5 root  ftp  512 Jul  6 11:33 ..
</pre></blockquote>

<h3>Démarrage du serveur et logs</h3>

<p>
Vous pouvez choisir d'exécuter ftpd soit à partir de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>
soit de le lancer directement via les scripts <a href="#rc">rc</a>. Les
exemples suivants vous montreront le service lancé via inetd.conf. Tout
d'abord, nous devons nous familiariser avec quelques options de ftpd. La
ligne par défaut dans <i>/etc/inetd.conf</i> est :

<blockquote><pre>
<b>ftp             stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -US</b>
</pre></blockquote>

<p>
Comme vous pouvez le voir, ftpd est invoqué avec <i>-US</i>. Ces options
vont permettre de loguer les connexions anonymes dans
<i>/var/log/ftpd </i>et les sessions courantes dans
<i>/var/run/utmp</i>. Ce qui permet de voir ces sessions via who(1).
Dans certains cas, on souhaitera fournir un accès anonyme et désactiver
ftp pour les utilisateurs du système. Pour cela, il faut utiliser
l'option <i>-A </i>de ftpd. Voici une ligne d'invocation de ftpd en mode
anonyme exclusif. On utilise aussi <i>-ll</i> qui logue chaque connexion
vers syslog en plus des commandes ftp get, retrieve, etc...

<blockquote><pre> 
<b>ftp             stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -llUSA</b>
</pre></blockquote>

<p> 
<b>Note</b> : Les personnes gérant des serveurs ftp à HAUT trafic ne
devraient pas invoquer ftpd à partir de inetd.conf. La meilleure option
consiste à commenter la ligne correspondant à ftpd dans /etc/inetd.conf
et à démarrer ftpd à partir de rc.conf.local avec l'option <i>-D</i>. Ce
qui va démarrer ftpd en tant que service. Ce mode de fonctionnement est
beaucoup moins coûteux et plus rapide que le démarrage via inetd. La
ligne correspondant à ftpd dans rc.conf.local ressemblerait à :

<blockquote><pre>
ftpd_flags="-DllUSA"           # for non-inetd use: ftpd_flags="-D"
</pre></blockquote>

<p>
Bien évidemment, cette méthode ne fonctionnera que si ftpd est commenté
dans <i>/etc/inetd.conf</i> et en veillant qu'inetd ait bien relu son
fichier de configuration.

<h3>Autres fichiers importants </h3>

<ul>
<li><i>/etc/ftpwelcome</i> - Ce fichier contient le message de bienvenue
    qui sera affiché aux personnes qui se connectent sur votre serveur
    ftp.
<li><i>/etc/motd</i> - Ce fichier contient le message qui sera affiché
    aux utilisateurs une fois authentifiés sur votre serveur ftp.
<li><i>.message</i> - Ce fichier peut être mis dans n'importe quel
    répertoire. Il contient un message qui sera affiché lorsque
    l'utilisateur entre dans le répertoire où ce fichier se trouve.
</ul>

<p>
<a name= "ftpchroot"></a>
<h2>10.13 - Confiner les utilisateurs à leur répertoire
    HOME avec ftpd(8)</h2>

<p>
Par défaut, lorsque les utilisateurs se connectent en ftp, ils peuvent
aller dans n'importe quel répertoire du système, dans la mesure où les
contrôles d'accès leur permettent.
Dans certains cas, ce comportement peut ne pas être souhaitable.
Il est possible de restreindre les utilisateurs ftp à leur répertoire
HOME en utilisant "chroot".

<p>
Si vous voulez autoriser les connexions ftp en chroot, utilisez l'option
<b>-A</b> de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>.

<p>
Si vous voulez utiliser chroot de manière plus fine, consultez
"<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=login.conf&amp;sektion=5">login capability infrastructure</a>" et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>
<p>

Les utilisateurs appartenant à une classe de connexion où la variable
<tt>ftp-chroot</tt> est positionnée seront automatiquement mis dans un
chroot.
De plus, vous pouvez ajouter un nom d'utilisateur au fichier
<b>/etc/ftpchroot</b> pour mettre ces utilisateurs dans un chroot.
Un utilisateur a uniquement besoin d'être listé dans un de ces endroits.

<p>
<a name= "Patches"></a>
<h2>10.15 - Appliquer des correctifs sous OpenBSD</h2>

<p>
Même avec OpenBSD, des bogues apparaissent de temps à autre.
Certaines bogues causent des problèmes de fiabilité (par exemple,
quelque chose peut amener le système à ne plus fonctionner
correctement). D'autres bogues causent des problèmes de sécurité (qui
peuvent permettre à d'autres personnes d'utiliser votre machine de façon
inattendue).
Lorsqu'un bogue critique est trouvé, le correctif sera mis en place au
niveau de l'arborescence du code source <i>-current</i>. Ce correctif
sera ensuite propagé vers les <a href="faq5.html#Flavors">versions
maintenues</a> d'OpenBSD.

Ces correctifs apparaissent sur la
<a href="../../fr/errata.html">page web des errata</a>. Ils sont séparés
en correctifs "communs" applicables à toutes les <a
href="../../fr/plat.html">plates-formes</a>, et en correctifs
applicables à une ou plusieurs plates-formes mais pas toutes.

<p>
Cependant, il est à noter qu'il n'y a pas de correctifs pour les
nouvelles fonctionnalités ajoutées à OpenBSD. Les correctifs corrigent
uniquement des problèmes de stabilité ou de sécurité qui doivent être
réglés très rapidement sur les systèmes impactés (mais pas tous
les systèmes vu que l'application de tel ou tel correctif dépend des
applications utilisées).

<p> 
Il existe trois façons d'installer les correctifs sur votre système :

<ul>
<li><b>Mettez à jour votre système en
<a href="current.html"><i>-current</i></a>.</b>
Vu que tous les correctifs sont appliqués systématiquement au code
source de la branche <i>-current</i>, la mise à jour de votre système
avec le dernier snapshot disponible est une excellente façon d'installer
les correctifs.
Cependant, l'utilisation de la branche <i>-current</i> n'est pas adaptée
à tout le monde.
<li><b>Mettez à jour votre système en <a
href="../../fr/stable.html"><i>-stable</i></a>.</b>
Vous pouvez faire ceci en téléchargeant votre arborescence du code
source ou en la mettant à jour en utilisant la branche <i>-stable</i>
appropriée puis en recompilant le noyau et le reste du système
d'exploitation. C'est probablement la méthode la plus aisée mais la
recompilation de tout le système prend du temps. De plus, le
téléchargement complet du code source peut prendre du temps aussi si
vous avez une bande passante limitée.
<li><b>Corrigez, compilez et installer les fichiers impactées
individuellement.</b>
C'est la méthode que nous allons aborder ci-après de manière détaillée.
Bien que cette méthode nécessite peu de bande passante et prend,
typiquement, peu de temps par rapport à un téléchargement ou une mise à
jour via cvs(1) et une compilation complète de tout le système, elle
peut parfois être la plus difficile à utiliser. En effet, il n'y a pas
une procédure universelle à suivre pour la mise à jour. Certaines fois
vous devez mettre en oeuvre un correctif pour une application donnée
puis recompiler et installer cette dernière. D'autres fois, vous aurez
peut-être à recompiler des sections entières de l'arborescence des
sources si le problème est localisé au niveau d'une bibliothèque.</ul>
Encore une fois, la correction de fichiers individuels n'est pas
toujours simple. Pensez à utiliser la deuxième méthode décrite plus haut
et suivre la branche <a href="../../fr/stable.html"><i>-stable</i></a>
(dite aussi la branche "des correctifs") d'OpenBSD.
L'utilisation combinée de ces différentes méthodes est possible si vous
comprenez exactement comment ça fonctionne. Les nouveaux utilisateurs
devront choisir une seule méthode.

<h3>Quelle est la différence entre les correctifs de la page des errata
    et ce qui existe au niveau de la base de données CVS ?</h3>

<p>
Tous les correctifs postés sur la <a href="../../fr/errata.html">page
web des errata</a> concernent uniquement l'arborescence des sources de
la version indiquée dans cette page. Les autres correctifs qui
concernent l'arborescence actuelle de CVS peuvent contenir certaines
modifications qui ne sont peut-être pas désirables sur la version de
production.
Ceci est important : Si vous avez installé un snapshot et que vous avez
téléchargé les arborescences du code source au moment où vous avez
obtenu le snapshot, il se peut que si vous essayer d'appliquer un des
correctifs publiés, ça ne marche pas à cause d'une modification du code
source.



<h3>Application des correctifs</h3>

<p>
Les correctifs d'OpenBSD sont distribués sous la forme de fichiers diff
unifiés.
Ces fichiers sont des fichiers texte qui contiennent les différences par
rapport au code source d'origine. Ils ne sont <b>PAS</b> distribués sous
forme binaire. Cela veut dire que pour appliquer les correctifs, vous
devez avoir à disposition sur votre système le code source de la version
<b>RELEASE </b>d'OpenBSD.
De manière générale, vous devriez avoir à disposition l'arborescence
complète du code source.
Si votre machine héberge une version à partir d'un CDROM officiel,
l'arborescence du code source est disponible sur le disque 3. Elle est
aussi disponible sous forme de fichiers à partir des
<a href="../../fr/ftp.html">serveurs FTP</a>.
Nous allons désormais supposer que vous avez l'arborescence complète à
votre disposition.

<p>
A titre d'exemple, nous allons appliquer le correctif 001 pour OpenBSD
qui corrige un bogue au niveau du pilote
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=st&amp;sektion=4">st(4)</a>
qui gère les lecteurs de bandes magnétiques.
Sans ce correctif, la restauration de sauvegardes est assez difficile.
Les personnes utilisant un lecteur de bandes magnétiques ont
<i>besoin</i> de ce correctif. Les autres personnes peuvent s'en passer.
Jetons un coup d'oeil à ce correctif :

<blockquote><pre>
# <b>more 001_st.patch</b>
Apply by doing:
        patch -p0 < 001_st.patch

Rebuild your kernel.
Index: sys/scsi/st.c
===================================================================
RCS file: /cvs/src/sys/scsi/st.c,v
retrieving revision 1.41
retrieving revision 1.41.2.1
diff -u -p -r1.41 -r1.41.2.1
--- sys/scsi/st.c       1 Aug 2004 23:01:06 -0000       1.41
+++ sys/scsi/st.c       2 Nov 2004 01:05:50 -0000       1.41.2.1
@@ -1815,7 +1815,7 @@ st_interpret_sense(xs)
        u_int8_t skey = sense->flags &amp; SSD_KEY;
        int32_t info;
 
-       if (((sense-&gt;flags & SDEV_OPEN) == 0) ||
+       if (((sc_link-&gt;flags & SDEV_OPEN) == 0) ||
            (serr != 0x70 && serr != 0x71))
                return (EJUSTRETURN); /* let the generic code handle it */
</pre></blockquote>

Comme vous pouvez le constater, le début du patch inclut de brèves instructions
sur la façon de l'appliquer. Nous admettrons que vous avez placé ce patch dans
le répertoire <tt>/usr/src</tt> auquel cas les étapes suivantes seront
utilisées :

<blockquote><pre>
# <b>cd /usr/src</b>
# <b>patch -p0 &lt; 001_st.patch</b>
Hmm...  Looks like a unified diff to me...
The text leading up to this was:
--------------------------
|Apply by doing:
|        cd /usr/src
|        patch -p0 &lt; 001_st.patch
|
|Rebuild your kernel.
|
|Index: sys/scsi/st.c
|===================================================================
|RCS file: /cvs/src/sys/scsi/st.c,v
|retrieving revision 1.41
|retrieving revision 1.41.2.1
|diff -u -p -r1.41 -r1.41.2.1
|--- sys/scsi/st.c      1 Aug 2004 23:01:06 -0000       1.41
|+++ sys/scsi/st.c      2 Nov 2004 01:05:50 -0000       1.41.2.1
--------------------------
Patching file sys/scsi/st.c using Plan A...
Hunk #1 succeeded at 1815.              <i>&lt;-- Ce message indique le
succès de l'opération</i>
done
</pre></blockquote>

Le message "<tt>Hunk #1 succeeded</tt>" indique que le correctif a été
appliqué avec succès.
Plusieurs correctifs sont plus complexes que l'exemple utilisé, et
impliqueront de multiples "hunks" et fichiers. Dans ce cas, il faudrait
que vous vous assuriez que tous les "hunks" ont été appliqués avec
succès pour tous les fichiers concernés. 
Si ce n'est pas le cas, ceci veut normalement dire que votre
arborescence du code source n'est pas bonne, que vous n'avez pas suivi
les instructions, ou que le correctif ne correspond pas au correctif
originel.
Les correctifs sont très sensibles aux espaces blancs -- un
copier/coller depuis votre navigateur changera la plupart du temps les
caractères de tabulation en espaces ou modifiera les espaces blancs de
telle façon à rendre le correctif inutilisable.

<p>
Vous pouvez maintenant <a href="faq5.html#Building">recompiler le
noyau</a> comme d'habitude, l'installer et redémarrer le système.

<p>
Les correctifs ne s'appliquent pas systématiquement au noyau.
Dans certains cas, vous devrez recompiler des utilitaires. Dans
d'autres, vous devrez recompiler tous les utilitaires liés statiquement
à une bibliothèque sujette à correction.
Suivez les instructions dans l'en-tête du correctif, et si vous n'êtes
pas certain, recompilez tout le système.

<p>
Les correctifs qui n'impactent pas directement votre utilisation du
système n'ont pas besoin d'être appliqués normalement.
Par exemple, si vous n'aviez pas de lecteur de bande magnétique dans
votre système, vous ne bénéficierez pas du correctif ci-dessus.
Cependant, les correctifs sont supposés être appliqués dans l'ordre. Il
est donc possible qu'un correctif ultérieur dépend d'un correctif apparu
plutôt.
Soyez conscient de ce mode de fonctionnement si vous sélectionnez la
méthode consistant à choisir vous-même vos correctifs. Si vous avez un
doute, appliquez-les tous, dans l'ordre de leur mise à disposition.

<a name="httpdchroot"></a>
<h2>10.16 - Parlez moi de chroot(2) Apache ?</h2>

<p>
Sous OpenBSD, le serveur 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
d'Apache est 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>é
par défaut. Etant un grand pas en avant du point de vue de la sécurité,
cela peut créer des problèmes si vous n'y êtes pas préparé.

<h3>Qu'est-ce qu'un chroot ?</h3>

Une application 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>ée
est bloquée dans un répertoire spécifique et ne peut errer dans les
autres répertoires de l'arbre du système de fichiers et voit ce
répertoire comme son répertoire <tt>/</tt> (root). Dans le cas
d'httpd(8), le programme démarre, ouvre ses fichiers log, ouvre ses
ports TCP (bien qu'il n'accepte pas encore de données), et lit son
fichier de configuration. Ensuite, il se fixe lui-même dans le
répertoire <i>/var/www</i> et baisse ses privilèges. Ce qui veut dire
que tous les fichiers servis et utilisés par Apache, doivent être dans
le répertoire <i>/var/www</i>. Dans la configuration par défaut
d'OpenBSD, tous les fichiers du répertoire <i>/var/www</i> sont en
lecture seule pour l'utilisateur qui fait tourner Apache, <i>www</i>.
Cela aide considérablement la sécurité ;
si il devait y avoir un problème de sécurité, les dégâts seraient
confinés dans un seul répertoire avec les permissions de "lecture seule"
et aucune ressource pour causer des problèmes.

<h3>Qu'est-ce que cela signifie pour l'administrateur ?</h3>

<p>
En gros, chroot(2)er Apache est quelque chose qui n'est pas adopté par
la plupart des autres systèmes d'exploitation. Beaucoup d'applications
et de configurations système ne fonctionneront plus comme avant sans
aménagement. De plus, il faut se souvenir que sécurité et commodité sont
souvent incompatibles.
L'implémentation d'Apache sous OpenBSD ne sacrifie pas la sécurité aux
profit des capacités ou de la "facilité".

<ul>
<li><b>Hiérarchie historique du système de fichiers :</b>
Les serveurs mis à jour depuis d'anciennes versions d'OpenBSD peuvent
avoir les fichiers web situés dans les répertoires HOME des
utilisateurs, ce qui clairement ne fonctionnera pas dans un
environnement chroot(2)é étant donné qu'httpd(8) ne peut atteindre le
répertoire <i>/home</i>. Les administrateurs découvriront peut-être que
leur partition /var/www existante est trop petite pour accueillir tous
les fichiers web. Vos options sont dès lors de restructurer votre
système ou de ne pas utiliser l'option du chroot(2). Vous pouvez, bien
évidemment, utiliser des liens symboliques dans le répertoire HOME de
l'utilisateur pointant vers les sous-répertoires dans
<i>/var/www</i>, mais vous ne pouvez PAS utiliser des liens dans
<i>/var/www</i> pointant vers une autre partie du système de
fichier -- ceci ne peut fonctionner dû au chroot(2). Notez que si
vous voulez que vos utilisateurs aient un
<a href="faq10.html#ftpchroot">accès FTP chroot(2)é</a>,
ceci ne fonctionnera pas plus étant donné que le chroot FTP va (à
nouveau) vous empêcher d'accéder aux destinations de ces liens
symboliques. Une solution est donc, de ne pas utiliser <i>/home</i>
comme répertoire HOME pour ces utilisateurs mais plutôt quelque chose
similaire à <i>/var/www/users</i>.
Les liens symboliques sont totalement utilisables à l'intérieur du
chroot(2) mais ceux-ci doivent être relatifs et non absolus.

<li><b>Rotation des fichiers log :</b> Normalement, une rotation des
fichiers log est réalisée en renommant les anciens fichiers, ensuite
en envoyant à httpd(8) un signal SIGUSR1 qui forcera Apache à fermer
ses anciens fichiers logs et à en ouvrir de nouveaux. Ceci n'est
désormais plus possible, étant donné que httpd(8) n'a pas la
possibilité d'ouvrir les fichiers de log en écriture une fois que ses
privilèges ont été abaissés. httpd(8) doit donc être stoppé et 
relancé.
Cela demande parfois quelques secondes pour que tous les processus
enfants se terminent, ce qui est obligatoire avant que httpd(8) ne
puisse redémarrer ; une possibilité de rotation des logs pourrait être :

<blockquote><pre>
# <b>apachectl stop</b>
  <i>rename your log files</i>
# <b>apachectl start ; sleep 10 ; apachectl start</b>
</pre></blockquote> 

Oui, la dernière ligne tente de redémarrer Apache immédiatement et dans
le cas où cela ne fonctionnerait pas, on attend quelques secondes puis
on rééssaye.
Et oui, cela signifie bien que pendant quelques secondes chaque fois que
vous effectuerez une rotation des logs, votre serveur web sera
inaccessible.
Bien que cela puisse poser des problème, n'importe quelle tentative pour
permettre à httpd(8) de rouvrir des fichiers après avoir
chroot(2)é ira à l'encontre de l'intérêt même du chroot !

Il existe néanmoins d'autres techniques, notamment loguer vers un
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pipe&amp;sektion=2">pipe(2)</a>, 
et utiliser un programme extérieur afin de réaliser une rotation des
fichiers à la fin du pipe.

<li><b>Modules Apache existants :</b> Pratiquement, ils se lanceront
    tous, cependant, certains pourraient ne pas fonctionner correctement
    dans le chroot(2), et pourraient causer des problèmes lors de
"<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=apachectl&amp;sektion=8">apachectl</a> 
    restart"</tt>, générant une erreur, causant httpd(8) à se stopper.

<li><b>CGIs existants :</b> La plupart ne fonctionneront pas tels quels.
    Ils auront certainement besoin de programmes ou de bibliothèques se
    trouvant hors de <i>/var/www</i>. Certains peuvent être corrigés en
    étant compilés statiquement (n'ayant pas besoin de bibliothèques se
    trouvant dans un autre répertoire), la plupart peuvent être corrigés
    en copiant dans <i>/var/www</i> les fichiers nécessaires à
    l'application, bien que cette manoeuvre soit non triviale et
    requiert une certaine connaissance du programme.

<li><b>Options de montage du système de fichiers :</b>
Par défaut sous OpenBSD, votre partition <i>/var</i> est monté avec les
options <tt>nosuid</tt> et <tt>nodev</tt>/
Si vous tentez d'utiliser une application à l'intérieur du chroot, vous
serez peut-être amené à changer ces options.
Bien entendu, il est possible que vous ayez besoin d'effectuer ces
changements même si vous n'utiliser pas l'option du chroot.

<li><b>Résolution de noms :</b>
httpd(8) à l'intérieur de chroot(2) NE sera pas capable d'utiliser
<i>/etc/hosts</i> ou <i>/etc/resolv.conf</i>. Par conséquent, si vous avez
applications qui nécessitent la résolution de nom, vous devrez remplir
<i>/var/www/etc/hosts</i> et/ou <i>/var/www/etc/resolv.conf</i> dans
l'environnement chroot(2). Il est à noter que certaines applications
ont besoin de faire la résolution de "localhost" pour fonctionner.

</ul>

Dans certains cas, les applications ou les configurations peuvent être
changées pour fonctionner dans le chroot(2). Dans d'autres cas, vous
devrez tout simplement retirer cette option en utilisant l'option
<tt>-u</tt> de httpd(8) dans<i>
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8">/etc/rc.conf.local</a></i>.

<h3>Exemple de chroot(2) d'une application : wwwcount</h3>

Voyons comment mettre en place chroot(2) pour une application à travers
un exemple. Cet exemple se base sur wwwcount, un compteur tout simple
d'accès aux pages web disponible dans les
<a href="../fr/faq15.html#PkgMgmt">paquetages</a>. Bien qu'il soit un
programme très efficace, wwwcount ne sait rien d'Apache chroot(2)é et ne
fonctionnera pas dans un environnement chroot(2)é avec sa configuration
de base.

<p>
Tout d'abord, nous installons le paquetage
<a href="http://www.muquit.com/muquit/software/Count/Count.html">wwwcount</a>.
Nous le configurons et le testons et c'est là que nous en déduisons
qu'il ne semble pas fonctionner : Apache nous affiche le message
"Internal Server Error".

La première étape consiste à arrêter Apache et à le redémarrer avec
l'option <tt>-u</tt> pour vérifier que le problème vient bien du
chroot(2) et pas de la configuration système.

<blockquote><pre>
# <b>apachectl stop</b>
/usr/sbin/apachectl stop: httpd stopped
# <b>httpd -u</b>
</pre></blockquote>

Après avoir fait cela, nous constatons que le compteur fonctionne
correctement, du moins après avoir changé les droits d'un répertoire
afin qu'Apache (et les CGIs qu'il exécute) puisse écrire à des fichiers.
Ainsi, nous sommes maintenant certains que le problème vient du chroot.
Nous arrêtons alors et redémarrons Apache à nouveau en utilisant le
chroot par défaut :

<blockquote><pre>
# <b>apachectl stop</b>
/usr/sbin/apachectl stop: httpd stopped
# <b>httpd</b>
</pre></blockquote>

<p>
Un bon point pour commencer serait de supposer que wwwcount utilise des
bibliothèques et d'autres fichiers qu'il ne peut accéder une fois dans le
chroot. On peut utiliser à cet effet la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ldd&amp;sektion=1">ldd(1)</a>
pour trouver les dépendances dynamiques dont le CGI a besoin :

<blockquote><pre>
# <b>cd /var/www/cgi-bin/</b>
# <b>ldd Count.cgi</b>
Count.cgi:
        Start    End      Type Open Ref GrpRef Name
        1c000000 3c007000 exe  1    0   0      /var/www/cgi-bin/Count.cgi
        0c085000 2c0be000 rlib 0    1   0      /usr/lib/libc.so.50.1
        08713000 08713000 rtld 0    1   0      /usr/libexec/ld.so
</pre></blockquote>
Ah ! voilà un problème. Deux fichiers ne sont pas disponibles dans
l'environnement chroot(2). Alors, on les copie dans cet environnement :

<blockquote><pre>
# <b>mkdir -p /var/www/usr/lib /var/www/usr/libexec</b>
# <b>cp /usr/lib/libc.so.50.1 /var/www/usr/lib</b>
# <b>cp /usr/libexec/ld.so /var/www/usr/libexec</b>
</pre></blockquote>
Puis nous essayons le compteur à nouveau.

<p>
Au moins, le programme s'exécute maintenant et nous affiche des messages
d'erreur directement : "Unable to open config file for reading". Nous
avons bien progressé mais nous n'avons pas encore fini. Le fichier de
configuration se trouve normalement dans le répertoire
<tt>/var/www/wwwcount/conf</tt>, mais au sein de l'environnement chroot,
le programme devrait le voir sous <tt>/wwwcount/conf</tt>.
Nous avons donc deux options. Soit nous recompilons le programme pour
qu'il tienne compte du nouveau fichier de configuration par défaut (où
plutôt du chemin pour l'atteindre) soit nous déplaçons les fichiers de
données. Vu que nous avons installé le programme à partir d'un paquetage,
nous prenons l'option 2, à savoir le déplacement des fichiers de
données. Afin que nous puissions utiliser exactement la même
configuration dans un environnement chroot(2)é ou pas, nous utiliserons
un lien symbolique :

<blockquote><pre>
# <b>mkdir -p /var/www/var/www</b>
# <b>cd /var/www/var/www</b>
# <b>ln -s ../../wwwcount wwwcount</b>
</pre></blockquote>
Remarquez que le lien symbolique a été pensé pour fonctionner au sein du
chroot. Nous testons notre programme à nouveau et nous voilà avec un
autre problème.
Maintenant wwwcount se plaint de ne pas trouver les fichiers "strip
image" qu'il utilise pour afficher des messages. Après quelques
recherches, nous nous rendons compte que ces fichiers sont stockés dans
<tt>/usr/local/lib/wwwcount</tt>, nous devons donc les copier dans le
chroot aussi.

<blockquote><pre>
# <b>tar cf - /usr/local/lib/wwwcount | (cd /var/www; tar xpf - )</b>
</pre></blockquote>
Nous testons à nouveau ... et ça marche !

<p>
Notez que nous n'avons copié que les fichiers strictement nécessaires au
bon fonctionnement.
En général, seuls les fichiers nécessaires à l'application doivent être
copiés dans le chroot.

<h3>Dois-je utiliser chroot ?</h3>
Dans l'exemple précédent, le programme est relativement simple et
pourtant nous avons rencontré différents types de problèmes.

<p>
<i>Toutes les applications ne peuvent ou ne devraient pas être
chroot(2)ées.</i>

<p>
Le but est la mise en place d'un serveur web sécurisé et le chroot(2)age
n'en est qu'un outil, pas un but en soi.
Souvenez-vous, la configuration initiale de l'Apache chroot(2)é sous
OpenBSD fait en sorte que l'utilisateur sous lequel le programme
httpd(8) tourne ne peut pas lancer de programme, ne peut pas modifier de
fichiers et ne peut pas prendre l'identité d'un autre utilisateur.
Réduire ces restrictions diminuera votre sécurité, chroot ou pas.

<p>
Certaines applications sont relativement
simples et les mettre dans un chroot(2) n'a aucun sens. D'autres sont
très complexes. Elles ne valent pas les efforts nécessaires pour les
mettre en chroot(2) et même si c'était le cas, vous perdriez les
avantages du chroot(2) après avoir copié la masse importante de fichiers
dont elles ont besoin pour fonctionner.
Ainsi le programme OpenWebMail a besoin de pouvoir lire et écrire dans
le répertoire mail, le répertoire home de l'utilisateur et doit pouvoir
travailler en tant que n'importe quel utilisateur du système.
Essayer le mettre cette application en chroot serait inutile car vous
serez obliger de désactiver tous les bénéfices du chroot(2)age.
Même avec des applications aussi simples que le compteur précédent, il
doit pouvoir écrire sur le disque (pour garder la trace de ses
compteurs) et donc, une <i>partie</i> du bénéfice du chroot(2) est
perdue.

<p>
Toute application qui doit fonctionne sous root ne vaut pas le coup
d'être chroot(2)ée puisque root peut généralement s'échapper du
chroot(2).

<p>
N'oubliez pas, si la procédure de chroot pour votre application est trop
complexe vous pourriez ne pas mettre à jour votre système aussi souvent
qu'il le faudrait.
Ceci pourrait rendre votre système MOINS sécurisé qu'un système plus
facilement administrable et dont le chroot est désactivé.

<a name="rootshell"></a>
<!-- XXXversion - root shell is now ksh -->
<h2>10.17 - Puis-je changer le shell de l'utilisateur root ?</h2>
Il est parfois dit qu'il ne faut pas changer le shell de l'utilisateur
root, bien qu'il n'y ait aucune raison de ne pas le faire sous OpenBSD.

<p>
Le shell par défaut sur OpenBSD de l'utilisateur <i>root</i> est
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>.

<p>
Une directive Unix traditionnelle est d'utiliser pour l'utilisateur root
des shells compilés statiquement, car si votre système démarre en mode
utilisateur unique, les partitions non-root ne seront pas montées et les
shells liés dynamiquement ne seront pas capable d'accéder aux bibliothèques
situées dans la partition <tt>/usr</tt>. Ceci n'étant pas très important
pour OpenBSD, car le système vous demandera de choisir un shell lors
d'un démarrage en mode utilisateur unique, le shell par défaut étant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>.

Les trois shells standards sous OpenBSD 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=csh&amp;sektion=1">csh</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>
et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>)
sont liés statiquement et donc utilisables en mode utilisateur unique.

<a name="ksh"></a>
<h2>10.18 - Que puis-je faire d'autre avec <i>ksh</i> ?</h2>
Sous OpenBSD,  
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>
est 
<a href="http://web.cs.mun.ca/~michael/pdksh/">pdksh</a>, 
le Shell Korn du Domaine Public (Public Domain Korn Shell), et est le
même binaire que
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>.

<p>
Les utilisateurs qui sont à l'aise avec <i>bash</i>, souvent utilisé sur
les systèmes Linux, trouveront probablement
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>
très familier. Ksh(1) offre la plupart des options habituellement
utilisées avec <i>bash</i>, notamment l'achèvement des commandes avec la
touche tab, l'édition de la ligne de commande et l'historique via les
touches fléchées, et CTRL-A/CTRL-E pour aller au début/à la fin de la
ligne de commande. Si vous désirez d'autres options de <i>bash</i>,
<i>bash</i> peut être installé soit via les
<a href="../fr/faq15.html#PkgMgmt">paquetages</a> ou soit via les
<a href="../fr/faq15.html#Ports">ports</a>.

<p>
Le prompt de <i>ksh</i> peut être facilement changé de manière à fournir
plus d'informations que le simple "$ " par défaut en modifiant la
variable <tt>PS1</tt>. Par exemple, en insérant la ligne suivante :

<blockquote><pre>
export PS1='$PWD $ '
</pre></blockquote> 

dans votre <tt>/etc/profile</tt>, cela produira le prompt suivant :

<blockquote><pre>
/home/nick $
</pre></blockquote>
 
Consultez le fichier 
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/etc/ksh.kshrc?content-type=text/plain"><tt>/etc/ksh.kshrc</tt></a>,
qui inclut plusieurs options utiles ainsi que des exemples, et qui peut
être invoqué dans les fichiers <tt>.profile</tt> de vos utilisateurs.


<p>
ksh(1) sous OpenBSD a été amélioré. Un certain nombre de caractères
spéciaux ont été ajoutés au niveau de la chaîne primaire de l'invite de
commandes, PS1. Ces caractères sont similaires à ceux présents dans
bash.
Par exemple :
<blockquote>
<tt>\e - </tt>Insertion d'un caractère d'échappement ASCII.<br>
<tt>\h - </tt>Le nom d'hôte sans le nom de domaine.<br>
<tt>\H - </tt>Le nom d'hôte complet, avec le nom de domaine.<br>
<tt>\n - </tt>Insertion d'un caractère de retour à la ligne.<br>
<tt>\t - </tt>L'heure actuelle, sur 24 heures, au format HH:MM:SS.<br>
<tt>\u - </tt>Le nom de l'utilisateur actuel.<br>
<tt>\w - </tt>Le répertoire de travail actuel. $HOME est abrégé en `~'.<br>
<tt>\W - </tt>La racine du répertoire de travail actuel.<br>
<tt>\$ - </tt>Affiche "#" pour les super-utilisateurs, et "$" pour les autres
</blockquote>

(consultez la page du manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh(1)</a>
pour plus de détails , et beaucoup, beaucoup plus de caractères spéciaux !
Veuillez noter que le caractère "$" a une signification spéciale à
l'intérieur des double quotes. Il est donc à manipuler avec précaution)

<p>
Vous pouvez par exemple utiliser la commande suivante :
<blockquote><pre>
export PS1="\n\u@\H\n\w \\$ "
</pre></blockquote>
pour disposer d'une invite de commandes très parlante mais dont
l'utilité n'est que relative.


<p>
<a name="Dir"></a>
<h2>10.19 - Services d'Annuaires</h2>

<p>
OpenBSD peut-être utilisé aussi bien comme client que serveur de bases de
données contenant l'identification de l'utilisateur, l'information sur les
groupes et d'autres données liées au réseau.

<p>
<a name="Dir.available"></a>
<h3>10.19.1 - Quels sont les services d'annuaires disponibles ?</h3>

<p>
Evidemment vous pouvez utiliser différents services d'annuaires sur OpenBSD.
Mais YP est le seul qui peut-être accessible directement en utilisant les
fonctions standards de la librairie C comme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getpwent&amp;sektion=3">getpwent(3)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getgrent&amp;sektion=3">getgrent(3)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&amp;sektion=3">gethostbyname(3)</a> 
et bien d'autres.
Donc, si vous conservez vos données dans une base de données YP, vous n'avez
pas besoin de les copier dans les fichiers de configuration locaux comme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=master.passwd&amp;sektion=5">master.passwd(5)</a> 
avant de l'utiliser, par exemple pour authentifier des utilisateurs système.

<p>
YP est un service d'annuaire compatible avec
Sun Microsystems NIS (Network Information System).
Regardez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=yp&amp;sektion=8">yp(8)</a>
pour un aperçu des pages de manuel disponibles.
Soyez prudent, certains systèmes d'exploitation possédent des services
d'annuaires qui contiennent des noms similaires mais qui sont incompatibles,
comme par exemple NIS+.

<p>
Pour utiliser d'autres services d'annuaires à l'exception de YP, vous avez
besoin de remplir les fichiers de configuration locaux de l'annuaire ou vous
avez besoin d'un frontal YP pour l'annuaire. 
Par exemple, vous pouvez utiliser le port <tt>sysutils/login_ldap</tt> quand
vous choisissez le premier, alors que le daemon 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ypldap&amp;sektion=8">ypldap(8)</a> 
fournit ce dernier.

<p>
Pour certaines applications, synchroniser simplement un petit nombre de
fichiers de configuration sur un groupe de machines en utilisant des outils
comme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">scp(1)</a> 
ou <tt>rsync</tt> (disponible dans les ports) constitue une alternative
robuste et facile à un service d'annuaire complet.

<a name="YP_secure"></a> 
<h3>10.19.2 - Considérations sur la sécurité de YP</h3>

<p>
Pour des raisons de compatibilité, toutes les fonctionnalités de sécurité
de OpenBSD construites dans l'implémentation de YP sont <em>désactivées</em>
par défaut.
Même quand elles sont toutes activées, le protocole NIS reste intrinsèquement 
non sécurisé pour deux raisons :
Toutes les données, incluant les données sensibles comme les hashs de mot de
passe, sont transmises non chiffrées sur le réseau, et ni le client ou le
serveur ne peut vérifier de maniére fiable l'identité de l'autre.

<p>
Donc, avant de mettre en place un serveur YP, vous devez considérer ces
faiblesses de sécurité intrinsèque comme acceptable dans votre contexte.
En particulier, YP n'est pas adapté si des attaquants potentiels ont un
accés physique à votre réseau.
Quiconque obtient l'accés root d'un des ordinateurs connecté sur l'un de vos
segment réseau faisant transiter du trafic YP peut se connecter sur votre
domaine YP et récupérer des données.
Dans certains cas, faire transiter du trafic YP à travers des tunnels SSL ou
IPSec peut-être une option, ou vous devrez considérer de combiner YP avec une
authentification
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kerberos&amp;sektion=8">kerberos(8)</a>.

<a name="YP_server"></a> 
<h3>10.19.3 - Configurer un serveur YP</h3>

<ol>
<li><p>	
Un serveur YP sert un groupe de clients appelé un "domaine".
Vous devez d'abord choisir un nom de domaine; cela peut-être une chaine
arbitraire et ne doit pas avoir de lien avec les noms de domaines DNS.
Choisir un nom aléatoire comme "Eepoo5vi" peut améliorer de façon marginale
la sécurité, avec l'effet d'être plutôt de la sécurité par l'obscurité.
Dans le cas ou vous devez maintenir plusieurs domaines YP distincts, il est
surement meilleur de choisir des noms de description comme "ventes",
"marketing" et "recherche" pour ne pas avoir d'erreurs d'administration
système causées par l'obscurité.
Il faut aussi remarquer que certaines versions de SunOS doivent utiliser le
nom de domaine DNS de l'hôte, donc votre choix est plutôt restreint dans un
réseau incluant de tels hôtes.

<p>
Utilisez l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=domainname&amp;sektion=1">domainname(1)</a> 
pour configurer le nom de domaine et le mettre dans le fichier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=defaultdomain&amp;sektion=5">defaultdomain(5)</a> 
pour qu'il soit automatiquement configuré au démarrage du système. 

<blockquote><pre>
echo "puffynet" > /etc/defaultdomain
domainname `cat /etc/defaultdomain`
</pre></blockquote>

<li><p>
Initialiser le serveur YP en utilisant la commande intéractive :

<blockquote><pre>
ypinit -m
</pre></blockquote>

A ce stade, il n'est plus nécessaire de spécifier les serveurs esclaves.
Pour ajouter des serveurs esclaves, vous pourrez relancer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ypinit&amp;sektion=8"
>ypinit(8)</a> plus tard, en utilisant l'option <tt>-u</tt>.
Configurer au moins un serveur esclave pour chaque domaine est utile pour
éviter les interruptions de service, le serveur maître pourrait s'arrêter ou
perdre sa connectivité réseau, en particulier les processus clients
essaieront d'accéder aux blocs de tables YP indéfiniment tant qu'ils ne
reçevront pas les informations demandées. Donc, les interruptions de service
YP rendront typiquement les hôtes clients complétement inutilisables tant
que le service YP n'est pas de retour.

<li><p>
Il faut décider ou stocker les fichiers sources pour générer vos tables YP
initiales.
Garder distincte la configuration du serveur de la configuration du service
aide à contrôler quelle information sera donnée de celle qui ne le sera pas,
donc le répertoire par défaut <tt>/etc</tt> n'est pas souvent le meilleur
choix.

<p>
Le seul inconvénient causé par le changement de répertoire source est que
vous ne pourrez plus ajouter, supprimer ou modifier des utilisateurs et des
groupes dans le domaine YP en utilisant des utilitaires comme
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=user&amp;sektion=8">user(8)</a>
et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=group&amp;sektion=8">group(8)</a>.
A la place, vous devrez éditer les fichiers de configuration avec un éditeur
de texte.

<p>
Pour définir le répertoire source, éditez le fichier 
<tt>/var/yp/`domainname`/Makefile.yp</tt>
et modifiez la variable <tt>DIR</tt>, par exemple :

<blockquote><pre>
DIR=/etc/yp/src/puffynet
</pre></blockquote>

<li><p>
Considérez la possibilité de personnalisation d'autres variables dans
<tt>/var/yp/`domainname`/Makefile</tt>. Regardez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=Makefile.yp&amp;sektion=8"
>Makefile.yp(8)</a> pour plus de détails.

<p>
Par exemple, même dans le cas ou vous utilisez le répertoire source par
défaut <tt>/etc</tt>, vous n'avez généralement pas besoin de tous les
comptes et groupes existants sur le serveur pour tous les hôtes clients.
En particulier, ne pas fournir de compte root et garder le hash du compte
root confidentiel est souvent bénéfique pour la sécurité.
Etudiez les valeurs des variables <tt>MINUID</tt>, <tt>MAXUID</tt>,
<tt>MINGID</tt> et <tt>MAXGID</tt> et ajustez les selon vos besoins.

<p>
Si tous vos clients YP utilisent OpenBSD ou FreeBSD, excluez les mots de
passe chiffrés de la table <tt>passwd</tt> en configurant <tt>UNSECURE=""</tt> 
dans <tt>/var/yp/`domainname`/Makefile.yp</tt>.

<p>
La pratique courante d'éditer le fichier modèle <tt>/var/yp/Makefile.yp</tt>
n'est plus recommandé. Les changements dans ce fichier affectent tous les
domaines initialisés aprés le changement, mais n'affecte pas les domaines
initialisés avant le changement, il s'agit donc d'erreurs de toute façon :
vous risquez que les changements attendus ne soient pas pris en compte, et
vous risquez de les oublier et qu'ils affectent d'autres domaines plus tard
alors que cela n'était pas voulu. 

<li><p>
Créez le répertoire source et le remplir avec les fichiers de configuration
dont vous avez besoin. Regardez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=Makefile.yp&amp;sektion=8">Makefile.yp(8)</a> 
pour savoir quel table YP a besoin de quel fichier source.
Pour le format de fichier de configuration individuel, consultez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=passwd&amp;sektion=5">passwd(5)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=group&amp;sektion=5">group(5)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">hosts(5)</a> 
voir plus, et regardez les exemple dans <tt>/etc</tt>.

<li><p>
Créez la version initiale de votre table YP en utilisant les commandes

<blockquote><pre>
cd /var/yp
make
</pre></blockquote>

Ne vous inquiétez pas des messages d'erreurs de 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=yppush&amp;sektion=8"
>yppush(8)</a> maintenant.
Le serveur YP ne fonctionne pas encore.

<li><p>
YP utilise les
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rpc&amp;sektion=3">rpc(3)</a> 
(remote procedure calls) pour communiquer avec ces clients,
il est donc nécessaire d'activer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>.
Pour le faire, éditez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8">rc.conf.local(8)</a> 
et configurez <tt>portmap=YES</tt>.
Cela démarrera le portmapper au prochain redémarrage.
Vous pouvez aussi éviter de redémarrer en le démarrant manuellement :

<blockquote><pre>
echo "portmap=YES" >> /etc/rc.conf.local
portmap
</pre></blockquote>

<li><p>
Pensez à utiliser soit le
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=securenet&amp;sektion=5">securenet(5)</a> 
ou les fonctionnalités de sécurité de votre serveur daemon YP dans
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ypserv.acl&amp;sektion=5">ypserv.acl(5)</a>.
Mais sachez que les deux ne fournissent seulement que du contrôle d'accès IP.
Ainsi, ils aident aussi longtemps que des agresseurs potentiels n'ont ni
l'accès physique au matériel du réseau transportant des segments de votre
trafic YP, ni l'accès root de toute machine connectée sur ces segments réseaux.

<li><p>
Finalement démarrez le daemon serveur YP :

<blockquote><pre>
ypserv
</pre></blockquote>

Il démarrera automatiquement à chaque redémarrage aussi longtemps que le
répertoire <tt>/var/yp/`domainname`</tt> continuera d'exister.

<li><p>
Pour tester le nouveau serveur, faite le devenir son propre client en
suivant les instructions de la première partie de la section suivante. 
Dans le cas ou vous ne voulez pas que le serveur utilise ces propres tables,
vous pouvez désactiver la partie cliente après le test avec les commandes
suivantes :

<blockquote><pre>
pkill ypbind
rm -rf /var/yp/binding
</pre></blockquote>

<li><p>
Si vous désirez permettre aux utilisateurs de changer leurs mots de passe
des machines clientes, vous devez activer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=yppasswdd&amp;sektion=8">yppasswdd(8)</a> :

<blockquote><pre>
echo 'yppasswdd_flags="-d /etc/yp/src/puffynet"' >> /etc/rc.conf.local
rpc.yppasswdd
</pre></blockquote>

Dans le cas ou vous utilisez le répertoire source par défaut dans <tt>/etc</tt>,
utilisez juste <tt>yppasswdd_flags=""</tt>.

<li><p>
Rappelez vous que chaque fois que vous changez un fichier source d'une
table YP, vous devez regénérer vos tables YP.

<blockquote><pre>
cd /var/yp
make
</pre></blockquote>
</ol>

Cela va mettre à jour tous les fichiers de bases de données dans <tt>/var/yp/`domainname`</tt>,
avec une exception : le fichier <tt>ypservers.db</tt>, contenant tous les 
serveurs YP maitres et esclaves associés avec le domaine, qui est crée
directement avec <tt>ypinit -m</tt> et modifié exclusivement par <tt>ypinit -u</tt>.
Dans le cas ou vous l'avez supprimé accidentellement, executez <tt>ypinit -u</tt>
pour le recréer de zéro.
</ol>

<a name="YP_client"></a> 
<h3>10.19.4 - Configurer un client YP</h3>

Configurer un client YP comprend deux parties distinctes.
En premier, vous devez exécuter le daemon YP client,
connecter votre hôte client au serveur YP.
Finaliser les points suivants vous permettra de récuperer les données du
serveur YP, mais ces données ne seront pas encore utilisables par le système :

<ol>
<li><p>
Comme sur le serveur, vous devez configurer le nom de domaine et activer le
portmapper:

<blockquote><pre>
echo "puffynet" > /etc/defaultdomain
domainname `cat /etc/defaultdomain`
echo "portmap=YES" >> /etc/rc.conf.local
portmap
</pre></blockquote>

<li><p>
Il est recommandé de fournir une liste de serveurs YP dans le fichier de
configuration <tt>/etc/yp/`domainname`</tt>.
Sinon le daemon client YP utilisera des broadcasts réseaux pour trouver les
serveurs YP pour son domaine.
Spécifier de manière explicite les serveurs et plus robuste et aussi
marginalement moins ouvert aux attaques. 
Si vous n'avez pas configuré de serveurs esclaves, mettez juste le nom du
serveur maître dans <tt>/etc/yp/`domainname`</tt>.

<li><p>
Le daemon client YP est appelé
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ypbind&amp;sektion=8">ypbind(8)</a>.
Le démarrer manuellement créera le répertoire <tt>/var/yp/binding</tt>,
comme cela il sera automatiquement redémarré au démarrage.

<blockquote><pre>
ypbind
</pre></blockquote>

<li><p>
Si tout se passe bien vous devez être capable de faire une requête sur le
serveur YP en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ypcat&amp;sektion=1">ypcat(1)</a> 
et voir votre table passwd retournée.

<blockquote><pre>
ypcat passwd
bob:*:5001:5000:Bob Nuggets:/home/bob:/usr/local/bin/zsh
...
</pre></blockquote>

D'autres outils utiles pour deboguer votre configuration YP inclus
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ypmatch&amp;sektion=1">ypmatch(1)</a> et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=yptest&amp;sektion=8">yptest(8)</a>.
</ol>

La deuxième partie de configuration de votre client YP 
inclus l'édition de fichiers de configuration locale
comme certaines tables YP utilisées par certains moyens offerts par le
système.
Tous les serveurs ne fournissent pas toutes les tables standards supportées
par le système d'exploitation, certains serveurs fournissent aussi des
tables non standards,
et vous n'êtes pas obligé d'utiliser tous les tables.
Laquelle de ces tables doit ou ne doit pas être utilisé,
et à quelles fins elles seront utilisées, est entièrement à la discrétion
de l'administrateur système de l'hôte client.

<p>
Pour une liste des tables standards YP et leur usage standard, regardez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=Makefile.yp&amp;sektion=8">Makefile.yp(8)</a>.
L'utilisation la plus courante des cas :

<ul>
<li><p>
Si vous désirez utiliser tous les comptes utilisateurs de votre domaine YP,
ajoutez la balise par défaut au fichier master.passwd et
reconstruisez la base de données de mot de passe :

<blockquote><pre>
echo '+:*::::::::' >> /etc/master.passwd
pwd_mkdb -p /etc/master.passwd
</pre></blockquote>

Pour des détails sur l'inclusion ou l'exclusion séléctive de comptes
utilisateurs, regardez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=passwd&amp;sektion=5">passwd(5)</a>.
Pour tester si l'inclusion fonctionne, utiliser l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=id&amp;sektion=1">id(1)</a>.

<li><p>
Si vous voulez inclure tous les groupes de votre domaine YP,
ajoutez la balise par défaut YP au fichier group :

<blockquote><pre>
echo '+:*::' >> /etc/group
</pre></blockquote>

Pour des détails sur l'inclusion séléctive de groupes, regardez
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=group&amp;sektion=5">group(5)</a>.

<li><p>
Si vous distribuez des noms d'hôtes via YP, vous devez maintenant regarder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">resolv.conf(5)</a> 
et vérifier que l'ordre de recherche de service d'annuaire est correct.
La plupart des utilisateurs utiliseront une ligne comme celle-là :

<blockquote><pre>
lookup file yp bind
</pre></blockquote>
</ul>


<p>
<font color= "#0000e0">
<a href= "index.html">[Index de la FAQ]</a> 
<a href= "faq9.html">[Section 9 - Migrer vers OpenBSD]</a>
<a href= "faq11.html">[Section 11 - Le système X Window]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a> <br>
<small>
<!--
Originally [OpenBSD: faq10.html,v 1.148 ]<br>
$Translation: faq10.html,v 1.77 2009/11/07 09:22:00 benoit Exp $<br>
-->
$OpenBSD: faq10.html,v 1.72 2009/11/08 22:09:17 tobias Exp $
</small>
</body>
</html>
